 


===================================================================================================================== 
 BÁSICO EM JAVA
 


===================================================================================================================== 
  Expressões aritméticas
OPERADORES ARITMÉTICOS JAVA
+ adição
- subtração
* multiplicação
/ divisão
% resto da divisão ("mod")
Exemplos de expressões aritméticas
2 * 6 / 3 Resultado = 4
3 + 2 * 4 Resultado = 11
(3 + 2) * 4 Resultado = 20
60 / (3 + 2) * 4 Resultado = 48
60 / ((3 + 2) * 4) Resultado = 3
Exemplos com o operador "mod"
14 % 3 Resultado = 2
19 % 5 Resultado = 4
 


===================================================================================================================== 
  Variáveis e tipos primitivos em Java
Declaração de variáveis
int idade = 25;
<tipo> <nome> = <valor inicial>;
                   //(opcional)

//Exemplos:
double altura = 1.68;
char sexo = 'F';


//Uma variável possui:
• Nome (ou identificador)
• Tipo
• Valor
• Endereço
 


===================================================================================================================== 
  Tipos primitivos em Java
byte
short
int
long
float
double
char
boolean
 


===================================================================================================================== 
  Saída de dados em Java
//Para escrever na tela um texto qualquer

//Sem quebra de linha ao final:
System.out.print("Bom dia!");

//Com quebra de linha ao final:
System.out.println("Bom dia!");

//Para escrever o conteúdo de uma variável de algum tipo básico

//Suponha uma variável tipo int declarada e iniciada:
int y = 32;
System.out.println(y);
Para escrever o conteúdo de uma variável
com ponto flutuante
//Suponha uma variável tipo double declarada e iniciada:

double x = 10.35784;

System.out.println(x);
System.out.printf("%.2f%n", x);
System.out.printf("%.4f%n", x);


//ATENÇÃO:
//Para considerar o separador de decimais como ponto, ANTES da declaração do Scanner, faça:
Locale.setDefault(Locale.US);
Para concatenar vários elementos em um
mesmo comando de escrita
//Regra geral para print e println:
//elemento1 + elemento2 + elemento3 + ... + elementoN

System.out.println("RESULTADO = " + x + " METROS");
Para concatenar vários elementos em um
mesmo comando de escrita
//Regra geral para printf:

//"TEXTO1 %f TEXTO2 %f TEXTO3", variavel1, variavel2

System.out.printf("RESULTADO = %.2f metros%n", x);
 


===================================================================================================================== 
  Exercício de fixação
//Em um novo programa, inicie as seguintes variáveis:

String product1 = "Computer";
String product2 = "Office desk";
int age = 30;
int code = 5290;
char gender = 'F';
double price1 = 2100.0;
double price2 = 650.50;
double measure = 53.234567;



//Em seguida, usando os valores das variáveis, produza a seguinte saída na tela do console:

Products:
Computer, which price is $ 2100,00
Office desk, which price is $ 650,50
Record: 30 years old, code 5290 and gender: F
Measue with eight decimal places: 53,23456700
Rouded (three decimal places): 53,235
US decimal point: 53.235
Resolução
import java.util.Locale;

public class Main {
    public static void main(String[] args) {
        // Declaração de variáveis
        String product1 = "Computer"; // String para armazenar o nome do primeiro produto
        String product2 = "Office desk"; // String para armazenar o nome do segundo produto
        byte age = 30; // Variável para armazenar a idade
        int code = 5290; // Variável para armazenar o código
        char gender = 'F'; // Variável para armazenar o gênero
        double price1 = 2100.0; // Variável para armazenar o preço do primeiro produto
        double price2 = 650.50; // Variável para armazenar o preço do segundo produto
        double measure = 53.234567; // Variável para armazenar a medida

        // Imprime o nome e preço dos produtos
        System.out.println("Products:");
        System.out.printf("%s, which price is $ %.2f%n", product1, price1);
        System.out.printf("%s, which price is $ %.2f%n", product2, price2);
        System.out.println();

        // Imprime informações do registro (idade, código e gênero)
        System.out.printf("Record: %d years old, code %d and gender: %c%n", age, code, gender);
        System.out.println();

        // Imprime a medida com 8 casas decimais e arredondada para 3 casas decimais
        System.out.printf("Measue with eight decimal places: %.8f%n", measure);
        System.out.printf("Rouded (three decimal places): %.3f%n", measure);

        // Altera a configuração de ponto decimal para o formato americano
        Locale.setDefault(Locale.US);
        System.out.printf("US decimal point: %.3f%n", measure);
    }
}

 


===================================================================================================================== 
  Processamento de dados em Java, Casting
int x, y;
x = 5;
y = 2 * x;
System.out.println(x);
System.out.println(y);
int x;
double y;
x = 5;
y = 2 * x;
System.out.println(x);
System.out.println(y);
double b, B, h, area;
b = 6.0;
B = 8.0;
h = 5.0;
area = (b + B) / 2.0 * h;
System.out.println(area);
double b, B, h, area;
b = 6.0;
B = 8.0;
h = 5.0;
area = (b + B) / 2.0 * h;
System.out.println(area);


Boa prática:
Sempre indique o tipo do número, se a
expressão for de ponto flutuante (não
inteira).
Para double use:
.0
Para float use:
f
float b, B, h, area;
b = 6f;
B = 8f;
h = 5f;
area = (b + B) / 2f * h;
System.out.println(area);


Boa prática:
Sempre indique o tipo do número, se a
expressão for de ponto flutuante (não
inteira).
Para double use:
.0
Para float use:
f
int a, b;
double resultado;
a = 5;
b = 2;
resultado = a / b;
System.out.println(resultado);
Casting
É a conversão explícita de um tipo para outro.
É necessário quando o compilador não é capaz de “adivinhar” que o
resultado de uma expressão deve ser de outro tipo.
//Exemplo 4

int a, b;
double resultado;
a = 5;
b = 2;
resultado = a / b;
System.out.println(resultado);


//Exemplo 4
int a, b;
double resultado;
a = 5;
b = 2;
resultado = (double) a / b;
System.out.println(resultado);


//Exemplo 5
double a;
int b;
a = 5.0;
b = a;
System.out.println(b);
 


===================================================================================================================== 
  Entrada de dados em Java
Scanner sc = new Scanner(System.in);
Para ler uma palavra (texto sem espaços)
//Suponha uma variável tipo String declarada:

String x;
x = sc.next();
Para ler um número inteiro
//Suponha uma variável tipo int declarada:

int x;
x = sc.nextInt();
Para ler um número com ponto flutuante
//Suponha uma variável tipo double declarada:

double x;
x = sc.nextDouble();

// ATENÇÃO:
// Para considerar o separador de decimais como ponto, ANTES da declaração do Scanner, faça:
// Locale.setDefault(Locale.US);
Para ler um caractere
//Suponha uma variável tipo char declarada:

char x;
x = sc.next().charAt(0);
Para ler vários dados na mesma linha
string x;
int y;
double z;
x = sc.next();
y = sc.nextInt();
z = sc.nextDouble();
Para ler um texto ATÉ A QUEBRA DE LINHA
import java.util.Scanner;
public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
String s1, s2, s3;
s1 = sc.nextLine();
s2 = sc.nextLine();
s3 = sc.nextLine();
System.out.println("DADOS DIGITADOS:");
System.out.println(s1);
System.out.println(s2);
System.out.println(s3);
sc.close();
}
}
//ATENÇÃO: quebra de linha pendente

int x;
String s1, s2, s3;
x = sc.nextInt();
s1 = sc.nextLine();
s2 = sc.nextLine();
s3 = sc.nextLine();
System.out.println("DADOS DIGITADOS:");
System.out.println(x);
System.out.println(s1);
System.out.println(s2);
System.out.println(s3);


// Quando você usa um comando de
// leitura diferente do nextLine() e
// dá alguma quebra de linha, essa
// quebra de linha fica "pendente"
// na entrada padrão.
// Se você então fizer um nextLine(),
// aquela quebra de linha pendente
// será absorvida pelo nextLine(). 

// Quando você usa um comando de
// leitura diferente do nextLine() e
// dá alguma quebra de linha, essa
// quebra de linha fica "pendente"
// na entrada padrão.
// Se você então fizer um nextLine(),
// aquela quebra de linha pendente
// será absorvida pelo nextLine(). 
 


===================================================================================================================== 
  Funções matemáticas em Java
A = Math.sqrt(x); Variável A recebe a raiz quadrada de x
A = Math.pow(x, y); Variável A recebe o resultado de x elevado a y
A = Math.abs(x); Variável A recebe o valor absoluto de x


public class Main {
public static void main(String[] args) {
double x = 3.0;
double y = 4.0;
double z = -5.0;
double A, B, C;
A = Math.sqrt(x);
B = Math.sqrt(y);
C = Math.sqrt(25.0);
System.out.println("Raiz quadrada de " + x + " = " + A);
System.out.println("Raiz quadrada de " + y + " = " + B);
System.out.println("Raiz quadrada de 25 = " + C);
A = Math.pow(x, y);
B = Math.pow(x, 2.0);
C = Math.pow(5.0, 2.0);
System.out.println(x + " elevado a " + y + " = " + A);
System.out.println(x + " elevado ao quadrado = " + B);
System.out.println("5 elevado ao quadrado = " + C);
A = Math.abs(y);
B = Math.abs(z);
System.out.println("Valor absoluto de " + y + " = " + A);
System.out.println("Valor absoluto de " + z + " = " + B);
}
}


 


===================================================================================================================== 
  Funções matemáticas
 


===================================================================================================================== 
  • sqrt – raiz quadrada
 


===================================================================================================================== 
  • pow – potenciação
 


===================================================================================================================== 
  • abs – valor absoluto
 


===================================================================================================================== 
  • Exemplos
 


===================================================================================================================== 
  Maiores informações: java.lang.Math
 


===================================================================================================================== 
  Exercícios
![WhatsApp Image 2022-11-27 at 2007.36.jpeg](data:image/jpeg;base64,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VHdojry5vD0SP7tO0R15c3h6JH92gsaVHdojry5vD0SP7tO0R15c3h6JH92gsaVHdojry5vD0SP7tO0R15c3h6JH92gsaVHdojry5vD0SP7tO0R15c3h6JH92gsaVHdojry5vD0SP7tO0R15c3h6JH92gsaVHdojry5vD0SP7tO0R15c3h6JH92gsaVHdojry5vD0SP7tO0R15c3h6JH92gsaVHdojry5vD0SP7tO0R15c3h6JH92gsaVHdojry5vD0SP7tO0R15c3h6JH92gsaVHdojry5vD0SP7tO0R15c3h6JH92gsaj7G/2nxD/xIh/2eOr47RHXlzeHokf3a/nDosiu/vCafwj+LTlp1Ny1SekKRUyRY5kiJhApjAAa0VADv/lQU039iv8A7qr/AEDSk39jP/uqv9A0oM2lKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUClKUGFN/Yr/wC6q/0DSk39iv8A7qr/AEDSg//Z)
import java.util.Scanner;

public class uri1003 {

    public static void main(String[] args) {

        // Cria um objeto Scanner para ler a entrada do usuário
        Scanner sc = new Scanner(System.in);

        // Declara as variáveis A, B e soma
        int A, B, soma;

        // Lê o valor de A da entrada do usuário
        A = sc.nextInt();
        // Lê o valor de B da entrada do usuário
        B = sc.nextInt();

        // Realiza a soma entre A e B
        soma = A + B;

        // Exibe o resultado da soma na saída padrão
        System.out.println("SOMA = " + soma);

        // Fecha o Scanner para liberar recursos
        sc.close();
    }
}

 
import java.util.Locale;
import java.util.Scanner;

public class uri1002 {

    public static void main(String[] args) {
        
        // define o padrão de localização como EUA
        Locale.setDefault(Locale.US);
        // Cria um objeto Scanner para ler a entrada do usuário
        Scanner sc = new Scanner(System.in);
        
        // Declara as variáveis R, A e pi
        double R, A, pi = 3.14159;
        
        // Lê o valor de R da entrada do usuário
        R = sc.nextDouble();

        // Calcula a área do círculo
        A = pi * R * R;

        // Exibe o resultado da área do círculo com quatro casas decimais
        System.out.printf("A=%.4f%n", A);

        // Fecha o Scanner para liberar recursos
        sc.close();
    }
}

 
import java.util.Scanner;

public class uri1007 {

    public static void main(String[] args) {

        // Cria um objeto Scanner para ler a entrada do usuário
        Scanner sc = new Scanner(System.in);
        
        // Declara as variáveis A, B, C, D e dif
        int A, B, C, D, dif;

        // Lê o valor de A da entrada do usuário
        A = sc.nextInt();
        // Lê o valor de B da entrada do usuário
        B = sc.nextInt();
        // Lê o valor de C da entrada do usuário
        C = sc.nextInt();
        // Lê o valor de D da entrada do usuário
        D = sc.nextInt();

        // Calcula a diferença entre A * B e C * D
        dif = A * B - C * D;

        // Exibe o resultado da diferença na saída padrão
        System.out.println("DIFERENCA = " + dif);   
        
        // Fecha o Scanner para liberar recursos
        sc.close();
    }
}

 
import java.util.Locale;
import java.util.Scanner;

public class uri1008 {

    public static void main(String[] args) {
        
        // define o padrão de localização como EUA
        Locale.setDefault(Locale.US);
        // Cria um objeto Scanner para ler a entrada do usuário
        Scanner sc = new Scanner(System.in);

        // Declara as variáveis numero, horas, valorHora e salario
        int numero, horas;
        double valorHora, salario;

        // Lê o valor de numero da entrada do usuário
        numero = sc.nextInt();
        // Lê o valor de horas da entrada do usuário
        horas = sc.nextInt();
        // Lê o valor de valorHora da entrada do usuário
        valorHora = sc.nextDouble();

        // Calcula o salario
        salario = valorHora * horas;

        // Exibe o número funcionário na saída padrão
        System.out.println("NUMBER = " + numero);
        // Exibe o salario com duas casas decimais na saída padrão
        System.out.printf("SALARY = U$ %.2f%n", salario);
        
        // Fecha o Scanner para liberar recursos
        sc.close();
    }
}

 
import java.util.Locale;
import java.util.Scanner;

public class uri1010 {

    public static void main(String[] args) {
        
        // define o padrão de localização como EUA
        Locale.setDefault(Locale.US);
        // Cria um objeto Scanner para ler a entrada do usuário
        Scanner sc = new Scanner(System.in);

        // Declara as variáveis cod1, cod2, qte1, qte2, preco1, preco2 e total
        int cod1, cod2, qte1, qte2;
        double preco1, preco2, total;

        // Lê o valor de cod1 da entrada do usuário
        cod1 = sc.nextInt();
        // Lê o valor de qte1 da entrada do usuário
        qte1 = sc.nextInt();
        // Lê o valor de preco1 da entrada do usuário
        preco1 = sc.nextDouble();
        
        // Lê o valor de cod2 da entrada do usuário
        cod2 = sc.nextInt();
        // Lê o valor de qte2 da entrada do usuário
        qte2 = sc.nextInt();
        // Lê o valor de preco2 da entrada do usuário
        preco2 = sc.nextDouble();

        // Calcula o total
        total = preco1 * qte1 + preco2 * qte2;

        // Exibe o valor a pagar com duas casas decimais na saída padrão
        System.out.printf("VALOR A PAGAR: R$ %.2f%n", total);
        
        // Fecha o Scanner para liberar recursos
        sc.close();
    }
}

 
import java.util.Locale;
import java.util.Scanner;

public class uri1012 {

    public static void main(String[] args) {
        
        // define o padrão de localização como EUA
        Locale.setDefault(Locale.US);
        // Cria um objeto Scanner para ler a entrada do usuário
        Scanner sc = new Scanner(System.in);
        
        // Declara as variáveis A, B, C, triangulo, circulo, trapezio, quadrado e retangulo
        double A, B, C, triangulo, circulo, trapezio, quadrado, retangulo;
        
        // Lê o valor de A da entrada do usuário
        A = sc.nextDouble();
        // Lê o valor de B da entrada do usuário
        B = sc.nextDouble();
        // Lê o valor de C da entrada do usuário
        C = sc.nextDouble();
        
        // Calcula a área do triângulo
        triangulo = A * C / 2.0;
        // Calcula a área do círculo
        circulo = 3.14159 * C * C;
        // Calcula a área do trapézio
        trapezio = (A + B) / 2.0 * C;
        // Calcula a área do quadrado
        quadrado = B * B;
        // Calcula a área do retângulo
        retangulo = A * B;
        
        // Exibe a área do triângulo com três casas decimais na saída padrão
        System.out.printf("TRIANGULO: %.3f%n", triangulo);
        // Exibe a área do círculo com três casas decimais na saída padrão
        System.out.printf("CIRCULO: %.3f%n", circulo);
        // Exibe a área do trapézio com três casas decimais na saída padrão
        System.out.printf("TRAPEZIO: %.3f%n", trapezio);
        // Exibe a área do quadrado com três casas decimais na saída padrão
        System.out.printf("QUADRADO: %.3f%n", quadrado);
        // Exibe a área do retângulo com três casas decimais na saída padrão
        System.out.printf("RETANGULO: %.3f%n", retangulo);
        
        // Fecha o Scanner para liberar recursos
        sc.close();
    }
}
 


===================================================================================================================== 
  Operadores comparativos
 
 


===================================================================================================================== 
  Expressões lógicas
 
 


===================================================================================================================== 
  Ideia por trás do operador "E"
 
 


===================================================================================================================== 
  Ideia por trás do operador "OU"
 
 


===================================================================================================================== 
  Ideia por trás do operador "NÃO"
 
 


===================================================================================================================== 
  Estrutura condicional
 
//Simples:

if ( <condição> ) {
<comando 1>
<comando 2>
}
//Composta:

if ( <condição> ) {
<comando 1>
<comando 2>
}
else {
<comando 3>
<comando 4>
}
 
if ( condição 1 ) {
comando 1
comando 2
}
else {
if ( condição 2 ) {
comando 3
comando 4
}
else {
comando 5
comando 6
}
}
if ( condição 1 ) {
comando 1
comando 2
}
else if ( condição 2 ) {
comando 3
comando 4
}
else if ( condição 3 ) {
comando 5
comando 6
}
else {
comando 7
comando 8
}
 


===================================================================================================================== 
  Sintaxe opcional: operadores de atribuição cumulativa
 
import java.util.Locale;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        // Define o padrão de localização como EUA
        Locale.setDefault(Locale.US);
        // Cria um objeto Scanner para ler a entrada do usuário
        Scanner sc = new Scanner(System.in);
        // Declara a variável minutos
        int minutos = sc.nextInt();
        // Declara a variável conta com o valor inicial de 50 reais
        double conta = 50.0;
        // Verifica se o número de minutos é maior que 100
        if (minutos > 100) {
            // Adiciona o valor correspondente aos minutos excedentes à conta
            conta += (minutos - 100) * 2.0;
        }
        // Exibe o valor da conta com duas casas decimais na saída padrão
        System.out.printf("Valor da conta = R$ %.2f%n", conta);
        // Fecha o Scanner para liberar recursos
        sc.close();
    }
}

 


===================================================================================================================== 
  Sintaxe opcional: estrutura switch-case
 
//SEM SWITCH-CASE

// importa a classe Scanner para ser utilizada no programa
import java.util.Scanner; 

// declaração da classe Main
public class Main { 
    // método principal, ponto de entrada do programa
    public static void main(String[] args) { 
        // cria um novo objeto Scanner chamado 'sc' para ler a entrada do usuário
        Scanner sc = new Scanner(System.in); 
        // lê a entrada do usuário e armazena na variável 'x'
        int x = sc.nextInt(); 
        // declaração da variável 'dia' para armazenar o dia da semana correspondente
        String dia; 
        // verificação do valor lido e atribuição do dia da semana correspondente
        if (x == 1) {
            dia = "domingo";
        }
        else if (x == 2) {
            dia = "segunda";
        }
        else if (x == 3) {
            dia = "terca";
        }
        else if (x == 4) {
            dia = "quarta";
        }
        else if (x == 5) {
            dia = "quinta";
        }
        else if (x == 6) {
            dia = "sexta";
        }
        else if (x == 7) {
            dia = "sabado";
        }
        else {
            dia = "valor invalido";
        }
        // imprime o dia da semana
        System.out.println("Dia da semana: " + dia); 
        // fecha o scanner
        sc.close(); 
    }
}


//COM SWITCH-CASE

// importa a classe Scanner para ser utilizada no programa
import java.util.Scanner; 

// declaração da classe Main
public class Main { 
    // método principal, ponto de entrada do programa
    public static void main(String[] args) { 
        // cria um novo objeto Scanner chamado 'sc' para ler a entrada do usuário
        Scanner sc = new Scanner(System.in); 
        // lê a entrada do usuário e armazena na variável 'x'
        int x = sc.nextInt(); 
        // declaração da variável 'dia' para armazenar o dia da semana correspondente
        String dia; 
        // switch case para verificação do valor lido e atribuição do dia da semana correspondente
        switch (x) {
            case 1:
                dia = "domingo";
                break;
            case 2:
                dia = "segunda";
                break;
            case 3:
                dia = "terca";
                break;
            case 4:
                dia = "quarta";
                break;
            case 5:
                dia = "quinta";
                break;
            case 6:
                dia = "sexta";
                break;
            case 7:
                dia = "sabado";
                break;
            default:
                dia = "valor invalido";
                break;
        }
        // imprime o dia da semana
        System.out.println("Dia da semana: " + dia); 
        // fecha o scanner
        sc.close(); 
    }
}

 
 


===================================================================================================================== 
  Expressão condicional ternária
 
//Demo

//NORMAL
double preco = 34.5;
double desconto;
if (preco < 20.0) {
desconto = preco * 0.1;
}
else {
desconto = preco * 0.05;
}


//TERNÁRIA
double preco = 34.5;
double desconto = (preco < 20.0) ? preco * 0.1 : preco * 0.05;
 


===================================================================================================================== 
  Exercícios
 
import java.util.Scanner; // importa a classe Scanner para ser utilizada no programa

public class cond01 {
	public static void main(String[] args) {
		// cria um novo objeto Scanner chamado 'sc' para ler a entrada do usuário
		Scanner sc = new Scanner(System.in);
		
		// lê a entrada do usuário e armazena na variável 'N'
		int N = sc.nextInt();
	    
		// verifica se o valor lido é negativo e imprime a mensagem correspondente
		if (N < 0) {
			System.out.println("NEGATIVO");
		}
		else {
			System.out.println("NAO NEGATIVO");
		}

		// fecha o scanner
		sc.close();
	}
}

 
import java.util.Scanner; // importa a classe Scanner para ser utilizada no programa

public class cond02 {
	public static void main(String[] args) {
		// cria um novo objeto Scanner chamado 'sc' para ler a entrada do usuário
		Scanner sc = new Scanner(System.in);
		
		// lê a entrada do usuário e armazena na variável 'N'
		int N = sc.nextInt();
	    
		// verifica se o valor lido é par ou impar e imprime a mensagem correspondente
		if (N % 2 == 0) {
			System.out.println("PAR");
		}
		else {
			System.out.println("IMPAR");
		}

		// fecha o scanner
		sc.close();
	}
}

 
import java.util.Scanner;

public class uri1044 {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);

		int A = sc.nextInt();
		int B = sc.nextInt();
		
		if (A % B == 0 || B % A == 0) {
			System.out.println("Sao Multiplos");
		}
		else {
			System.out.println("Nao sao Multiplos");
		}
		
		sc.close();
	}
}
 
import java.util.Scanner;

public class uri1046 {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);

		int horaInicial = sc.nextInt();
		int horaFinal = sc.nextInt();
		
		int duracao;
		if (horaInicial < horaFinal) {
			duracao = horaFinal - horaInicial;
		}
		else {
			duracao = 24 - horaInicial + horaFinal;
		}
		
		System.out.println("O JOGO DUROU " + duracao + " HORA(S)");
		
		sc.close();
	}
}
 
import java.util.Scanner;

public class uri1038 {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);

		int codigo = sc.nextInt();
		int quantidade = sc.nextInt();
		
		double total;
		if (codigo == 1) {
			total = quantidade * 4.0;
		}
		else if (codigo == 2) {
			total = quantidade * 4.5;
		}
		else if (codigo == 3) {
			total = quantidade * 5.0;
		}
		else if (codigo == 4) {
			total = quantidade * 2.0;
		}
		else {
			total = quantidade * 1.5;
		}

		System.out.printf("Total: R$ %.2f%n", total);
		
		sc.close();
	}
}
 
import java.util.Locale;
import java.util.Scanner;

public class uri1037 {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);

		double numero = sc.nextDouble();
		
		if (numero < 0.0 || numero > 100.0) {
			System.out.println("Fora de intervalo");
		}
		else if (numero <= 25.0) {
			System.out.println("Intervalo [0,25]");
		}
		else if (numero <= 50.0) {
			System.out.println("Intervalo (25,50]");
		}
		else if (numero <= 75.0) {
			System.out.println("Intervalo (50,75]");
		}		
		else {
			System.out.println("Intervalo (75,100]");
		}
		
		sc.close();
	}
}
 
import java.util.Locale;
import java.util.Scanner;

public class uri1041 {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);

		double x = sc.nextDouble();
		double y = sc.nextDouble();
		
		if (x == 0.0 && y == 0.0) {
			System.out.println("Origem");
		}
		else if (x == 0.0) {
			System.out.println("Eixo Y");
		}
		else if (y == 0.0) {
			System.out.println("Eixo X");
		}
		else if (x > 0.0 && y > 0.0) {
			System.out.println("Q1");
		}
		else if (x < 0.0 && y > 0.0) {
			System.out.println("Q2");
		}
		else if (x < 0.0 && y < 0.0) {
			System.out.println("Q3");
		}
		else {
			System.out.println("Q4");
		}
		
		sc.close();
	}
}
 
import java.util.Locale;
import java.util.Scanner;

public class uri1051 {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);

		double salario = sc.nextDouble();
		
		double imposto;
		if (salario <= 2000.0) {
			imposto = 0.0;
		}
		else if (salario <= 3000.0) {
			imposto = (salario - 2000.0) * 0.08;
		}
		else if (salario <= 4500.0) {
			imposto = (salario - 3000.0) * 0.18 + 1000.0 * 0.08;
		}
		else {
			imposto = (salario - 4500.0) * 0.28 + 1500.0 * 0.18 + 1000.0 * 0.08;
		}

		if (imposto == 0.0) {
			System.out.println("Isento");
		}
		else {
			System.out.printf("R$ %.2f%n", imposto);
		}
		
		sc.close();
	}
}
 


===================================================================================================================== 
  Estrutura repetitiva "enquanto" (while)
 
 


===================================================================================================================== 
  Estrutura repetitiva "para" (for)
 
 
 
 


===================================================================================================================== 
  Estrutura repetitiva do-while "faça-enquanto"
 
 
import java.util.Locale;
import java.util.Scanner;

public class Main {
  public static void main(String[] args) {
    // Define o local para US (EUA) para que as casas decimais sejam separadas por ponto
    Locale.setDefault(Locale.US);
    
    // Inicializa o objeto Scanner para ler os dados do usuário
    Scanner sc = new Scanner(System.in);
    
    // Variável para armazenar a resposta do usuário sobre repetir a operação
    char resp;
    
    // Laço de repetição que será executado enquanto a resposta do usuário for diferente de "n"
    do {
      // Solicita a temperatura em Celsius ao usuário
      System.out.print("Digite a temperatura em Celsius: ");
      double C = sc.nextDouble();
      
      // Converte a temperatura em Celsius para Fahrenheit
      double F = 9.0 * C / 5.0 + 32.0;
      
      // Exibe a temperatura convertida em Fahrenheit
      System.out.printf("Equivalente em Fahrenheit: %.1f%n", F);
      
      // Pergunta ao usuário se ele deseja repetir a operação
      System.out.print("Deseja repetir (s/n)? ");
      resp = sc.next().charAt(0);
    } while (resp != 'n');
    
    // Fecha o Scanner para liberar os recursos do sistema
    sc.close();
  }
}
 


===================================================================================================================== 
  Exercícios
 
import java.util.Scanner;

public class uri1114 {

	public static void main(String[] args) {

		// Criando um objeto Scanner para ler a entrada do usuário
		Scanner sc = new Scanner(System.in);
		
		// Lendo a senha digitada pelo usuário
		int senha = sc.nextInt();
		
		// Loop que verifica se a senha é igual a 2002
		while (senha != 2002) {
			// Caso a senha seja diferente de 2002, exibir mensagem de senha inválida
			System.out.println("Senha Invalida");
			senha = sc.nextInt();
		}
		
		// Caso a senha seja igual a 2002, exibir mensagem de acesso permitido
		System.out.println("Acesso Permitido");
		
		// Fechando o objeto Scanner para liberar os recursos alocados
		sc.close();
	}
}
 
import java.util.Scanner;

public class uri1115 {

	public static void main(String[] args) {
		// Declaração do objeto Scanner
		Scanner sc = new Scanner(System.in);

		// Variáveis para armazenar as coordenadas x e y
		int x = sc.nextInt();
		int y = sc.nextInt();
		
		// Loop para ler as coordenadas e classificá-las
		while (x != 0 && y != 0) {
			// Verifica se as coordenadas x e y são positivas
			if (x > 0 && y > 0) {
				System.out.println("primeiro");
			}
			// Verifica se x é negativo e y é positivo
			else if (x < 0 && y > 0) {
				System.out.println("segundo");
			}
			// Verifica se x e y são negativos
			else if (x < 0 && y < 0) {
				System.out.println("terceiro");
			}
			// Se nenhuma das condições acima for verdadeira, as coordenadas são x positivo e y negativo
			else {
				System.out.println("quarto");
			}
			// Lê novas coordenadas x e y
			x = sc.nextInt();
			y = sc.nextInt();
		}
		
		// Fecha o objeto Scanner
		sc.close();
	}
}
 
import java.util.Scanner;

public class uri1134 {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);
		
		/* Variáveis para armazenar a quantidade de cada tipo de combustível vendido */
		int alcool = 0;
		int gasolina = 0;
		int diesel = 0;
		
		/* Variável para armazenar o tipo de combustível escolhido */
		int tipo = sc.nextInt();
		
		/* Enquanto o tipo de combustível escolhido não for 4, o loop continua */
		while (tipo != 4) {
			
			/* Verifica o tipo de combustível escolhido e aumenta a quantidade correspondente */
			if (tipo == 1) {
				alcool = alcool + 1;
			}
			else if (tipo == 2) {
				gasolina = gasolina + 1;
			}
			else if (tipo == 3) {
				diesel = diesel + 1;
			}
			
			/* Recebe o próximo tipo de combustível escolhido */
			tipo = sc.nextInt();
		}

		/* Imprime o resultado da contagem dos tipos de combustível vendidos */
		System.out.println("MUITO OBRIGADO");
		System.out.println("Alcool: " + alcool);
		System.out.println("Gasolina: " + gasolina);
		System.out.println("Diesel: " + diesel);
		
		/* Fecha o objeto Scanner */
		sc.close();
	}
}

 
import java.util.Scanner;

public class uri1067 {

	public static void main(String[] args) {

// Inicializa o objeto Scanner para ler dados do teclado
	Scanner sc = new Scanner(System.in);

	// Lê o valor de x
	int x = sc.nextInt();
	
	// Loop que percorre de 1 até x
	for (int i=1; i<=x; i++) {
		// Se i for ímpar, imprime na tela
		if (i % 2 != 0) {
			System.out.println(i);
		}
	}
	
	// Fecha o Scanner
	sc.close();
}
}
 
import java.util.Scanner;

public class uri1072 {

	public static void main(String[] args) {

   // Inicializa o objeto Scanner para ler dados do teclado
    Scanner sc = new Scanner(System.in);

    // Lê a quantidade de valores a serem lidos
    int n = sc.nextInt();
    
    // Inicializa as variáveis para contar valores dentro e fora do intervalo
    int in = 0;
    int out = 0;
    
    // Loop que percorre a quantidade de valores a serem lidos
    for (int i = 0; i < n; i++) {
        int x = sc.nextInt();
        // Verifica se o valor está no intervalo [10, 20]
        if (x >= 10 && x <= 20) {
            in++; // Incrementa a contagem de valores dentro do intervalo
        } else {
            out++; // Incrementa a contagem de valores fora do intervalo
        }
    }
    
    // Imprime o resultado
    System.out.println(in + " in");
    System.out.println(out + " out");
    
    // Fecha o Scanner
    sc.close();
}
}
 
import java.util.Locale;
import java.util.Scanner;

public class uri1079 {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);

		int n = sc.nextInt();
		
		for (int i=0; i<n; i++) {
			
			double a = sc.nextDouble();
			double b = sc.nextDouble();
			double c = sc.nextDouble();

			double media = (a * 2.0 + b * 3.0 + c * 5.0) / 10.0;

			System.out.printf("%.1f%n", media);
		}
		
		sc.close();
	}
}
 
import java.util.Scanner;

public class uri1116 {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);

		int n = sc.nextInt();
		
		for (int i=0; i<n; i++) {
			
			int x = sc.nextInt();
			int y = sc.nextInt();
			
			if (y == 0) {
				System.out.println("divisao impossivel");
			}
			else {
				double div = (double) x / y;
				System.out.printf("%.1f%n", div);
			}
		}
		
		sc.close();
	}
}
 
import java.util.Scanner;

public class uri1153 {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);

		int n = sc.nextInt();
		
		int fat = 1;
		for (int i=1; i<=n; i++) {
			fat = fat * i;
		}
		
		System.out.println(fat);
		
		sc.close();
	}
}
 
import java.util.Scanner;

//nao esqueca de mudar o nome da classe para Main
public class uri1157 {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);

		int n = sc.nextInt();
		
		for (int i=1; i<=n; i++) {
			if (n % i == 0) {
				System.out.println(i);
			}
		}
		
		sc.close();
	}
}
 
import java.util.Scanner;

//nao esqueca de mudar o nome da classe para Main
public class uri1143 {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);

		int n = sc.nextInt();
		
		for (int i=1; i<=n; i++) {

			int primeiro = i;
			int segundo = i * i;
			int terceiro = i * i * i;
			System.out.printf("%d %d %d%n", primeiro, segundo, terceiro);
		}
		
		sc.close();
	}
}
 


===================================================================================================================== 
  Funções interessantes para String
 
// Define a string original
String original = "abcde FGHIJ ABC abc DEFG";

// Converte a string original para minúsculas
String s01 = original.toLowerCase();

// Converte a string original para maiúsculas
String s02 = original.toUpperCase();

// Remove os espaços em branco no começo e no fim da string original
String s03 = original.trim();

// Extrai a substring a partir da posição 2 da string original
String s04 = original.substring(2);

// Extrai a substring da posição 2 até a posição 9 da string original
String s05 = original.substring(2, 9);

// Substitui todas as ocorrências de 'a' por 'x' na string original
String s06 = original.replace('a', 'x');

// Substitui todas as ocorrências de "abc" por "xy" na string original
String s07 = original.replace("abc", "xy");

// Encontra a posição da primeira ocorrência de "bc" na string original
int i = original.indexOf("bc");

// Encontra a posição da última ocorrência de "bc" na string original
int j = original.lastIndexOf("bc");

// Imprime a string original
System.out.println("Original: -" + original + "-");

// Imprime a string s01 (convertida para minúsculas)
System.out.println("toLowerCase: -" + s01 + "-");

// Imprime a string s02 (convertida para maiúsculas)
System.out.println("toUpperCase: -" + s02 + "-");

// Imprime a string s03 (com espaços em branco removidos)
System.out.println("trim: -" + s03 + "-");

// Imprime a string s04 (extraída a partir da posição 2)
System.out.println("substring(2): -" + s04 + "-");

// Imprime a string s05 (extraída entre as posições 2 e 9)
System.out.println("substring(2, 9): -" + s05 + "-");

// Imprime a string s06 (com 'a' substituído por 'x')
System.out.println("replace('a', 'x'): -" + s06 + "-");

// Imprime a string s07 (com "abc" substituído por "xy")
System.out.println("replace('abc', 'xy'): -" + s07 + "-");

// Imprime a posição da primeira ocorrência de "bc"
System.out.println("Index of 'bc': " + i);

// Imprime a posição da última ocorrência de "bc"
System.out.println("Last index of 'bc': " + j);
 
// Declaração da variável string s
String s = "potato apple lemon";

// Divide a string s em partes separadas por espaços e armazena em um vetor
String[] vect = s.split(" ");

// Armazena a primeira parte do vetor em uma variável
String word1 = vect[0];

// Armazena a segunda parte do vetor em uma variável
String word2 = vect[1];

// Armazena a terceira parte do vetor em uma variável
String word3 = vect[2];
 


===================================================================================================================== 
  PROGRAMAÇÃO ORIENTADA A OBJETOS
Programa que solicita três lados para dois triângulos, calcula a área e as compara entre si, retornando qual a maior área
 


===================================================================================================================== 
 SOLUÇÃO SEM ORIENTAÇÃO A OBJETOS

package application;

import java.util.Locale; // importa a classe Locale para configurar a localidade padrão
import java.util.Scanner; // importa a classe Scanner para ser utilizada no programa

public class Principal {

	public static void main(String[] args) {
		
		// configura a localidade padrão para US
		Locale.setDefault(Locale.US);
		// cria um novo objeto Scanner chamado 'sc' para ler a entrada do usuário
		Scanner sc = new Scanner(System.in);
		
		// declaração das variáveis para armazenar os lados dos triângulos X e Y
		double xA, xB, xC, yA, yB, yC;
		
		// imprime uma mensagem pedindo a entrada dos lados do triângulo X
		System.out.println("Digite os lados do triangulo X: ");
		xA = sc.nextDouble();
		xB = sc.nextDouble();
		xC = sc.nextDouble();
		
		// imprime uma mensagem pedindo a entrada dos lados do triângulo Y
		System.out.println("Digite os lados do triangulo Y: ");
		yA = sc.nextDouble();
		yB = sc.nextDouble();
		yC = sc.nextDouble();
		
		// calcula o semi-perímetro e a área do triângulo X usando a fórmula de Heron
		double p = (xA + xB +xC)/2.0;
		double areaX = Math.sqrt(p * (p - xA) * (p - xB) * (p - xC));
		
		// calcula o semi-perímetro e a área do triângulo Y usando a fórmula de Heron
		p = (yA + yB +yC)/2.0;
		double areaY = Math.sqrt(p * (p - yA) * (p - yB) * (p - yC));
		
		// imprime as áreas dos triângulos X e Y com 4 casas decimais
		System.out.printf("Área do triangulo X: %.4f%n", areaX);
		System.out.printf("Área do triangulo Y: %.4f%n", areaY);
		
		// verifica qual triângulo tem a área maior e imprime a mensagem correspondente
		if(areaX > areaY) {
			System.out.printf("Area de X é a maior ");
		}
		else {
			System.out.printf("Area de Y é a maior ");
		}
		
		// fecha o scanner
		sc.close();
}}
Programa que solicita três lados para dois triângulos, calcula a área e as compara entre si, retornando qual a maior área
 


===================================================================================================================== 
 SOLUÇÃO COM ORIENTAÇÃO A OBJETOS
 


===================================================================================================================== 
 CLASSE TRIANGULO

package entities;

public class Triangulo {
	
	public double a;
	public double b;
	public double c;
	
}

 


===================================================================================================================== 
 SOLUÇÃO COM ORIENTAÇÃO A OBJETOS
 


===================================================================================================================== 
 CLASSE PRINCIPAL
package application;

import java.util.Locale;
import java.util.Scanner;

import entities.Triangulo;

public class Principal {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		//criando variavel tipo Triangulo
		Triangulo x, y;
		
		//Criando e instanciando novo Triangulo para variaveis x e y
		x = new Triangulo();
		y = new Triangulo();
		
		//input dos valores do lados do Tri
		System.out.println("Digite os lados do triangulo X: ");
		x.a = sc.nextDouble();
		x.b = sc.nextDouble();
		x.c = sc.nextDouble();
		
		System.out.println("Digite os lados do triangulo Y: ");
		y.a = sc.nextDouble();
		y.b = sc.nextDouble();
		y.c = sc.nextDouble();
		
		double p = (x.a + x.b +x.c)/2.0;
		double areaX = Math.sqrt(p * (p - x.a) * (p - x.b) * (p - x.c));
		
		p = (y.a + y.b +y.c)/2.0;
		double areaY = Math.sqrt(p * (p - y.a) * (p - y.b) * (p - y.c));
		
		System.out.printf("Área do triangulo X: %.4f%n", areaX);
		System.out.printf("Área do triangulo X: %.4f%n", areaY);
		
		
		if(areaX > areaY) {
			System.out.printf("Area de X é a maior ");
		}
		else {
			System.out.printf("Area de Y é a maior ");
		}
		
		sc.close();

	}

}
 
 
 


===================================================================================================================== 
  Criando um método para obtermos os benefícios de reaproveitamento e delegação
 
package entities;

public class Triangulo {
	
	public double a;
	public double b;
	public double c;
	
  //metodo para calcular area
	public double area() {
		
		double p = (a + b + c)/2.0;
		return Math.sqrt(p * (p - a) * (p - b) * (p - c));
		
	}

}
 
package application;

import java.util.Locale;
import java.util.Scanner;

import entities.Triangulo;

public class Principal {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		//criando variavel tipo Triangulo
		Triangulo x, y;
		
		//Criando e estanciando novo Triangulo para variaveis x e y
		x = new Triangulo();
		y = new Triangulo();
		
		//input dos valores do lados do Tri
		System.out.println("Digite os lados do triangulo X: ");
		x.a = sc.nextDouble();
		x.b = sc.nextDouble();
		x.c = sc.nextDouble();
				
		System.out.println("Digite os lados do triangulo Y: ");
		y.a = sc.nextDouble();
		y.b = sc.nextDouble();
		y.c = sc.nextDouble();
		
		
		//chamando método para calcular area
		double areaX = x.area();		
		double areaY = y.area();
		
		//imprimindo as áreas
		System.out.printf("Área do triangulo X: %.4f%n", areaX);
		System.out.printf("Área do triangulo X: %.4f%n", areaY);
		
		
		//comparando as areas
		if(areaX > areaY) {
			System.out.printf("Area de X é a maior ");
		}
		else {
			System.out.printf("Area de Y é a maior ");
		}
		
		sc.close();

	}

}
 
Começando a resolver um segundo problema exemplo
 
 
 
package entities;

public class Product {
	
	//criando os atributos
	public String name;
	public double price;
	public int quantity;
	
	//criando oo metodos
	public double totalValueInStock() {
		return price * quantity;
	}
		
	public void addProducts(int quantity) {
		this.quantity += quantity;
	}
	
	public void removeProducts(int quantity) {
		this.quantity -= quantity;
	}

}

package application;

import java.util.Locale;
import java.util.Scanner;

import entities.Product;

public class Program {

	public static void main(String[] args) {
		
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		//criando e instanciando novo Product
		Product product = new Product();
		System.out.println("Entre com os dados do produto: ");
		
		System.out.println("Nome: ");
		
		//input do valor na variável product no campo name da Classe Product
		product.name = sc.nextLine();
		
		System.out.println("Preço: ");
		
		//input do valor na variável product no campo price da Classe Product
		product.price = sc.nextDouble();
		
		System.out.println("Quantidade: ");
		
		//input do valor na variável product no campo quantity da Classe Product
		product.quantity = sc.nextInt();
		
		
		System.out.println(product.name + ", " + product.price + ", " + product.quantity);
			
		
		sc.close();

	}

}
 


===================================================================================================================== 
  Object e toString
 
 
package entities;

public class Product {
	
	//criando os atributos
	public String name;
	public double price;
	public int quantity;
	
	//criando os metodos
	public double totalValueInStock() {
		return price * quantity;
	}
		
	public void addProducts(int quantity) {
		this.quantity += quantity;
	}
	
	public void removeProducts(int quantity) {
		this.quantity -= quantity;
	}
	
	public String toString() {
		
		return name
			+ ", $"
			+ String.format("%.2f", price)
			+ ", "
			+ quantity
			+ " unidades, Total: $"
			+ String.format("%.2f", totalValueInStock());
			
	}

}
package application;

import java.util.Locale;
import java.util.Scanner;

import entities.Product;

public class Program {

	public static void main(String[] args) {
		
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		//criando e instanciando novo Product
		Product product = new Product();
		System.out.print("Entre com os dados do produto: ");
		
		System.out.println();
		System.out.println("Nome: ");
		
		//input do valor na variável product no campo name da Classe Product
		product.name = sc.nextLine();
		
		System.out.println("Preço: ");
		
		//input do valor na variável product no campo price da Classe Product
		product.price = sc.nextDouble();
		
		System.out.println("Quantidade: ");
		
		//input do valor na variável product no campo quantity da Classe Product
		product.quantity = sc.nextInt();
		
		
		System.out.println();
		System.out.println("Dados do produto: " + product.toString());
		
		System.out.println();
		System.out.print("Entre com o número de produtos "
				+ "para serem adicionados ao estoque: ");
		
		System.out.println();
		
		//acrescentando a quantidade no objeto product
		int quantity = sc.nextInt();
		product.addProducts(quantity);
		
		System.out.println();
		System.out.println("Dados atualizados: " + product.toString());
		
		System.out.println();
		System.out.print("Entre com o número de produtos "
				+ "para serem removidos do estoque: ");
		
		//removendo a quantidade no objeto product
				quantity = sc.nextInt();
				product.removeProducts(quantity);
		
				System.out.println();
				System.out.println("Dados atualizados: " + product.toString());
			
		
		sc.close();

	}

}
 


===================================================================================================================== 
  Exercícios
 
package entities;

public class Retangulo {
	// declaração das variáveis para armazenar a largura e a altura do retângulo
	public double larg;
	public double alt;
	
	// método para calcular a área do retângulo
	public double area() {
		return larg * alt;
	}
	
	// método para calcular o perímetro do retângulo
	public double perimetro() {
		return (larg * 2) + (alt *2);
	}
	
	// método para calcular a diagonal do retângulo
	public double diagonal() {
		return Math.sqrt(Math.pow(alt, 2) + Math.pow(larg, 2));
	}
}

// declara o pacote do programa
package program; 

// importa a classe Locale
import java.util.Locale; 
// importa a classe Scanner
import java.util.Scanner; 
// importa a classe Retangulo
import entities.Retangulo; 

public class Principal {

    // método principal
	public static void main(String[] args) {
	    // Define o idioma padrão como inglês
		Locale.setDefault(Locale.US);
	    // Cria um novo objeto Scanner para ler entrada de dados
		Scanner sc = new Scanner(System.in); 
	    // Cria um novo objeto Retangulo
		Retangulo x = new Retangulo(); 
		
		// imprime a mensagem e lê a largura do retângulo
		System.out.println("Entre com a largura: ");
		x.larg = sc.nextDouble();
		
		// imprime a mensagem e lê a altura do retângulo
		System.out.println("Entre com a altura: ");
		x.alt = sc.nextDouble();
		
		// imprime a área do retângulo com duas casas decimais
		System.out.printf("Area: %.2f", x.area());
		System.out.println();
		// imprime o perímetro do retângulo com duas casas decimais
		System.out.printf("Perimetro: %.2f", x.perimetro());
		System.out.println();
		// imprime a diagonal do retângulo com duas casas decimais
		System.out.printf("Diagonal: %.2f", x.diagonal());
			
		// fecha o objeto Scanner
		sc.close();

	}
}

 
package entities;

public class Funcionario {
    // nome do funcionário
	public String nome;
    // salário bruto
	public double salBrut;
    // taxa de desconto
	public double taxa;
	
    // calcula o salário líquido
	public double salarioLiquido() {
		return (1 - (taxa/100)) * salBrut;
	}
	
    // aumenta o salário bruto
	public void increSalario(double percent) {
		salBrut += salBrut * percent / 100.0;
		}
	
    // imprime as informações do funcionário
	public String toString() {
		return nome + ", $ " + String.format("%.2f", salarioLiquido());
		
	}
}


// declara o pacote do programa
package program;

// importa a classe Locale
import java.util.Locale;
// importa a classe Scanner
import java.util.Scanner;
// importa a classe Funcionario
import entities.Funcionario;

public class Principal {

	public static void main(String[] args) {
	    // Define o idioma padrão como inglês
		Locale.setDefault(Locale.US);
	    // Cria um novo objeto Scanner para ler entrada de dados
		Scanner sc = new Scanner(System.in);
		
		// Cria um novo objeto Funcionário
		Funcionario x = new Funcionario();
		
		// imprime a mensagem e lê o nome do funcionário
		System.out.println("Nome: ");
		x.nome = sc.nextLine();
		
		// imprime a mensagem e lê o salário bruto
		System.out.println("Salario Bruto: ");
		x.salBrut = sc.nextDouble();
		
		// imprime a mensagem e lê a taxa de desconto
		System.out.println("Taxa: ");
		x.taxa = sc.nextDouble();
		
		System.out.println();
		// imprime as informações do funcionário
		System.out.println("Funcionário: " + x);
		System.out.println();
		// imprime a mensagem e lê o percentual a acrescentar no salário
		System.out.println("Percentual a acrescentar no salário: ");
		double percent = sc.nextDouble();
		x.increSalario(percent);
	
		System.out.println();
		// imprime as informações atualizadas do funcionário
		System.out.println("Dados atualizados: " + x);
		// fecha o objeto Scanner
		sc.close();
	}
}


 
package entities;

public class Estudante {
    // nota 1 do estudante
    public double nota1;
    // nota 2 do estudante
    public double nota2;
    // nota 3 do estudante
    public double nota3;
    // nome do estudante
	public String nome;
	 
    // calcula a diferença de pontos
	 public double diferPontos() {
			
			double x = (nota1*30 + nota2*35 + nota3*35)/100;
			
			if(x < 60) {
				x = 60 - x;
				return x;
			}else {
				return 0;
			}				
		}
	 	
    // calcula a média tripla e verifica se o estudante foi aprovado ou reprovado
	public double medTri() {
		
		double x = (nota1*30 + nota2*35 + nota3*35)/100;
		
		if(x < 60) {
		    //imprime a média final do estudante e a mensagem de reprovado
			System.out.printf("Média final = %.2f", x);
			System.out.println();
			System.out.println("Reprovado!");
			//imprime a diferença de pontos
			System.out.printf("Faltam %.2f", diferPontos(), " pontos");
			System.out.println();
		}else{
		    //imprime a média final do estudante e a mensagem de aprovado
			System.out.printf("Média final = %.2f", x);
			System.out.println();
			System.out.println("Aprovado!");
		}
		return 0;
	}
	
	public String toString() {
	    //imprime a média final do estudante
		return  String.format("%.2f", medTri());
	}
	
}

// declara o pacote do programa
package program;

// importa a classe Locale
import java.util.Locale;
// importa a classe Scanner
import java.util.Scanner;
// importa a classe Estudante
import entities.Estudante;

public class Principal {

	public static void main(String[] args) {
	    // Define o idioma padrão como inglês
		Locale.setDefault(Locale.US);
	    // Cria um novo objeto Scanner para ler entrada de dados
		Scanner sc = new Scanner(System.in);
		
		// Cria um novo objeto Estudante
		Estudante est = new Estudante();
		
		// imprime a mensagem e lê o nome do estudante
		System.out.println("Digite seu nome: ");
		est.nome = sc.nextLine();
			
		// lê a nota 1 do estudante
		est.nota1 = sc.nextDouble();
			
		// lê a nota 2 do estudante
		est.nota2 = sc.nextDouble();
				
		// lê a nota 3 do estudante
		est.nota3 = sc.nextDouble();
		System.out.println();
		
		// imp//imprime a média final do estudante e seu status de aprovação ou reprovação
		System.out.println(est.toString());

		// fecha o objeto Scanner
		sc.close();
	}
}
 


===================================================================================================================== 
  Exercícios anteriores feitos pelo Professor
 
 
 
 


===================================================================================================================== 
  Membros estáticos
 
 
Versão 1: métodos na própria classe do programa
• Nota: dentro de um método estático você não pode chamar membros de
instância da mesma classe.
package application;

import java.util.Locale; // importa a classe Locale
import java.util.Scanner; // importa a classe Scanner

public class Program {
    // constante de PI
	public static final double PI = 3.14159;

	public static void main(String[] args) {
	    // Define o idioma padrão como inglês
		Locale.setDefault(Locale.US);
	    // Cria um novo objeto Scanner para ler entrada de dados
		Scanner sc = new Scanner(System.in);
		// imprime a mensagem e lê o raio do círculo
		System.out.print("Enter radius: ");
		double radius = sc.nextDouble();
		
		// chama a função volume e imprime o resultado
		System.out.printf("Volume = %.2f", volume(radius));
		sc.close();
	}

	public static double volume(double radius) {
	    // calcula e retorna o volume da esfera
		return 4.0 * PI * radius * radius * radius / 3.0;
	}
}

Versão 2: classe Calculator com membros de instância
package util;

public class Calculator {
    // constante de PI
	public final double PI = 3.14159;

    // calcula e retorna a circunferência
	public double circumference(double radius) {
		return 2.0 * PI * radius;
	}

    // calcula e retorna o volume
	public double volume(double radius) {
		return 4.0 * PI * radius * radius * radius / 3.0;
	}
}

package application;

import java.util.Locale; // importa a classe Locale
import java.util.Scanner; // importa a classe Scanner
import util.Calculator; // importa a classe Calculator

public class Program {
    public static void main(String[] args) {
        // Define o idioma padrão como inglês
        Locale.setDefault(Locale.US);
        // Cria um novo objeto Scanner para ler entrada de dados
        Scanner sc = new Scanner(System.in);
        // Cria um novo objeto Calculator
        Calculator calc = new Calculator();

        // imprime a mensagem e lê o raio do círculo
        System.out.print("Enter radius: ");
        double radius = sc.nextDouble();
        
        // calcula a circunferência
        double c = calc.circumference(radius);
        
        // calcula o volume
        double v = calc.volume(radius);
        
        // imprime a circunferência, o volume e o valor de PI
        System.out.printf("Circumference: %.2f%n", c);
        System.out.printf("Volume: %.2f%n", v);
        System.out.printf("PI value: %.2f%n", calc.PI);

        // fecha o objeto Scanner
        sc.close();
    }
}

classe Calculator com método estático
 
package util;

public class Calculator {
    // constante de PI
    public static final double PI = 3.14159;

    // calcula e retorna a circunferência
    public static double circumference(double radius) {
        return 2.0 * PI * radius;
    }

    // calcula e retorna o volume
    public static double volume(double radius) {
        return 4.0 * PI * radius * radius * radius / 3.0;
    }
}

package application;

import java.util.Locale; // importa a classe Locale
import java.util.Scanner; // importa a classe Scanner

public class Program {
    public static void main(String[] args) {
        Locale.setDefault(Locale.US);
        Scanner sc = new Scanner(System.in);

        // imprime a mensagem e lê o raio do círculo
        System.out.print("Enter radius: ");
        double radius = sc.nextDouble();
        
        // calcula a circunferência
        double c = Calculator.circumference(radius);
        
        // calcula o volume
        double v = Calculator.volume(radius);
        
        // imprime a circunferência, o volume e o valor de PI
        System.out.printf("Circumference: %.2f%n", c);
        System.out.printf("Volume: %.2f%n", v);
        System.out.printf("PI value: %.2f%n", Calculator.PI);

        // fecha o objeto Scanner
        sc.close();
    }
}

 


===================================================================================================================== 
  Exercício de fixação
 
package utilities;

public class CurrencyConverter {
	
	public static final double IOF = 0.06;
	
  //criando membros estaticos com parâmtros que vêm da classe principal:
  
	public static double valReais(double cotacao, double valDolar) {
		 return cotacao * valDolar;		
	}
	
	public static double imposto(double cotacao, double valDolar) {
		return valDolar * IOF * cotacao;
	}

}
package program;

import java.util.Locale;
import java.util.Scanner;

import utilities.CurrencyConverter;

public class Principal {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
				
		System.out.print("Qual o preço do dolar? ");
		double cotacao = sc.nextDouble();
		
		System.out.print("Quantos dólares vai comprar? ");
		double valDolar = sc.nextDouble();
		
    //criando variáveis que receberão o resultado do cálculo dos membros estáticos:

		double reais = CurrencyConverter.valReais(cotacao, valDolar);
		double imp = CurrencyConverter.imposto(cotacao, valDolar);
		
		System.out.printf("Valor a pagar em reais: %.2f", (reais + imp));
				
		sc.close();
	}

}
 


===================================================================================================================== 
  Construtores, palavra this, sobrecarga, encapsulamento
 


===================================================================================================================== 
  Construtores
 
 
package entities;

public class Product {
	public String name;
	public double price;
	public int quantity;
	
	//construtor que obriga o programador a informar os dados do produto na horqa de instanciar
	public Product(String name, double price, int quantity) {
		this.name = name;
		this.price = price;
		this.quantity = quantity;
	}

	public double totalValueInStock() {
		return price * quantity;
	}

	public void addProducts(int quantity) {
		this.quantity += quantity;
	}

	public void removeProducts(int quantity) {
		this.quantity -= quantity;
	}

	public String toString() {
		return name + ", $ " + String.format("%.2f", price) + ", " + quantity + " units, Total: $ "
				+ String.format("%.2f", totalValueInStock());
	}
}
package application;

import java.util.Locale;
import java.util.Scanner;
import entities.Product;

public class Program {
	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		
		System.out.println("Enter product data: ");
		System.out.print("Name: ");
		
		//variavel temporaria receber o valor digitado:		
		String name = sc.nextLine();
		System.out.print("Price: ");
		double price = sc.nextDouble();
		System.out.print("Quantity in stock: ");
		int quantity = sc.nextInt();
		
		//o programador fica obrigado a informar os dados do produto na hora de instanciar
		Product product = new Product(name, price, quantity);
		
		
		System.out.println();
		System.out.println("Product data: " + product);
		System.out.println();
		System.out.print("Enter the number of products to be added in stock: ");
		quantity = sc.nextInt();
		product.addProducts(quantity);
		System.out.println();
		System.out.println("Updated data: " + product);
		System.out.println();
		System.out.print("Enter the number of products to be removed from stock: ");
		quantity = sc.nextInt();
		product.removeProducts(quantity);
		System.out.println();
		System.out.println("Updated data: " + product);
		
		
		sc.close();
	}
}
 


===================================================================================================================== 
  Palavra this
 
 
 


===================================================================================================================== 
  Sobrecarga
 
 
package entities;

public class Product {
	public String name;
	public double price;
	public int quantity;
	
	//construtor que obriga o programador a informar os dados do produto na horqa de instanciar
	public Product(String name, double price, int quantity) {
		this.name = name;
		this.price = price;
		this.quantity = quantity;
	}
	
	//construtor para iniciar com a quantidade product = 0 (sobrecarga)
	public Product(String name, double price) {
		this.name = name;
		this.price = price;

	}
	
	//construtor padrao para ser usado se preciso for
	public Product() {
	}
	
	
	//em resumo, o conceito de sobrecarga é vc poder fazer quantos construtores quiser numa classe
	//na hora de declarar ou chama-los no programa principal, vc pode escolher qual vai usar
	

	public double totalValueInStock() {
		return price * quantity;
	}

	public void addProducts(int quantity) {
		this.quantity += quantity;
	}

	public void removeProducts(int quantity) {
		this.quantity -= quantity;
	}

	public String toString() {
		return name 
				+ ", $ " 
				+ String.format("%.2f", price) 
		        + ", " 
				+ quantity 
				+ " units, Total: $ "
				+ String.format("%.2f", totalValueInStock());
	}
}
package application;

import java.util.Locale;

public class Program {
	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		
		System.out.println("Enter product data: ");
		System.out.print("Name: ");
		
		//variavel temporaria receber o valor digitado:		
		String name = sc.nextLine();
		System.out.print("Price: ");
		double price = sc.nextDouble();
	
		
		//o programador fica obrigado a informar os dados do produto na hora de instanciar
		//o parametro quantity foi removido pois foi feito em sobrecarga um novo construtor recebendo apenas dois parametros
		Product product = new Product(name, price);
		
		//o novo construtor padrao criado em sobrecarga permite instaciar novo objeto Product
		Product p = new Product();
		
		System.out.println();
		System.out.println("Product data: " + product);
		System.out.println();
		System.out.print("Enter the number of products to be added in stock: ");
		int quantity = sc.nextInt();
		product.addProducts(quantity);
		System.out.println();
		System.out.println("Updated data: " + product);
		System.out.println();
		System.out.print("Enter the number of products to be removed from stock: ");
		quantity = sc.nextInt();
		product.removeProducts(quantity);
		System.out.println();
		System.out.println("Updated data: " + product);
		
		
		sc.close();
	}
}
 


===================================================================================================================== 
  Encapsulamento
 
 
Padrão para implementação de getters e setters
	private String name;
	private double price;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public double getPrice() {
		return price;
	}

public void setPrice(double price) {
this.price = price;
}
 


===================================================================================================================== 
  Exercício de fixação

package entities;

public class Product {
	private String name;
	private double price;
	private int quantity;
	//private para encapsular os atributos
	
	//construtor que obriga o programador a informar os dados do produto na horqa de instanciar
	public Product(String name, double price, int quantity) {
		this.name = name;
		this.price = price;
		this.quantity = quantity;
	}
	
	//construtor para iniciar com a quantidade product = 0 (sobrecarga)
	public Product(String name, double price) {
		this.name = name;
		this.price = price;

	}
	
	//construtor padrao para ser usado se preciso for
	public Product() {
	}
	
	//em resumo, o conceito de sobrecarga é vc poder fazer quantos construtores quiser numa classe
	//na hora de declarar ou chama-los no programa principal, vc pode escolher qual vai usar
	
	
	//metodo get para devolver o valor alocado em name e entregar para o programa principal
	public String getName() {
		return name;
	}
	
	//metodo set para acessar e modificar o atributo name, que está encapsulado por declaração private
	//este metodo precisa ser void, pois não retorna valor nenhum. Apenas modifica o atributo.
	public void setName(String name) {
		this.name = name;
	}
	
	//metodo get para acessar o valor alocado em price e entregar ao programa principal
	public double getPrice() {
		return price;
	}
	
	//metodo set para acessar e modificar o atributo price, que está encapsulado por declaração private
	//este metodo precisa ser void, pois não retorna valor nenhum. Apenas modifica o atributo.
	public void setPrice(double price) {
		this.price = price;
	}
	
	//PROTEGENDO O ATRIBUTO QUANTIDADE DO OBJETO PRODUCT:
	//no caso de quantidade, como boa regra de negocio, nao pode ser permitida a modificacao do valor via set
	//assim, cri-se apenas o metodo get, para permitir que o valor do atributo encapsulado seja entregue ao programa principal
	public int getQuantity() {
		return quantity;
	}
	
	

	public double totalValueInStock() {
		return price * quantity;
	}

	public void addProducts(int quantity) {
		this.quantity += quantity;
	}

	public void removeProducts(int quantity) {
		this.quantity -= quantity;
	}

	//metodo toString para devolver os valores do objeto product formados para o programa principal
	public String toString() {
		return name 
				+ ", $ " 
				+ String.format("%.2f", price) 
		        + ", " 
				+ quantity 
				+ " units, Total: $ "
				+ String.format("%.2f", totalValueInStock());
	}
}
package application;

import java.util.Locale;

public class Program {
	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);

		System.out.println("Enter product data: ");
		System.out.print("Name: ");

		// variavel temporaria receber o valor digitado:
		String name = sc.nextLine();
		System.out.print("Price: ");
		double price = sc.nextDouble();

		// o programador fica obrigado a informar os dados do produto na hora de
		// instanciar
		// o parametro quantity foi removido pois foi em sobrecarga um novo construtor
		// recebendo apenas dois parametros
		Product product = new Product(name, price);

		// o novo construtor padrao criado em sobrecarga permite instaciar novo objeto
		// Product
		Product p = new Product();

		// acessando o metodo set para modificar o metodo name na classe Product
		product.setName("Computer");

		// acessando o metodo set para modificar o metodo name na classe Product
		product.setPrice(1200.00);

		// acessando o metodo get para imprimir o name modificado
		System.out.println("Update name: " + product.getName());

		// acessando o metodo get para imprimir o name modificado
		System.out.println("Update price: " + product.getPrice());

		System.out.println();
		System.out.println("Product data: " + product);
		System.out.println();
		System.out.print("Enter the number of products to be added in stock: ");
		int quantity = sc.nextInt();
		product.addProducts(quantity);
		System.out.println();
		System.out.println("Updated data: " + product);
		System.out.println();
		System.out.print("Enter the number of products to be removed from stock: ");
		quantity = sc.nextInt();
		product.removeProducts(quantity);
		System.out.println();
		System.out.println("Updated data: " + product);

		sc.close();
	}}

	
 


===================================================================================================================== 
  Gerando automaticamente construtores, getters e setters com Eclipse
 
package entities;

  public class Product {
	private String name;
	private double price;
	private int quantity;
	
	
	//construtores gerados automaticamente pelo sistema
	public Product(String name, double price, int quantity) {
		this.name = name;
		this.price = price;
		this.quantity = quantity;
	}
	
	public Product(String name, double price) {
		this.name = name;
		this.price = price;
	}
	
	public Product() {	
	}
	
	//geters and seters gerados automticamente pelo sistema	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public double getPrice() {
		return price;
	}

	public void setPrice(double price) {
		this.price = price;
	}

	public double getQuantity() {
		return quantity;
	}
	
	//metodos da classe.
	public double totalValueInStock() {
		return price * quantity;
	}

	public void addProducts(int quantity) {
		this.quantity += quantity;
	}

	public void removeProducts(int quantity) {
		this.quantity -= quantity;
	}

	
	public String toString() {
		return name 
				+ ", $ " 
				+ String.format("%.2f", price) 
		        + ", " 
				+ quantity 
				+ " units, Total: $ "
				+ String.format("%.2f", totalValueInStock());
	}
}
package application;

import java.util.Locale;

public class Program {
	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);

		System.out.println("Enter product data: ");
		System.out.print("Name: ");

		// variavel temporaria receber o valor digitado:
		String name = sc.nextLine();
		System.out.print("Price: ");
		double price = sc.nextDouble();

		// o programador fica obrigado a informar os dados do produto na hora de
		// instanciar
		// o parametro quantity foi removido pois foi em sobrecarga um novo construtor
		// recebendo apenas dois parametros
		Product product = new Product(name, price);

		// o novo construtor padrao criado em sobrecarga permite instaciar novo objeto
		// Product
		Product p = new Product();

		// acessando o metodo set para modificar o metodo name na classe Product
		product.setName("Computer");

		// acessando o metodo set para modificar o metodo name na classe Product
		product.setPrice(1200.00);

		// acessando o metodo get para imprimir o name modificado
		System.out.println("Update name: " + product.getName());

		// acessando o metodo get para imprimir o name modificado
		System.out.println("Update price: " + product.getPrice());

		System.out.println();
		System.out.println("Product data: " + product);
		System.out.println();
		System.out.print("Enter the number of products to be added in stock: ");
		int quantity = sc.nextInt();
		product.addProducts(quantity);
		System.out.println();
		System.out.println("Updated data: " + product);
		System.out.println();
		System.out.print("Enter the number of products to be removed from stock: ");
		quantity = sc.nextInt();
		product.removeProducts(quantity);
		System.out.println();
		System.out.println("Updated data: " + product);

		sc.close();
	}}


 
 


===================================================================================================================== 
  Exercício de fixação
 
package entities;

public class Cliente {
    // Variáveis de instância privadas
    private String name;
    private String cpf;

    // Construtor 
    public Cliente(String name, String cpf) {
        this.name = name;
        this.cpf = cpf;
    }

    // Métodos get e set para o nome 
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }

    // Métodos get e set para o CPF
    public String getCpf() {
        return cpf;
    }
    public void setCpf(String cpf) {
        this.cpf = cpf;
    }
    
    // Sobrescreve o método toString para representar o objeto como uma string
    public String toString() {
        return "nome: " + name + "; " + "CPF: " + cpf + ";";
    }
}


package utilities;

public class ContaCorrente {
    // Variáveis de instância privadas
    private double cc;
    private double valor;

    // Construtor com dois parâmetros
    public ContaCorrente(double cc, double valor) {
        this.cc = cc;
        this.valor = valor;
    }

    // Construtor com um parâmetro
    public ContaCorrente(double cc) {
        this.cc = cc;
    }

    // Métodos get e set para o número da conta corrente
    public double getCc() {
        return cc;
    }
    public void setCc(double cc) {
        this.cc = cc;
    }

    // Métodos get e set para o valor 
    public double getValor() {
        return valor;
    }
    public void setValor(double valor) {
        this.valor = valor;
    }

    // Método para somar valor à conta corrente
    public double somaValor(double valor) {
        return this.valor += valor;
    }

    // Método para subtrair valor à conta corrente
    public double subtraiValor(double valor) {
        return this.valor -= valor + 5.00;
    }

    // Sobrescreve o método toString para representar o objeto como uma string
    public String toString() {
        return " Conta: " + cc + "; " + "Valor atualizado: $" + valor

	}
		
}
package application;

import java.util.Locale;
import java.util.Scanner;

import entities.Cliente;
import utilities.ContaCorrente;

public class Programa {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);

		System.out.print("Entre com o nome do cliente: ");
		String name = sc.nextLine();
		System.out.print("Entre com o CPF do cliente: ");
		String cpf = sc.nextLine();
		System.out.print("Entre com o número da conta: ");
		double cc = sc.nextDouble();
		System.out.print("Fazer um depósito inicial? S(sim)/N(não) ");
		char confirm = sc.next().charAt(0);
		
		Cliente cliente = new Cliente(name, cpf);
		
		double valor = 0;
		ContaCorrente contaCorrente = new ContaCorrente(cc, valor);

		

		if (confirm == 's' || confirm == 'S') {

			System.out.print("Digite o valor: ");
			
		  valor = sc.nextDouble();
		  cliente.setName(name);
			cliente.setCpf(cpf);
			contaCorrente.setCc(cc);
			contaCorrente.setValor(valor);

			System.out.println("Dados da conta: \n" + cliente.toString() + contaCorrente.toString());
			System.out.println();

			System.out.print("Entre com um valor a ser acrescentado: ");
			valor = sc.nextDouble();
			contaCorrente.somaValor(valor);
			System.out.println("Dados atualizados: \n" + cliente.toString() + contaCorrente.toString());
			System.out.println();

			System.out.print("Entre com um valor a ser retirado: ");
			valor = sc.nextDouble();
			contaCorrente.subtraiValor(valor);
			System.out.println("Dados atualizados \n" + cliente.toString() + contaCorrente.toString());
			System.out.println();

		} else {

			  if (confirm == 'N' || confirm == 'n') {
				  System.out.println("Programa encerrado!");
			}
		}
		
		
		System.out.println();
		System.out.println("Dados atualizados \n" + cliente.toString() + contaCorrente.toString());

		sc.close();

	}

}
 


===================================================================================================================== 
  Correção do professor
 
package application;

import java.util.Locale;
import java.util.Scanner;

import entities.Account;

public class Program {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		Account account;

		System.out.print("Enter account number: ");
		int number = sc.nextInt();
		System.out.print("Enter account holder: ");
		sc.nextLine();
		String holder = sc.nextLine();
		System.out.print("Is there an initial deposit (y/n)? ");
		char response = sc.next().charAt(0);
		if (response == 'y') {
			System.out.print("Enter initial deposit value: ");
			double initialDeposit = sc.nextDouble();
			account = new Account(number, holder, initialDeposit);
		}
		else {
			account = new Account(number, holder);
		}
		
		System.out.println();
		System.out.println("Account data:");
		System.out.println(account);
		
		System.out.println();
		System.out.print("Enter a deposit value: ");
		double depositValue = sc.nextDouble();
		account.deposit(depositValue);
		System.out.println("Updated account data:");
		System.out.println(account);
		
		System.out.println();
		System.out.print("Enter a withdraw value: ");
		double withdrawValue = sc.nextDouble();
		account.withdraw(withdrawValue);
		System.out.println("Updated account data:");
		System.out.println(account);
		
		sc.close();
	}
}
package entities;

public class Account {

	private int number;
	private String holder;
	private double balance;
	
	public Account(int number, String holder) {
		this.number = number;
		this.holder = holder;
	}

	public Account(int number, String holder, double initialDeposit) {
		this.number = number;
		this.holder = holder;
		deposit(initialDeposit);
	}

	public int getNumber() {
		return number;
	}

	public String getHolder() {
		return holder;
	}

	public void setHolder(String holder) {
		this.holder = holder;
	}

	public double getBalance() {
		return balance;
	}

	public void deposit(double amount) {
		balance += amount;
	}
	
	public void withdraw(double amount) {
		balance -= amount + 5.0;
	}
	
	public String toString() {
		return "Account "
				+ number
				+ ", Holder: "
				+ holder
				+ ", Balance: $ "
				+ String.format("%.2f", balance);
	}
}
 


===================================================================================================================== 
  Exercício anterior refeito pelo aluno
package aplicação;

import java.util.Locale;

public class Programa {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);

		Conta conta;

		System.out.print("Entre com o número da conta: ");
		int numero = sc.nextInt();

		System.out.print("Entre com o nome do correntista: ");
		sc.nextLine();
		String nome = sc.nextLine();
		System.out.println();

		System.out.print("Deseja fazer um depósito inicial? S(sim) / N(não)");
		char resposta = sc.next().charAt(0);

		if (resposta == 'S' || resposta == 's') {

			System.out.println("Entre com o valor inicial: ");
			double depositoInicial = sc.nextDouble();

			conta = new Conta(numero, nome, depositoInicial);

		} else {
			conta = new Conta(numero, nome);
		}
		
		System.out.println();
		System.out.println("Dados da Conta: ");
		System.out.println(conta);
		
		
		System.out.println();
		System.out.println("Entre com um valor: ");
		double depositaValor = sc.nextDouble();
		conta.deposito(depositaValor);
		System.out.println(conta);
		
		System.out.println();
		System.out.println("Retire um valor: ");
		double retiraValor = sc.nextDouble();
		conta.retirada(retiraValor);
		System.out.println(conta);
		
		System.out.println();
		System.out.println("Dados atualizados: ");
		System.out.println(conta);

		sc.close();

	}

}
package entidades;

public class Conta {
	private int numero;
	private String nome;
	private double saldo;

	public Conta(int numero, String nome) {
		this.numero = numero;
		this.nome = nome;
	}

	public Conta(int numero, String nome, double depositoInicial) {
		this.numero = numero;
		this.nome = nome;
		deposito(depositoInicial);
	}

	public int getConta() {
		return numero;
	}

	public String getNome() {
		return nome;
	}

	public void setNome(String nome) {
		this.nome = nome;
	}

	public double getSaldo() {
		return saldo;
	}

	// usando amount para quantia
	public void deposito(double amount) {
		saldo += amount;
	}

	// usando amount para quantia
	public void retirada(double amount) {
		saldo -= amount + 5.0;
	}

	public String toString() {
		return numero + ", Nome " + nome + ", Saldo " + String.format("%.2f", saldo);
	}

}

 


===================================================================================================================== 
  Comportamento de memória, arrays, listas
 


===================================================================================================================== 
  Tipos referência vs. tipos valor
 
 
 


===================================================================================================================== 
  Tipos valor - tipos primitivos
 
 
 


===================================================================================================================== 
  Valores padrão - Tipo referência
 
 


===================================================================================================================== 
  Tipos referência vs. tipos valor
 
 


===================================================================================================================== 
  Desalocação de memória -
 


===================================================================================================================== 
  garbage collector e escopo local
 
 
 
 
 
 


===================================================================================================================== 
  Vetores - Parte 1
 


===================================================================================================================== 
  Checklist
• Revisão do conceito de vetor
• Declaração e instanciação
• Manipulação de vetor de elementos tipo valor (tipo primitivo)
• Manipulação de vetor de elementos tipo referência (classe)
• Acesso aos elementos
• Propriedade length
 
 
 
 
 


===================================================================================================================== 
  Problema exemplo 1

package application;

import java.util.Locale;
import java.util.Scanner;

public class Program {
	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		double[] vect = new double[n];
		for (int i = 0; i < n; i++) {
			vect[i] = sc.nextDouble();
		}
		double sum = 0.0;
		for (int i = 0; i < n; i++) {
			sum += vect[i];
		}
		double avg = sum / n;
		System.out.printf("AVERAGE HEIGHT: %.2f%n", avg);
		sc.close();
	}
}
 


===================================================================================================================== 
  Vetores - Parte 2
 


===================================================================================================================== 
  Problema exemplo 2
 
 
 
 


===================================================================================================================== 
  Array usando tipo Classe 
Fazer um programa para ler um número inteiro N e os dados (nome e
preço) de N Produtos. Armazene os N produtos em um vetor. Em
seguida, mostrar o preço médio dos produtos.
package entities;

public class Product {
	private String nome;
	private Double preco;
	
	
	public Product(String nome, Double preco) {
		this.nome = nome;
		this.preco = preco;
	}


	public String getNome() {
		return nome;
	}


	public void setNome(String nome) {
		this.nome = nome;
	}


	public Double getPreco() {
		return preco;
	}


	public void setPreco(Double preco) {
		this.preco = preco;
	}
	
	
	

}
package application;

import java.util.Locale;

public class Program {

	public static void main(String[] args) {
		
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		int n = sc.nextInt();
		Product[] vect = new Product[n];
		
		for(int i = 0; i < n; i++) {
			sc.nextLine();
			String nome = sc.nextLine();
			double preco = sc.nextDouble();			
			vect[i] = new Product(nome, preco);
			
		}
		
		double soma = 0.0;	
		for(int i = 0; i < n; i++) {
			soma += vect[i].getPreco();
		}
		
		double media = soma / n;
		
		System.out.printf("A media dos valores é: %.2f", media);
		
		
		sc.close();
	}

}
//programa anterior substituindo variável n por vec.length

package application;

import java.util.Locale;

public class Program {

	public static void main(String[] args) {
		
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		int n = sc.nextInt();
		Product[] vect = new Product[n];
		
		for(int i = 0; i < vect.length; i++) {
			sc.nextLine();
			String nome = sc.nextLine();
			double preco = sc.nextDouble();			
			vect[i] = new Product(nome, preco);
			
		}
		
		double soma = 0.0;	
		for(int i = 0; i < vect.length; i++) {
			soma += vect[i].getPreco();
		}
		
		double media = soma / vect.length;
		
		System.out.printf("A media dos valores é: %.2f", media);
		
		
		sc.close();
	}

}

 


===================================================================================================================== 
  Exercícios 
Faça um programa que leia um número inteiro positivo N (máximo = 10) e depois N números inteiros
e armazene-os em um vetor. Em seguida, mostrar na tela todos os números negativos lidos.
 
//Resolução do aluno

package application;

import java.util.Locale;
import java.util.Scanner;

public class Program {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		System.out.print("Quantos números você vai digitar? (max.10) ");
		int n = sc.nextInt();
		int[] vect = new int[n];
		
		if(n < 10) {
			System.out.println();
			for(int i = 0; i < n; i++) {
				vect [i] = sc.nextInt();
			}
			
			System.out.println("NUMEROS NEGATIVOS:");
			
			for(int i = 0; i < n; i++) {				
				if(vect[i] < 0) {
					System.out.println(vect[i]);
				}
			}		
				
		}else {
			System.out.println("Programa Encerrado! Digite um número até 10. ");
		}
				
		
		sc.close();
	}

}
//Resolução do professor

import java.util.Locale;
import java.util.Scanner;

public class negativos {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		int n;
		
		System.out.print("Quantos numeros voce vai digitar? ");
	    n = sc.nextInt();

	    int[] vetor = new int[n];

	    for (int i=0; i<n; i++) {
	    	System.out.print("Digite um numero: ");
	        vetor[i] = sc.nextInt();
	    }

	    System.out.println("NUMEROS NEGATIVOS:");

	    for (int i=0; i<n; i++) {
	        if (vetor[i] < 0) {
	        	System.out.printf("%d\n", vetor[i]);
	        }
	    }

		sc.close();
	}
}
 
//Resolução do aluno

package application;

import java.util.Locale;
import java.util.Scanner;

public class Program1 {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		System.out.print("Quantos numeros voce vai digitar? ");
		int n = sc.nextInt();		
		int[] vetor = new int[n];
		
		for(int i = 0; i < vetor.length; i++) {
			System.out.print("Digite um numero: ");
			vetor[i] = sc.nextInt();
		}
		
		
		System.out.println("Valores: ");
		for(int i = 0; i < vetor.length; i++) {
			System.out.printf(" " + vetor[i]);
		}
				
		double soma = 0.0;
		double media = 0.0;
		for(int i = 0; i < vetor.length; i++) {
			soma += vetor[i];
		}
		
		media = soma / vetor.length;
		System.out.println();
		System.out.print("Soma: " + soma);
		System.out.print("; " + "Média: " + media);
		
		sc.close();
	}

}
//Resolução do professor

import java.util.Locale;
import java.util.Scanner;

public class soma_vetor {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		int n;
	    double soma, media;

	    System.out.print("Quantos numeros voce vai digitar? ");
	    n = sc.nextInt();

	    double[] vetor = new double[n];

	    for (int i=0; i<n; i++) {
	    	System.out.print("Digite um numero: ");
	        vetor[i] = sc.nextDouble();
	    }

		soma = 0;
	    for (int i=0; i<n; i++) {
	        soma = soma + vetor[i];
	    }

	    media = soma / n;

		System.out.print("VALORES = ");

	    for (int i=0; i<n; i++) {
	    	System.out.printf("%.1f  ", vetor[i]);
	    }

	    System.out.printf("\nSOMA = %.2f\n", soma);
	    System.out.printf("MEDIA = %.2f\n", media);

		sc.close();
	}
}
 
//Resolução do aluno


package entities;

public class Pessoa {
	private String nome;
	private int idade;
	private double altura;
	
	public Pessoa(String nome, int idade, double altura) {
		this.nome = nome;
		this.idade = idade;
		this.altura = altura;
	}
	public String getNome() {
		return nome;
	}
	public void setNome(String nome) {
		this.nome = nome;
	}
	public int getIdade() {
		return idade;
	}
	public void setIdade(int idade) {
		this.idade = idade;
	}
	public double getAltura() {
		return altura;
	}
	public void setAltura(double altura) {
		this.altura = altura;
	}

}

package application;

import java.util.Locale;

public class Program2 {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		double percent = 0;
		
		
		System.out.println("Quantas pessoas serao digitadas? ");
		int n = sc.nextInt();
		Pessoa[] vetor = new Pessoa[n];
		

		for (int i = 0; i < n; i++) {
			sc.nextLine();
			System.out.println("Dados da " + (i + 1) + "ª " + "pessoa:");
			String nome = sc.nextLine();
			int idade = sc.nextInt();
			double altura = sc.nextDouble();

			vetor[i] = new Pessoa(nome, idade, altura);
			
		}
		
		double media = 0;
		for (int i = 0; i < n; i++) {
			media += vetor[i].getAltura() / vetor.length;
		}
		
		
		System.out.printf("Altura média %.2f", media);
		System.out.println();
		
		for(int i = 0; i < n; i++) {
			if(vetor[i].getIdade() < 16) {
				percent++;
			}
		}
		
		double percentMenores = (percent/n) * 100;
		
		System.out.println("Pessoas com menos de 16 anos: " + percentMenores + "%");
		
		
		for (int i = 0; i < n; i++) {
			if (vetor[i].getIdade() < 16) {			
				System.out.println(vetor[i].getNome());
			}
		}

		sc.close();

	}

}
//Resolução do professor

import java.util.Locale;
import java.util.Scanner;

public class alturas {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		int n, nmenores;
	    double alturatotal, alturamedia, percentualMenores;

	    System.out.print("Quantas pessoas serao digitadas? ");
	    n = sc.nextInt();

	    String[] nomes = new String[n];
	    int[] idades = new int[n];
	    double[] alturas = new double[n];

	    for (int i=0; i<n; i++) {
	    	System.out.printf("Dados da %da pessoa:\n", i + 1);
	    	System.out.print("Nome: ");
	        nomes[i] = sc.next();
	        System.out.print("Idade: ");
	        idades[i] = sc.nextInt();
	        System.out.print("Altura: ");
	        alturas[i] = sc.nextDouble();
	    }

		nmenores = 0;
		alturatotal = 0;
	    for (int i=0; i<n; i++) {
	        if (idades[i] < 16) {
	            nmenores++;
	        }
	        alturatotal = alturatotal + alturas[i];
	    }

	    alturamedia = alturatotal / n;
	    percentualMenores = ((double)nmenores / n) * 100.0;

	    System.out.printf("\nAltura media = %.2f\n", alturamedia);
	    System.out.printf("Pessoas com menos de 16 anos: %.1f%%\n", percentualMenores);

	    for(int i=0; i<n; i++) {
	        if (idades[i] < 16) {
	        	System.out.printf("%s\n", nomes[i]);
	        }
	    }

		sc.close();
	}
}
Faça um programa que leia N números reais e armazene-os em um vetor. Em seguida, mostrar na tela
o maior número do vetor (supor não haver empates). Mostrar também a posição do maior elemento,
considerando a primeira posição como 0 (zero).
 
//Resolução do aluno

package application;

import java.util.Locale;
import java.util.Scanner;

public class Program {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		System.out.print("Quantos numeros voce vai digitar? ");
		int n = sc.nextInt();
		double num;
		
		double[] vetor = new double[n];
		
		for(int i = 0; i < n; i++) {
			System.out.print("Digite o " + (i+1) + "º" + " número: ");
			vetor[i] = sc.nextDouble();
		}
		double maior = 0;
		int posi = 0;
		for(int i = 1; i < n; i++) {
			if(vetor[i - 1] > vetor[i]) {
				maior = vetor[i - 1];
				posi = i;
			}else {
				double menor = vetor[i];
			}
		}
				
		System.out.printf("Maior valor: %.2f%n", maior);
		System.out.print("posição do maior valor: " + posi + "ª" + " posição.");
				
		sc.close();
	}}
//Resolução do professor

import java.util.Locale;
import java.util.Scanner;

public class maior_posicao {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		int n, posmaior;
	    double maior;

	    System.out.print("Quantos numeros voce vai digitar? ");
	    n = sc.nextInt();

	    double[] vetor = new double[n];

	    for (int i=0; i<n; i++) {
	    	System.out.print("Digite um numero: ");
	        vetor[i] = sc.nextDouble();
	    }

	    maior = vetor[0];
	    posmaior = 0;

	    for (int i=1; i<n; i++) {
	        if (vetor[i] > maior) {
	            maior = vetor[i];
	            posmaior = i;
	        }
	    }
		
	    System.out.printf("MAIOR VALOR = %.1f\n", maior);
	    System.out.printf("POSICAO DO MAIOR VALOR = %d\n", posmaior);

		sc.close();
	}
}
 


===================================================================================================================== 
  Boxing, unboxing e wrapper classes
 
 
 
//Usando Wrapper classes para não precisar fazer casting (int) antes da variável x
Integer x = 10;
int y = x * 2;

//Usando Wrapper classes no lugar dos tipos primitivos para os atributos.
//Isso se justifica porque há atributos que precisam receber valor null. 
//Ex.: Na criação de um cadastro, o e-mail do usuário pode ser null.
public class Product {
public String name;
public Double price;
public Integer quantity;

(...)
 


===================================================================================================================== 
  Laço "for each"
 



String[] vect = new String[] {"Maria", "Bob", "Alex"};

  //Laço convencional para percorrer o array
  for (int i=0; i< vect.length; i++) {
    System.out.println(vect[i]);
  }


  //Laço for each com o mesmo objetivo
  for (String obj : vect) {
    System.out.println(obj);
  }
 


===================================================================================================================== 
  Listas - Parte 1
 
 
 


===================================================================================================================== 
  Listas - Parte 2
 
package application;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class Program {

	public static void main(String[] args) {
		
		List<String> list = new ArrayList<>();
		
		//Inserindo elementos na lista
		list.add("Maria");
		list.add("Alex");
		list.add("Marco");
		list.add("Mario");
		list.add("Bob");
		list.add("Anna");
		
		//Adicionando elementos na lista
		list.add(2, "Ivan");
		
		//Acessando o tamanho da lista
		System.out.println(list.size());
		
		System.out.println("--------------------------------");
		
		//Removendo 2 elementos da lista
		list.remove("Anna");
		list.remove(1);
		
		//Acessando o novo tamanho
		System.out.println(list.size());
		
		System.out.println("--------------------------------");
		
		for(String x : list) {
			System.out.println(x);
		}
		
		System.out.println("--------------------------------");
		
		//Removendo elementos por predicado:
		//Neste caso, removendo os elementos que começam com M
		list.removeIf(x -> x.charAt(0) == 'M');
		
		for(String x : list) {
			System.out.println(x);
		}
		
		System.out.println("--------------------------------");
		
		//Encontrando a posição de um elemento
		System.out.println("Indice de Bob: " + list.indexOf("Bob"));
		//Encontrando a posição de um elemento inexistente (retorna -1)
		System.out.println("Indice de Bob: " + list.indexOf("Marco"));
		
		System.out.println("--------------------------------");
		
		//Inserindo elementos na lista
				list.add("Maria");
				list.add("Alex");
				list.add("Marco");
				list.add("Mario");
				list.add("Bob");
				list.add("Anna");
		
		//Filtrando elementos da lista. Neste caso, filtrando elementos que começam com A
		List<String> result = list.stream().filter(x -> x.charAt(0) == 'A').collect(Collectors.toList());

		for(String x : result) {
			System.out.println(x);
		}
		
		System.out.println("--------------------------------");
		
		//Encontrando um elemento com base em um predicado. Neste caso, se ele não encontrar, retornará null
		String nome = list.stream().filter(x -> x.charAt(0) == 'A').findFirst().orElse(null);
		System.out.println(nome);
	}

}
 


===================================================================================================================== 
  Exercício de fixação
 
 
 
//Resolução do aluno

package entities;

public class Employee {
	
	private Integer id;
	private String nome;
	private Double salario;
	
	public Employee() {
	}

	
	public Employee(Integer id, String nome, Double salario) {
		this.id = id;
		this.nome = nome;
		this.salario = salario;
	}

	public Integer getId() {
		return id;
	}


	public void setId(Integer id) {
		this.id = id;
	}


	public String getNome() {
		return nome;
	}


	public void setNome(String nome) {
		this.nome = nome;
	}


	public Double getSalario() {
		return salario;
	}

	public void aumentoSalario (double aumento) {
		this.salario = (1 + (aumento / 100.0)) * this.salario;
		
	}


	@Override
	public String toString() {
			return "id= " 
					+ id 
					+ ", " 
					+ nome 
					+ ", " 
					+ String.format("%.2f $", salario)  + "";
	}

}
package apllication;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Scanner;

import entities.Employee;

public class Program {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		System.out.print("Quantos funcionários você vai registrar? ");
		int n = sc.nextInt();
		
		//Instanciamento da lista - variável lista do tipo List<Employee> recebe novo Arraylist com n elementos
		List<Employee> lista = new ArrayList<>(n);
		
		for(int i = 0; i < n; i++) {
			System.out.println("Funcionário N" + "º " + (i + 1));
			System.out.print("Id: ");
			Integer id = sc.nextInt();
			sc.nextLine();
			System.out.print("Nome: ");
			String nome = sc.nextLine();
			System.out.print("Salário: ");
			Double salario = sc.nextDouble();
			sc.nextLine();
			
			//Adicionar à lista os parâmetros para o construtor Employee
			lista.add(new Employee(id, nome, salario));
		}
		
		System.out.println("Entre com o Id do funcionário que terá o salário reajustado: ");
		int id = sc.nextInt();
		
		//Criando uma variável func do tipo Employee para receber filtro getId e comparar com o id digitado
		//Se retornar null, já cai na primeira parte do if a seguir e encerra o programa.
		Employee func = lista.stream().filter(x -> x.getId() == id).findFirst().orElse(null);
		
		if(func == null) {
			System.out.println("Este Id não existe!");
		}else {
			System.out.println("Entre com o percentual: "); 
			double aumento = sc.nextDouble();
			func.aumentoSalario(aumento);
		}
		
		//Imprimir os objetos da lista Employee
		for(Employee obj : lista) {
			System.out.println(obj);
		}
				
		sc.close();
	}

}

//Resolução do professor

package entities;

public class Employee {

	private Integer id;
	private String name;
	private Double salary;
	
	public Employee() {
	}
	
	public Employee(Integer id, String name, Double salary) {
		this.id = id;
		this.name = name;
		this.salary = salary;
	}

	public Integer getId() {
		return id;
	}

	public void setId(Integer id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Double getSalary() {
		return salary;
	}

	public void setSalary(Double salary) {
		this.salary = salary;
	}
	
	public void increaseSalary(double percentage) {
		salary += salary * percentage / 100.0;
	}
	
	public String toString() {
		return id + ", " + name + ", " + String.format("%.2f", salary);
	}
}
package application;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Scanner;

import entities.Employee;

public class Program {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);

		List<Employee> list = new ArrayList<>();
		
		// PART 1 - READING DATA:
		
		System.out.print("How many employees will be registered? ");
		int n = sc.nextInt();
		
		for (int i=1; i<=n; i++) {
			System.out.println();
			System.out.println("Employee 


===================================================================================================================== 
" + i + ": ");

			System.out.print("Id: ");
			int id = sc.nextInt();
			while (hasId(list, id)) {
				System.out.print("Id already taken. Try again: ");
				id = sc.nextInt();
			}
			
			System.out.print("Name: ");
			sc.nextLine();
			String name = sc.nextLine();
			System.out.print("Salary: ");
			double salary = sc.nextDouble();
			list.add(new Employee(id, name, salary));
		}

		// PART 2 - UPDATING SALARY OF GIVEN EMPLOYEE:
		
		System.out.println();
		System.out.print("Enter the employee id that will have salary increase: ");
		int id = sc.nextInt();
		Employee emp = list.stream().filter(x -> x.getId() == id).findFirst().orElse(null);
		if (emp == null) {
			System.out.println("This id does not exist!");
		}
		else {
			System.out.print("Enter the percentage: ");
			double percentage = sc.nextDouble();
			emp.increaseSalary(percentage);
		}
		
		// PART 3 - LISTING EMPLOYEES:
		
		System.out.println();
		System.out.println("List of employees:");
		for (Employee obj : list) {
			System.out.println(obj);
		}
				
		sc.close(); 
	}
	
	public static boolean hasId(List<Employee> list, int id) {
		Employee emp = list.stream().filter(x -> x.getId() == id).findFirst().orElse(null);
		return emp != null;
	}
}
 


===================================================================================================================== 
  Matrizes
 
 
 
 
package application;

import java.util.Locale;
import java.util.Scanner;

public class Program {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		int n = sc.nextInt();
		
		//Instanciando a matriz na memória
		int[][] mat = new int[n][n];
		
		//Lendo a matriz
		//Primeiro for lê as linhas e o segundo lê as colunas
		//A cada 1 giro do primeiro for, o segundo gira n vezes
		//ATENÇÃO!!! Aqui, eu troquei a variável n por length da matriz
		for(int i = 0; i < mat.length; i++) {
			for(int j = 0; j < mat[i].length; j++) {
				mat[i][j] = sc.nextInt();
				
			}
		}
		
		//Imprimindo a diagonal principal
		//Para encontrar a diagonal principal, é só ler os numeros das linhas e colunas iguais
		System.out.println("Diagonal principal: ");
		for(int i = 0; i < n; i++) {
			System.out.print(mat[i][i] + " ");
		}
		System.out.println();
		
		
		//Lendo a matriz em busca dos números negativos
		int conta = 0;
		for(int i = 0; i < n; i++) {
			for(int j = 0; j < n; j++) {
				if(mat[i][j] < 0) {
					conta++;
				}
			}
		}
		
		System.out.println("Numeros negativos = " + conta);
		
		sc.close();
	}

}
 
 


===================================================================================================================== 
  Exercício de fixação
 
 
//Resolução do aluno

package application;

import java.util.Locale;
import java.util.Scanner;

public class Program {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		System.out.print("Quantas linhas ? ");
		int m = sc.nextInt();
		System.out.print("Quantas colunas ? ");
		int n = sc.nextInt();
		int[][] mat = new int[m][n];
		
		//Construindo a matriz
		for(int i = 0; i < m; i++ ) {
			for(int j = 0; j < n; j++) {
				mat[i][j] = sc.nextInt();
			}		
		}
		
		int x = sc.nextInt();
		
		for(int i = 0; i < m; i++) {
			for(int j = 0; j < n; j++) {
				if(mat[i][j] == x) {
					
					//imprimindo as variáveis i e j que, se x == mat[i][j], representam as posições de linha e coluna do número
					System.out.println("Posição: " + i + ", " + j + ":");
					
					//imprimindo o número à esquerda se (coluna - 1)
					if(j > 0) {
					System.out.println("Esquerda: " + mat[i][j - 1]);					
					}
					
					//imprimindo o número acima se (linha -1)
					if(i > 0) {
						System.out.println("Em cima: " + mat[i - 1][j]);
					}
					
					//imprimindo número à direita se coluna < (coluna < linhas da matriz - 1)
					if (j < mat[i].length - 1) {
						System.out.println("Direita: " + mat[i][j + 1]);
					}
					
					//imprimindo número abaixo se linha menor que tamanho da matriz
					if (i < mat.length - 1) {
						System.out.println("Baixo: " + mat[i + 1][j]);
					}
									
				}
			}
		}

		
		sc.close();
	}

}
Resolução do professor

package application;

import java.util.Scanner;

public class Program {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);
		
		int m = sc.nextInt();
		int n = sc.nextInt();
		int[][] mat = new int[m][n];
		
		for (int i=0; i<mat.length; i++) {
			for (int j=0; j<mat[i].length; j++) {
				mat[i][j] = sc.nextInt();
			}
		}
		
		int x = sc.nextInt();
		
		for (int i=0; i<mat.length; i++) {
			for (int j=0; j<mat[i].length; j++) {
				if (mat[i][j] == x) {
					System.out.println("Position " + i + "," + j + ":");
					if (j > 0) {
						System.out.println("Left: " + mat[i][j-1]);
					}
					if (i > 0) {
						System.out.println("Up: " + mat[i-1][j]);
					}
					if (j < mat[i].length-1) {
						System.out.println("Right: " + mat[i][j+1]);
					}
					if (i < mat.length-1) {
						System.out.println("Down: " + mat[i+1][j]);
					}
				}
			}
		}
		
		sc.close();
	}
}
 


===================================================================================================================== 
  Trabalhando com data-hora
 
 
 
 
 
 
 
package application;

import java.time.Duration;

public class Program {

	public static void main(String[] args) {
		
		//INSTANCIAÇÃO - Iniciando DAta-hora em java
		
		//Usando objeto DateTimeFormatter para formatar data no padrão ISO
		DateTimeFormatter fmt1 = DateTimeFormatter.ofPattern("dd/MM/yyyy");
		DateTimeFormatter fmt2 = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");
		
		
		
		LocalDate d01 = LocalDate.now(); //Data		2022-12-05
		System.out.println("d01 " + d01);
		
		LocalDateTime d02 = LocalDateTime.now(); //Data-hora   2022-12-05T22:58:05.848103888
		System.out.println("d02 " + d02);
		
		Instant d03 = Instant.now();
		System.out.println("d03 " + d03);//Data-hora global     2022-12-06T01:58:05.848202404Z
		
		
		LocalDate d04 = LocalDate.parse("2022-07-20");//Data formatada
		System.out.println("d04 " + d04);
		
		LocalDateTime d05 = LocalDateTime.parse("2022-07-20T01:30:26");//Data-hora formatada    2022-07-20T01:30:26
		System.out.println("d05 " + d05.toString());//Pode ser usado o toString para transformar a data para o padrão ISO 8601
	
		Instant d06 = Instant.parse("2022-07-20T01:30:26Z");//Data-hora formatada  2022-07-20T01:30:26Z
		System.out.println("d06 " + d06.toString());//Com toString, mas pode ser sem.
	
		Instant d07 = Instant.parse("2022-07-20T01:30:26-03:00");//Entende que a hora é a local e calcula GMT-03:00, hora em londres. 3 horas adiantado
		System.out.println("d07 " + d07.toString());
		
		LocalDate d08 = LocalDate.parse("20/07/2022", fmt1);//Formatada no padrão ISO  2022-07-20
		System.out.println("d08 " + d08.toString());
		
		LocalDateTime d09 = LocalDateTime.parse("20/07/2022 01:30", fmt2);//Formatada no parão ISO com hora  2022-07-20T01:30
		System.out.println("d09 " + d09.toString());
	
		LocalDate d10 = LocalDate.of(2022, 7, 20);//Instanciando data com dia, mês e ano isolados usados como argumentos
		System.out.println("d10 " + d10.toString());
	
		LocalDateTime d11 = LocalDateTime.of(2022, 7, 20, 03, 30);
		System.out.println("d11 " + d11.toString());
		
		System.out.println("-----------------------------------------------");
		
		
		//FORMATAÇÃO - convertendo Data-hora para texto
		//Quando se tem o objeto Data-hora e se deseja formatar em texto
		
		
		DateTimeFormatter fmt3 = DateTimeFormatter.ofPattern("dd/MM/yyy");
		DateTimeFormatter fmt4 = DateTimeFormatter.ofPattern("dd/MM/yyy HH:mm");
		
		//Instanciando objeto tipo DateTimeFormatter com withZone para obter o fuso horário da maquina local
		DateTimeFormatter fmt5 = DateTimeFormatter.ofPattern("dd/MM/yyy HH:mm").withZone(ZoneId.systemDefault());
		
		//Instanciando para formatar objeto no padrão ISO
		DateTimeFormatter fmt6 = DateTimeFormatter.ISO_DATE_TIME;
		
		DateTimeFormatter fmt7 = DateTimeFormatter.ISO_INSTANT;
		
		System.out.println("d04 " + d04.format(fmt3));//Formatando objeto Data-hora para string 
		System.out.println("d04 " + fmt3.format(d04));//Pode ser usado invertido - passando o objeto como parâmetro
		System.out.println("d04 " + d04.format(DateTimeFormatter.ofPattern("dd/MM/yyy")));//Passando a instanciação no lugar do objeto
		System.out.println("d05 " + d05.format(fmt4));//Usando para formatar LocalDateTime
		
		//Lembrando que o d06 se refere a Instant.parse, porém o Instant não tem .format
		//Quando for Instant, precisa formatar com com fuso horário. Por isso o withZone
		System.out.println("d06 " + fmt5.format(d06));
		
		//Formatado no padrão ISO
		System.out.println("d05 " + d05.format(fmt6));
		
		//Quando for Instant, precisa formatar com com fuso horário.
		System.out.println("d06 " + fmt7.format(d06));
		
		System.out.println("-----------------------------------------------");
		
		//Convertendo Data-hora Global para local
			
		LocalDate r1 = LocalDate.ofInstant(d06, ZoneId.systemDefault());//Quando é uma data sem hora
		LocalDate r2 = LocalDate.ofInstant(d06, ZoneId.of("Portugal"));//Quando é uma data sem hora
		LocalDateTime r3 = LocalDateTime.ofInstant(d06, ZoneId.systemDefault());//Quando é uma data com hora
		LocalDateTime r4 = LocalDateTime.ofInstant(d06, ZoneId.of("Portugal"));//Quando é uma data com hora
		System.out.println("r1 " + r1);
		System.out.println("r2 " + r2);
		System.out.println("r3 " + r3);
		System.out.println("r4 " + r4);
		
		
		System.out.println("-----------------------------------------------");
		
		//Obtendo dados de Data-hora local
		
		System.out.println("d04 dia " + d04.getDayOfMonth());
		System.out.println("d04 mês " + d04.getMonthValue());
		System.out.println("d04 ano " + d04.getYear());
		
		System.out.println("d05 ano " + d05.getHour());
		System.out.println("d05 ano " + d05.getMinute());
	
		System.out.println("-----------------------------------------------");
		
		//OPERAÇÕES IMPORTANTES COM DATA-HORA
	
		//Com LocalDate
		LocalDate semanaAntes = d04.minusDays(7);//Subtrai dias
		System.out.println("semanaAntes = " + semanaAntes);
		
		LocalDate semanaDepois = d04.plusDays(7);//Soma dias
		System.out.println("semanaDepois = " + semanaDepois);
		
		LocalDate anosDepois = d04.plusYears(7);//soma anos
		System.out.println("anosDepois = " + anosDepois);
		
		System.out.println("-----------------------------------------------");
		
		//OPERAÇÕES IMPORTANTES COM DATA-HORA
		
		//Com LocalDateTime
	
		LocalDateTime horasDiasAntes = d05.minusDays(7);//Subtrai dias
		System.out.println("semanaAntes = " + horasDiasAntes);
		
		LocalDateTime horasDiasDepois = d05.plusDays(7);//Soma dias
		System.out.println("semanaDepois = " + horasDiasDepois);
		
		LocalDateTime horasAnosAntes = d05.plusYears(7);//Soma anos
		System.out.println("anosDepois = " + horasAnosAntes);
	
		//Com Instant
		Instant instantSemanaPassada = d06.minus(7, ChronoUnit.DAYS);
		Instant instantSemanaSeguinte = d06.plus(7, ChronoUnit.DAYS);
		
		System.out.println("instantSemanaPassada = " + instantSemanaPassada);
		System.out.println("instantSemanaSeguinte = " + instantSemanaSeguinte);
	
		System.out.println("-----------------------------------------------");
		
		//Duração de tempo entre datas
		//***IMPORTANTE! Não tem como calcular o tempo entre dois LocalDate. Precisa converter para LocalDateTime com atStartOfDay, pois o LcalDate não tem informação de tempo.
		
		Duration t1 = Duration.between(semanaAntes.atStartOfDay(), d04.atStartOfDay());
		Duration t2 = Duration.between(horasDiasAntes, d05);
		Duration t3 = Duration.between(instantSemanaPassada, d06);
		Duration t4 = Duration.between(d06, instantSemanaPassada);
		
		System.out.println("t1 dias = " + t1.toDays());
		System.out.println("t2 dias = " + t2.toDays());
		System.out.println("t3 dias = " + t3.toDays());
		System.out.println("t4 dias = " + t4.toDays());
	
	
	
	}

}


SAÍDAS:

d01 2022-12-06
d02 2022-12-06T14:32:31.486138201
d03 2022-12-06T17:32:31.486255188Z
d04 2022-07-20
d05 2022-07-20T01:30:26
d06 2022-07-20T01:30:26Z
d07 2022-07-20T04:30:26Z
d08 2022-07-20
d09 2022-07-20T01:30
d10 2022-07-20
d11 2022-07-20T03:30
-----------------------------------------------
d04 20/07/2022
d04 20/07/2022
d04 20/07/2022
d05 20/07/2022 01:30
d06 19/07/2022 22:30
d05 2022-07-20T01:30:26
d06 2022-07-20T01:30:26Z
-----------------------------------------------
r1 2022-07-19
r2 2022-07-20
r3 2022-07-19T22:30:26
r4 2022-07-20T02:30:26
-----------------------------------------------
d04 dia 20
d04 mês 7
d04 ano 2022
d05 ano 1
d05 ano 30
-----------------------------------------------
semanaAntes = 2022-07-13
semanaDepois = 2022-07-27
anosDepois = 2029-07-20
-----------------------------------------------
semanaAntes = 2022-07-13T01:30:26
semanaDepois = 2022-07-27T01:30:26
anosDepois = 2029-07-20T01:30:26
instantSemanaPassada = 2022-07-13T01:30:26Z
instantSemanaSeguinte = 2022-07-27T01:30:26Z
-----------------------------------------------
t1 dias = 7
t2 dias = 7
t3 dias = 7
t4 dias = -7
package app;

import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class Program1 {

	public static void main(String[] args) {

		// https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/time/format/DateTimeFormatter.html
		DateTimeFormatter fmt1 = DateTimeFormatter.ofPattern("dd/MM/yyyy");
		DateTimeFormatter fmt2 =  DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");
		
		LocalDate d01 = LocalDate.now();
		LocalDateTime d02 = LocalDateTime.now();
		Instant d03 = Instant.now();
		
		LocalDate d04 = LocalDate.parse("2022-07-20");
		LocalDateTime d05 = LocalDateTime.parse("2022-07-20T01:30:26");
		Instant d06 = Instant.parse("2022-07-20T01:30:26Z");
		Instant d07 = Instant.parse("2022-07-20T01:30:26-03:00");
		
		// https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/time/format/DateTimeFormatter.html
		LocalDate d08 = LocalDate.parse("20/07/2022", fmt1);
		LocalDateTime d09 = LocalDateTime.parse("20/07/2022 01:30", fmt2);

		LocalDate d10 = LocalDate.of(2022, 07, 20);
		LocalDateTime d11 = LocalDateTime.of(2022, 07, 20, 1, 30);
		
		System.out.println("d01 = " + d01.toString());
		System.out.println("d02 = " + d02.toString());
		System.out.println("d03 = " + d03.toString());
		System.out.println("d04 = " + d04.toString());
		System.out.println("d05 = " + d05.toString());
		System.out.println("d06 = " + d06.toString());
		System.out.println("d07 = " + d07.toString());
		System.out.println("d08 = " + d08.toString());
		System.out.println("d09 = " + d09.toString());
		System.out.println("d10 = " + d10.toString());
		System.out.println("d11 = " + d11.toString());

    	LocalDate d04 = LocalDate.parse("2022-07-20");
		LocalDateTime d05 = LocalDateTime.parse("2022-07-20T01:30:26");
		Instant d06 = Instant.parse("2022-07-20T01:30:26Z");
		
		// https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/time/format/DateTimeFormatter.html
		DateTimeFormatter fmt1 = DateTimeFormatter.ofPattern("dd/MM/yyyy");
		DateTimeFormatter fmt2 = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");
		DateTimeFormatter fmt3 = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm").withZone(ZoneId.systemDefault());
		DateTimeFormatter fmt4 = DateTimeFormatter.ISO_DATE_TIME;
		DateTimeFormatter fmt5 = DateTimeFormatter.ISO_INSTANT;
		
		System.out.println("d04 = " + d04.format(fmt1));
		System.out.println("d04 = " + fmt1.format(d04));
		System.out.println("d04 = " + d04.format(DateTimeFormatter.ofPattern("dd/MM/yyyy")));
		
		System.out.println("d05 = " + d05.format(fmt1));
		System.out.println("d05 = " + d05.format(fmt2));
		System.out.println("d05 = " + d05.format(fmt4));

		System.out.println("d06 = " + fmt3.format(d06));
		System.out.println("d06 = " + fmt5.format(d06));
		System.out.println("d06 = " + d06.toString());

    // for (String s : ZoneId.getAvailableZoneIds())
		// System.out.println(s);

		LocalDate d04 = LocalDate.parse("2022-07-20");
		LocalDateTime d05 = LocalDateTime.parse("2022-07-20T01:30:26");
		Instant d06 = Instant.parse("2022-07-20T01:30:26Z");

		LocalDate r1 = LocalDate.ofInstant(d06, ZoneId.systemDefault());
		LocalDate r2 = LocalDate.ofInstant(d06, ZoneId.of("Portugal"));
		LocalDateTime r3 = LocalDateTime.ofInstant(d06, ZoneId.systemDefault());
		LocalDateTime r4 = LocalDateTime.ofInstant(d06, ZoneId.of("Portugal"));

		System.out.println("r1 = " + r1);
		System.out.println("r2 = " + r2);
		System.out.println("r3 = " + r3);
		System.out.println("r4 = " + r4);

		System.out.println("d04 dia = " + d04.getDayOfMonth());
		System.out.println("d04 mês = " + d04.getMonthValue());
		System.out.println("d04 ano = " + d04.getYear());

		System.out.println("d05 hora = " + d05.getHour());
		System.out.println("d05 minutos = " + d05.getMinute());


		LocalDate d04 = LocalDate.parse("2022-07-20");
		LocalDateTime d05 = LocalDateTime.parse("2022-07-20T01:30:26");
		Instant d06 = Instant.parse("2022-07-20T01:30:26Z");
		
		LocalDate pastWeekDate = d04.minusDays(7);
		LocalDate nextWeekDate = d04.plusDays(7);
		
		LocalDateTime pastWeekLocalDate = d05.minusDays(7);
		LocalDateTime nextWeekLocalDate = d05.plusDays(7);
		
		Instant pastWeekInstant = d06.minus(7, ChronoUnit.DAYS);
		Instant nextWeekInstant = d06.plus(7, ChronoUnit.DAYS);
		
		System.out.println("pastWeekDate = " + pastWeekDate);
		System.out.println("nextWeekDate = " + nextWeekDate);
		
		System.out.println("pastWeekLocalDate = " + pastWeekLocalDate);
		System.out.println("nextWeekLocalDate = " + nextWeekLocalDate);
		
		System.out.println("pastWeekInstant = " + pastWeekInstant);
		System.out.println("nextWeekInstant = " + nextWeekInstant);
		
		Duration t1 = Duration.between(pastWeekDate.atStartOfDay(), d04.atStartOfDay());
		Duration t2 = Duration.between(pastWeekLocalDate, d05);
		Duration t3 = Duration.between(pastWeekInstant, d06);
		Duration t4 = Duration.between(d06, pastWeekInstant);

		System.out.println("t1 dias = " + t1.toDays());
		System.out.println("t2 dias = " + t2.toDays());
		System.out.println("t3 dias = " + t3.toDays());
		System.out.println("t4 dias = " + t4.toDays());
	}
}
 


===================================================================================================================== 
  Date e Calendar - modelo antigo de Data-hora usado peloa Java antes da versão 8
 
 
 
//Feito pelo aluno

package application;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.util.Calendar;
import java.util.Date;
import java.util.TimeZone;

public class Program1 {

	public static void main(String[] args) throws ParseException {

		// DATE E CALENDAR - modelo antigo de Data-hora usado pelo Java antes da versão
		// 8

		SimpleDateFormat sdf1 = new SimpleDateFormat("dd/MM/yyyy");
		SimpleDateFormat sdf2 = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
		SimpleDateFormat sdf3 = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
		sdf3.setTimeZone(TimeZone.getTimeZone("GMT"));// Instanciando no formato UTC

		Date x1 = new Date();// Instanciando data com instante atual
		Date x2 = new Date(System.currentTimeMillis());// Instanciando data com instante atual
		Date x3 = new Date(0L);// Instanciando a data armazenada pelo Java desde 1970
		Date x4 = new Date(1000L * 60L * 60L * 5L);// Instanciando Data 5h da manhã de 1970

		Date y1 = (Date) sdf1.parse("25/06/2018");
		Date y2 = (Date) sdf2.parse("25/06/2018 15:42:07");
		Date y3 = Date.from(Instant.parse("2018-06-25T15:42:07Z"));// Data definida no horário UTC

		// Fomato Data-hora padrão Java

		System.out.println("x1 = " + x1);
		System.out.println("x2 = " + x2);
		System.out.println("x3 = " + x3);
		System.out.println("x4 = " + x4);
		System.out.println("y1 = " + y1);
		System.out.println("y2 = " + y2);
		System.out.println("y3 = " + y3);

		System.out.println("--------------------------------------");

		// Horas no formato do Brasil
		System.out.println("x1 = " + sdf2.format(x1));
		System.out.println("x2 = " + sdf2.format(x2));
		System.out.println("x3 = " + sdf2.format(x3));
		System.out.println("x4 = " + sdf2.format(x4));
		System.out.println("y1 = " + sdf2.format(y1));// Convertendo para o formato dd/MM/yyyy.
		System.out.println("y2 = " + sdf2.format(y2));
		System.out.println("y3 = " + sdf2.format(y3));

		System.out.println("--------------------------------------");

		// Horas no formato padrão UTC
		System.out.println("x1 = " + sdf3.format(x1));
		System.out.println("x2 = " + sdf3.format(x2));
		System.out.println("x3 = " + sdf3.format(x3));
		System.out.println("x4 = " + sdf3.format(x4));
		System.out.println("y1 = " + sdf3.format(y1));// Convertendo para o formato dd/MM/yyyy.
		System.out.println("y2 = " + sdf3.format(y2));
		System.out.println("y3 = " + sdf3.format(y3));

		System.out.println("--------------------------------------");

		// MANIPULANDO DATA-HORA COM CALENDAR:

		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
		Date d = Date.from(Instant.parse("2018-06-25T15:42:07Z"));
		System.out.println(sdf.format(d));
		
		//Adicionando horas na data com o objeto Calendar
		Calendar cal = Calendar.getInstance();
		cal.setTime(d);
		cal.add(Calendar.HOUR_OF_DAY, 4);//Acrescentando 4 horas a minha data do calendário
		d = cal.getTime();//atualizando a variável d com a nova data-hora
		System.out.println(sdf.format(d));
		
		System.out.println("--------------------------------------");
		
		//Obtendo uma unidade de tempo
		int minutes = cal.get(Calendar.MINUTE);
		int month = 1 + cal.get(Calendar.MONTH);//Atenção! É necessário acrescentar 1 ao mês porque o mês para o sistema começa em 0
		
		System.out.println("Minutos = " + minutes);
		System.out.println("Meses = " + month);
	}

}

package cofre;

import java.text.DecimalFormat;
import java.util.Locale;
import java.util.Scanner;

public class Testar {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		Cofrinho cofrinho = new Cofrinho();
		int opcao = 0;
		int opcao2 = 0;
		int pais = 0;
		int cont = 0;
		double cent;
		
		
		
		do {
			System.out.println("============================================");
			System.out.println("");
			System.out.println("Valor total no cofrinho : " + new DecimalFormat("0.00").format(cofrinho.totalConvertido()));
			System.out.println("============================================");
			System.out.println("Adicionar ou remover moedas? ");
			System.out.println("Digite o número[]: ");
			System.out.println("[1] - Adicionar ");
			System.out.println("[2] - Remover ");
			opcao = sc.nextInt();
			
			if (opcao == 1) {
				System.out.println("Tipos disponíveis: ");
				System.out.println("Digite o número[]: ");
				System.out.println("[1] - Real");
				System.out.println("[2] - Dolar");
				System.out.println("[3] - Euro");
				System.out.println("[4] - Guarani");
				pais = sc.nextInt();

				if (pais != 0) {
					System.out.println("Moedas disponíveis: ");
					System.out.println("Digite o número[]: ");
					System.out.println("[1] - 5 cent");
					System.out.println("[2] - 10 cent");
					System.out.println("[3] - 25 cent");
					System.out.println("[4] - 50 cent");
					System.out.println("[5] - 1 $");
					int valor = sc.nextInt();					

					switch (valor) {
					case 1:
						 cent = 0.05;						 
						break;
					case 2:
						 cent = 0.10;						
						break;
					case 3:
						 cent = 0.25;						
						break;
					case 4:
						 cent = 0.50;						 
						break;
					case 5:
						 cent = 1.0;
						break;
					default:
						 cent = 0;
						break;
					}
					
					
					switch (pais) {
					case 1:
						cofrinho.adicionar(new Real(cent));
						break;
					case 2:
						cofrinho.adicionar(new Dolar(cent));
						break;
					case 3:
						cofrinho.adicionar(new Euro(cent));
						break;
					case 4:
						cofrinho.adicionar(new Guarani(cent));
						break;
					}
				}

				System.out.println("Adicionar mais moedas? ");
				System.out.println("[1] - Sim ");
				System.out.println("[2] - Não ");
				opcao2 = sc.nextInt();
				
			}
			if (opcao == 2) {	
				
				
				
				
				
				System.out.println("============================================");
				System.out.println("Tipos disponíveis: ");
				System.out.println("Digite o número[]: ");
				System.out.println("[1] - Real");
				System.out.println("[2] - Dolar");
				System.out.println("[3] - Euro");
				System.out.println("[4] - Guarani");
				System.out.println("============================================");
				System.out.println("Moedas no cofrinho: ");
				System.out.println("Digite o número[]: ");
				for (Moeda moeda : cofrinho.listagemMoedas()) {
					cont++;
					System.out.println("[" + cont +  "]" + moeda.getApresentacao());
				}
				
				pais = sc.nextInt();

				if (pais != 0) {
					
					System.out.println("Moedas disponíveis: ");
					System.out.println("Digite o número[]: ");
					System.out.println("[1] - 5 cent");
					System.out.println("[2] - 10 cent");
					System.out.println("[3] - 25 cent");
					System.out.println("[4] - 50 cent");
					System.out.println("[5] - 1 $");
					System.out.println("============================================");
					System.out.println("Moedas no cofrinho: ");
					System.out.println("Digite o número[]: ");
					for (Moeda moeda : cofrinho.listagemMoedas()) {
						cont++;
						System.out.println("[" + cont +  "]" + moeda.getApresentacao());
					}
					
					
					int valor = sc.nextInt();					

					switch (valor) {
					case 1:
						 cent = 0.05;
						break;
					case 2:
						 cent = 0.10;
						break;
					case 3:
						 cent = 0.25;
						break;
					case 4:
						 cent = 0.50;
						break;
					case 5:
						 cent = 1.0;
						break;
					default:
						 cent = 0;
						break;
					}
					
					
					switch (pais) {
					case 1:
						cofrinho.remover(new Real(valor));
						break;
					case 2:
						cofrinho.remover(new Dolar(valor));
						break;
					case 3:
						cofrinho.remover(new Euro(valor));
						break;
					case 4:
						cofrinho.remover(new Guarani(valor));
						break;
					}

				}
								
				System.out.println("Remover mais moedas? ");
				System.out.println("[1] - Sim ");
				System.out.println("[2] - Não ");
				opcao2 = sc.nextInt(); 
						
			}

		} while (opcao2 == 1);

		sc.close();


		for (Moeda moeda : cofrinho.listagemMoedas()) {
			System.out.println(moeda.getApresentacao());
		}
		
		
		System.out.println("============================================");
		System.out.println("");
		System.out.println("Valor total no cofrinho : " + new DecimalFormat("0.00").format(cofrinho.totalConvertido()));

	}

}
 


===================================================================================================================== 
  Enumerações
 
 
package entities;

import java.util.Date;
import entities.enums.OrderStatus;

public class Pedido {
	private Integer id;
	private Date moment;
	private OrderStatus status;//Atributo status do tipo OrderStatus
	

	public Pedido() {
	}

	public Pedido(Integer id, Date moment, OrderStatus status) {
		this.id = id;
		this.moment = moment;
		this.status = status;
	}

	public Integer getId() {
		return id;
	}

	public void setId(Integer id) {
		this.id = id;
	}

	public Date getMoment() {
		return moment;
	}

	public void setMoment(Date moment) {
		this.moment = moment;
	}

	public OrderStatus getStatus() {
		return status;
	}

	public void setStatus(OrderStatus status) {
		this.status = status;
	}

	@Override
	public String toString() {
		return "Pedido [id=" + id + ", moment=" + moment + ", status=" + status + "]";
	}
	
	
	
		

}
	
package entities.enums;

public enum OrderStatus {
	PAGAMENTO_PENDENTE,
	AGUARDANDO,
	ENVIADO,
	ENTREGUE;
}

//Tipo enumerado para representar os status do ciclo de vida do pedido
package application;


import java.util.Date;
import java.util.Locale;
import java.util.Scanner;

import entities.Pedido;
import entities.enums.OrderStatus;

public class Program {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		//Instanciação de um novo objeto do tipo Pedido
		Pedido pedido = new Pedido(1080, new Date(), OrderStatus.PAGAMENTO_PENDENTE);
													//status do pedido tipo OrderStatus
		
		System.out.println(pedido);
		
		OrderStatus os1 = OrderStatus.ENTREGUE;//Instanciando novo objeto do tipo OrderStatus com status ENTREGUE	
		OrderStatus os2 = OrderStatus.valueOf("ENTREGUE");//Convertendo String para Enum
		
		System.out.println(os1);
		System.out.println(os2);
		
		sc.close();
	}

}
 
    OrderStatus os1 = OrderStatus.ENTREGUE;//Instanciando novo objeto do tipo OrderStatus com status ENTREGUE	
		OrderStatus os2 = OrderStatus.valueOf("ENTREGUE");//Convertendo String para Enum
		
		System.out.println(os1);
		System.out.println(os2);
 

 


===================================================================================================================== 
  Vamos falar um pouco de design
 
 
 
 


===================================================================================================================== 
  Composição
 
 
 
 


===================================================================================================================== 
  Exercício resolvido 1
 
 


===================================================================================================================== 
  Exercício resolvido 2 (demo StringBuilder)

 
 
package application;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Locale;
import java.util.Scanner;

import entities.Comment;
import entities.Post;

public class Program {

	public static void main(String[] args) throws ParseException {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
		
		Comment c1 = new Comment("Tenha uma boa viagem!");
		Comment c2 = new Comment("Ual! Que incrível!");
		Post p1 = new Post(
				sdf.parse("21/06/2018 13:05:44"),
				"Viajando para Nova Zelândia",
				"Estou indo visitar este país maravilhoso", 12);
		
		Comment c3 = new Comment("Boa noite!");
		Comment c4 = new Comment("Que a força esteja com você!");
		Post p2 = new Post(
				sdf.parse("28/07/2018 23:14:19"),
				"Boa noite, garotos!",
				"Te vejo amanhã!", 12);
		
		p2.addComment(c1);
		p2.addComment(c2);
		
		System.out.println(p1);
		System.out.println(p2);
	
		
		sc.close();
	}

}
package entities;

public class Comment {
	private String text;
	
	public Comment() {
	}

	public Comment(String text) {
		this.text = text;
	}

	public String getText() {
		return text;
	}

	public void setText(String text) {
		this.text = text;
	}

}

package entities;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class Post {
	//Para não precisar ficar instanciando toda vez o SimpleDateFormat, é melhor declarar uma constante
	//Private static é para não precisar ter uma cópia do objeto sdf para cada Post da aplicação
	//Terá apenas uma cópia para aplicação inteira
	private static SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
	
	private Date moment;
	private String title;
	private String content;
	private Integer likes;
	
	//Criando associação. Um post pode ter vários comentários.
	private List<Comment> comments = new ArrayList<>();
	
	//Criando os construtores
	public Post() {
	}

	public Post(Date moment, String title, String content, Integer likes) {
		this.moment = moment;
		this.title = title;
		this.content = content;
		this.likes = likes;
	}

	public Date getMoment() {
		return moment;
	}

	public void setMoment(Date moment) {
		this.moment = moment;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public Integer getLikes() {
		return likes;
	}

	public void setLikes(Integer likes) {
		this.likes = likes;
	}

	public List<Comment> getComments() {
		return comments;
	}
	
	public void addComment(Comment comment) {
		comments.add(comment);
	}
	
	public void removeComment(Comment comment) {
		comments.remove(comment);
	}
	
	//Por causa da complexidade dos textos que serão impressos, É melhor usar StringBuilder no toString
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append(title + "\n");
		sb.append(likes);
		sb.append(" likes - ");
		sb.append(sdf.format(moment) + "\n");
		sb.append(content + "\n");
		sb.append("Comments: \n");
		
		for(Comment c : comments) {
			sb.append(c.getText() + "\n");
		}
		
		return sb.toString();
	}


}
 


===================================================================================================================== 
  Exercício de fixação
 
 
 
package aplicacao;

import java.text.ParseException;

public class Programa {

	public static void main(String[] args) throws ParseException {
		
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
		
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Entre com os dados do cliente :");
		System.out.print("Nome: ");
		String nome = sc.nextLine();
		System.out.print("Email: ");
		String email = sc.next();
		System.out.print("Data de nascimento (DD/MM/YYYY): ");
		Date dataNascimento = sdf.parse(sc.next());
		
		//instanciando um cliente com os dados que o usuário vai digitar
		Cliente cliente = new Cliente(nome, email, dataNascimento);
		
		System.out.println("Entre com os dados do pedido: ");
		System.out.println("Status: ");
		StatusDoPedido status = StatusDoPedido.valueOf(sc.next());
		
		//instanciando um objeto Ordem associado ao cliente
		Ordem ordem = new Ordem(new Date(), status, cliente);
		
		System.out.println("Quantos itens o pedido vai ter? ");
		int n = sc.nextInt();
		
		for(int i = 0; i < n; i++) {
			System.out.println("Entre com os dados do " 
		            + (i + 1) 
		            + "º" 
					+ " item: ");
			
			System.out.println("Nome do produto: ");
			sc.nextLine();//para limpar a entrada do último nextInt
			String nomeDoProduto = sc.nextLine();
			
			System.out.println("Preço do produto: ");
			double preco = sc.nextDouble();
			
			System.out.println("Quantidade: ");
			int quantidade = sc.nextInt();
			
			/*INSTANCIANDO OS OBJETOS:
			 * 1 - instanciar o produto;
			 * 2 - instanciar o item de pedido associado ao produto
			 * 3 - inserir esse item de pedido no pedido
			 */
			Produto produto = new Produto(nome, preco);
			
			ItemDoPedido it = new ItemDoPedido(quantidade, preco, produto);
			
			ordem.addItem(it);//adicionando o item
		}
		
		
		System.out.println();
		System.out.println(ordem);
		
		
		
	
		sc.close();
	}

}

package entidades;

import java.text.SimpleDateFormat;

public class Cliente {
	
	private static SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	
	private String nome;
	private String email;
	private Date dataNascimento;

	public Cliente() {
	}

	public Cliente(String nome, String email, Date dataNascimento) {
		this.nome = nome;
		this.email = email;
		this.dataNascimento = dataNascimento;
	}

	public String getNome() {
		return nome;
	}

	public void setNome(String nome) {
		this.nome = nome;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	public Date getDataAniversario() {
		return dataNascimento;
	}

	public void setDataAniversario(Date dataAniversario) {
		this.dataNascimento = dataAniversario;
	}
	
	@Override
	public String toString() {
		return nome + " (" + sdf.format(dataNascimento) + ") - " + email;
 	}
	
	
}
package entidades;

public class ItemDoPedido {
	private Integer quantidade;
	private double preco;
	
	private Produto produto;//composição: ItemDoPedido tem 1 Produto
	
	public ItemDoPedido() {		
	}

	public ItemDoPedido(Integer quantidade, double preco, Produto produto) {
		this.quantidade = quantidade;
		this.preco = preco;
		this.produto = produto;
	}

	public Integer getQuantidade() {
		return quantidade;
	}

	public void setQuantidade(Integer quantidade) {
		this.quantidade = quantidade;
	}

	public double getPreco() {
		return preco;
	}

	public void setPreco(double preco) {
		this.preco = preco;
	}

	public Produto getProduto() {
		return produto;
	}

	public void setProduto(Produto produto) {
		this.produto = produto;
	}
	
	public double subTotal() {
		return preco * quantidade;
	}

	@Override
	public String toString() {
		return getProduto().getNome()
				+ ", $"
				+ String.format("%.2f", preco)
				+ ", Quantidade: "
				+ quantidade
				+ ", Subtotal: $"
				+ String.format("%.2f", subTotal());
	}

}
package entidades;
import java.text.SimpleDateFormat;

public class Ordem {
	
	private static SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
	
	private Date momento;
	private StatusDoPedido status;
	
	private Cliente cliente;//Composição: 1 Pedido tem 1 cliente.
	
	//Composição: 1 Pedido tem vários itens
	private List<ItemDoPedido> itens = new ArrayList<ItemDoPedido>();
	
	public Ordem() {
		
	}

	public Ordem(Date momento, StatusDoPedido status, Cliente cliente) {
		this.momento = momento;
		this.status = status;
		this.cliente = cliente;
	}

	public Date getMomento() {
		return momento;
	}

	public void setMomento(Date momento) {
		this.momento = momento;
	}

	public StatusDoPedido getStatus() {
		return status;
	}

	public void setStatus(StatusDoPedido status) {
		this.status = status;
	}

	public Cliente getCliente() {
		return cliente;
	}

	public void setCliente(Cliente cliente) {
		this.cliente = cliente;
	}

	public void addItem(ItemDoPedido item) {
		itens.add(item);
	}
	
	public void removeItem(ItemDoPedido item) {
		itens.remove(item);
	}
	
	
	public double total() {
		double soma = 0.0;
		for(ItemDoPedido it : itens) {
			soma += it.subTotal();
		}
		return soma;
	}
	
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();//usando StringBuilder para ficar mais eficiente
		sb.append("Order moment: ");
		sb.append(sdf.format(momento) + "\n");
		sb.append("Order status: ");
		sb.append(status + "\n");
		sb.append("Client: ");
		sb.append(cliente + "\n");
		sb.append("Order items:\n");
		for (ItemDoPedido item : itens) {
			sb.append(item + "\n");
		}
		sb.append("Preço total: $");
		sb.append(String.format("%.2f", total()));
		return sb.toString();
	}	
}

package entidades;

public class Produto {
	private String nome;
	private Double preco;
	
	public Produto() {
	}

	public Produto(String nome, Double preco) {
		this.nome = nome;
		this.preco = preco;
	}

	public String getNome() {
		return nome;
	}

	public void setNome(String nome) {
		this.nome = nome;
	}

	public Double getPreco() {
		return preco;
	}

	public void setPreco(Double preco) {
		this.preco = preco;
	}
	
	
	

}
package entidades.enums;

public enum StatusDoPedido {
	
	PAGAMENTO_PENDENTE,
	PROCESSANDO,
	ENVIADO,
	ENTREGUE
}
 


===================================================================================================================== 
  Herança e Polimorfismo
 
 
 
 
 
 
package entites;

public class Conta {
	private Integer nome;
	private String titular;
	protected Double saldo;//protected para dar acesso a este atributo a outras classes do mesmo pacote ou subclasses
	
	public Conta() {		
	}

	public Conta(Integer nome, String titular, Double saldo) {
		this.titular = titular;
		this.saldo = saldo;
	}

	public Integer getNome() {
		return nome;
	}

	public void setNome(Integer nome) {
		this.nome = nome;
	}

	public String getTitular() {
		return titular;
	}

	public void setTitular(String titular) {
		this.titular = titular;
	}

	public void saque(double valor) {
		saldo -= valor;
	}
	
	public void deposito(double valor) {
		saldo += valor;
	}
	
}
 
package entites;

/*
 * Extends para definir que a classe ContaEmpresa terá todos os 
 * atributos e comportamentos da classe Conta
 */
public class ContaEmpresa extends Conta {

	private Double limiteDeSaque;

	public ContaEmpresa() {
		super();
	}

	public ContaEmpresa(Integer nome, String titular, Double saldo, Double limiteDeSaque) {
		super(nome, titular, saldo);// super - para herdar nome, titular e saldo da classe Conta
		this.limiteDeSaque = limiteDeSaque;
	}

	public Double getLimiteDeSaque() {
		return limiteDeSaque;
	}

	public void setLimiteDeSaque(Double limiteDeSaque) {
		this.limiteDeSaque = limiteDeSaque;
	}

	public void emprestimo(double valor) {
		if (valor <= limiteDeSaque) {
			saldo += valor - 10.0;//atributo com protected na classe Conta
		}

	}

}
package application;

import java.util.Locale;
import java.util.Scanner;

import entites.ContaEmpresa;

public class Programa {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		
		/*
		 * 
		 * 
		 * 
		 * 
		 * PROGRAMA INCOMPLETO
		 * 
		 * 
		 * 
		 * 
		 * 
		 */
	
		
		sc.close();
	}

}
 


===================================================================================================================== 
  Upcasting e downcasting
 
 
package entites;

public class Conta {
	private Integer numero;
	private String titular;
	protected Double saldo;//protected para dar acesso a este atributo a outras classes do mesmo pacote ou subclasses
	
	public Conta() {		
	}

	public Conta(Integer numero, String titular, Double saldo) {
		this.titular = titular;
		this.saldo = saldo;
	}

	public Integer getNumero() {
		return numero;
	}

	public void setNumero(Integer numero) {
		this.numero = numero;
	}

	public String getTitular() {
		return titular;
	}

	public void setTitular(String titular) {
		this.titular = titular;
	}

	public void saque(double valor) {
		saldo -= valor;
	}
	
	public void deposito(double valor) {
		saldo += valor;
	}
	
}
package entites;

/*
 * Extends para definir que a classe ContaEmpresa terá todos os 
 * atributos e comportamentos da classe Conta
 */
public class ContaEmpresa extends Conta {

	private Double limiteDeSaque;

	public ContaEmpresa() {
		super();
	}

	public ContaEmpresa(Integer numero, String titular, Double saldo, Double limiteDeSaque) {
		super(numero, titular, saldo);// super - para herdar nome, titular e saldo da classe Conta
		this.limiteDeSaque = limiteDeSaque;
	}

	public Double getLimiteDeSaque() {
		return limiteDeSaque;
	}

	public void setLimiteDeSaque(Double limiteDeSaque) {
		this.limiteDeSaque = limiteDeSaque;
	}

	public void emprestimo(double valor) {
		if (valor <= limiteDeSaque) {
			saldo += valor - 10.0;//atributo com protected na classe Conta
		}
	}
}
package application;

import java.util.Locale;
import java.util.Scanner;

import entites.Conta;
import entites.ContaEmpresa;
import entites.ContaPoupanca;

public class Programa {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		Conta conta = new Conta(1001, "IVAN", 0.0);
		ContaEmpresa contaEmpresa = new ContaEmpresa(1002, "CARLOS", 0.0, 500.0);
				
		//****UPCASTING*****
		
		/*
		 * Objeto conta1 do tipo superclasse Conta pode receber
		 * a subclasse contaEmpresa por causa da relação "é um" - 
		 * -uma contaEmpresa é uma Conta.
		 * Dessa forma, conta1 pode ser acessado e trará os atributos e 
		 * comportamentos da sua superclasse Conta
		 */
		Conta conta1 = contaEmpresa;
		conta1.deposito(100.0);
		
		Conta conta2 = new ContaEmpresa(1003, "Bob", 0.0, 200.0);
		Conta conta3 = new ContaPoupanca(1004, "Ana", 0.0, 0.01);
				
		//****DOWNCASTING*****
		
		/*
		 * Objeto conta4 do tipo ContaEmpresa não pode receber
		 * conta2 do tipo Conta. Se não fizer o casting nos parênteses
		 * antes do objeto, o programa vai interpretar que esta conversão 
		 * não é segura e vai dar erro. Porque pode ser que o objeto conta2
		 * não tenha o mesmo tipo do objeto conta4, por isso 
		 * o casting é necessário.
		 * Esta conversão de Superclasse para Subclasse não é natural
		 */
		ContaEmpresa conta4 = (ContaEmpresa)conta2;
		conta4.emprestimo(100.0);
		
		//ContaEmpresa conta5 = (ContaEmpresa)conta3; - esta operação dá erro na execução mesmo não acusando na compilação
		
		/*
		 * O erro ao converter conta3 do tipo Conta para ContaEmpresa ocorre
		 * porque conta3 não é ContaEmpresa, mas ContaPoupança. Este erro só é percebido
		 * quando o programa executa. Por isso é extremamente perigoso.
		 * Para prevenção do problema, é necessário testar o tipo do objeto 
		 * antes de fazer o casting, conforme abaixo:
		 */
		
		if(conta3 instanceof ContaEmpresa) {
			ContaEmpresa conta5 = (ContaEmpresa)conta3;
			conta5.emprestimo(200.0);
			System.out.println("Empréstimo!");
		}
		if(conta3 instanceof ContaPoupanca) {
			ContaPoupanca conta5 = (ContaPoupanca)conta3;
			conta5.atualizaSaldo();
			System.out.println("Atualizado!");
		}	
		sc.close();
	}
}
package entites;

public class ContaPoupanca extends Conta {
	private double taxaDeJuros;

	public ContaPoupanca() {
		super();
	}

	public ContaPoupanca(Integer numero, String titular, Double saldo, double taxaDeJuros) {
		super(numero, titular, saldo);// super - herdando nome, titular e saldo da classe Conta
		this.taxaDeJuros = taxaDeJuros;
	}

	public double getTaxaDeJuros() {
		return taxaDeJuros;
	}

	public void setTaxaDeJuros(double taxaDeJuros) {
		this.taxaDeJuros = taxaDeJuros;
	}
	
	public void atualizaSaldo() {
		saldo += saldo * taxaDeJuros;
	}

}
 


===================================================================================================================== 
  Sobreposição, palavra super, anotação @Override
 
 
 
package entites;

public class Conta {
	private Integer numero;
	private String titular;
	protected Double saldo;//protected para dar acesso a este atributo a outras classes do mesmo pacote ou subclasses
	
	public Conta() {		
	}

	public Conta(Integer numero, String titular, Double saldo) {
		this.titular = titular;
		this.saldo = saldo;
	}

	public Integer getNumero() {
		return numero;
	}

	public void setNumero(Integer numero) {
		this.numero = numero;
	}

	public String getTitular() {
		return titular;
	}

	public void setTitular(String titular) {
		this.titular = titular;
	}
	
	public double getSaldo() {
		return saldo;
	}

	public void saque(double valor) {
		saldo -= valor + 5.0;
	}
	
	public void deposito(double valor) {
		saldo += valor;
	}
	
}

package entites;

/*
 * Extends para definir que a classe ContaEmpresa terá todos os 
 * atributos e comportamentos da classe Conta
 */
public class ContaEmpresa extends Conta {

	private Double limiteDeSaque;

	public ContaEmpresa() {
		super();
	}

	public ContaEmpresa(Integer numero, String titular, Double saldo, Double limiteDeSaque) {
		super(numero, titular, saldo);// super - para herdar nome, titular e saldo da classe Conta
		this.limiteDeSaque = limiteDeSaque;
	}

	public Double getLimiteDeSaque() {
		return limiteDeSaque;
	}

	public void setLimiteDeSaque(Double limiteDeSaque) {
		this.limiteDeSaque = limiteDeSaque;
	}

	public void emprestimo(double valor) {
		if (valor <= limiteDeSaque) {
			saldo += valor - 10.0;//atributo com protected na classe Conta
		}
	}
}

package application;

import java.util.Locale;
import java.util.Scanner;

import entites.Conta;
import entites.ContaEmpresa;
import entites.ContaPoupanca;

public class Programa {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		//usando a regra de saque da Classe Conta
		Conta conta1 = new Conta(1001, "IVAN", 1000.0);
		conta1.saque(200.0);
		
		//sobrescrevendo a ergra de saque da classe Conta com a regra da classe ContaPoupanca
		Conta conta2 = new ContaPoupanca(1002, "CARLOS", 1000.0, 0.01);
		conta2.saque(200.0);
		
		
		System.out.println(conta1.getSaldo());
		System.out.println(conta2.getSaldo());
		
		sc.close();
	}
}
package entites;

public class ContaPoupanca extends Conta {
	private double taxaDeJuros;

	public ContaPoupanca() {
		super();
	}

	public ContaPoupanca(Integer numero, String titular, Double saldo, double taxaDeJuros) {
		super(numero, titular, saldo);// super - herdando nome, titular e saldo da classe Conta
		this.taxaDeJuros = taxaDeJuros;
	}

	public double getTaxaDeJuros() {
		return taxaDeJuros;
	}

	public void setTaxaDeJuros(double taxaDeJuros) {
		this.taxaDeJuros = taxaDeJuros;
	}
	
	public void atualizaSaldo() {
		saldo += saldo * taxaDeJuros;
	}
	
	
	//Para sobrescrever a regra de saque da classe Conta. Porque aqui não são descontados 5R$
	@Override
	public void saque(double valor) {
		saldo -= valor;
	}

}
 


===================================================================================================================== 
  Palavra super
 
package entites;

/*
 * Extends para definir que a classe ContaEmpresa terá todos os 
 * atributos e comportamentos da classe Conta
 */
public class ContaEmpresa extends Conta {

	private Double limiteDeSaque;

	public ContaEmpresa() {
		super();
	}

	public ContaEmpresa(Integer numero, String titular, Double saldo, Double limiteDeSaque) {
		super(numero, titular, saldo);// super - para herdar nome, titular e saldo da classe Conta
		this.limiteDeSaque = limiteDeSaque;
	}

	public Double getLimiteDeSaque() {
		return limiteDeSaque;
	}

	public void setLimiteDeSaque(Double limiteDeSaque) {
		this.limiteDeSaque = limiteDeSaque;
	}

	public void emprestimo(double valor) {
		if (valor <= limiteDeSaque) {
			saldo += valor - 10.0;//atributo com protected na classe Conta
		}
	}
	
	//Para sobrescrever a regra de saque da classe Conta
	@Override
	public void saque(double valor) {
		super.saque(valor);//usando a lógica de saque da superclasse
		saldo -= 2.0;
	}
}
 
 


===================================================================================================================== 
  Classes e métodos final
 
 
 
 
package entites;

//Método final evita que a Classe ContaPoupanca seja herdada
public final class ContaPoupanca extends Conta {
	private double taxaDeJuros;

	public ContaPoupanca() {
		super();
	}

	public ContaPoupanca(Integer numero, String titular, Double saldo, double taxaDeJuros) {
		super(numero, titular, saldo);// super - herdando nome, titular e saldo da classe Conta
		this.taxaDeJuros = taxaDeJuros;
	}

	public double getTaxaDeJuros() {
		return taxaDeJuros;
	}

	public void setTaxaDeJuros(double taxaDeJuros) {
		this.taxaDeJuros = taxaDeJuros;
	}
	
	public void atualizaSaldo() {
		saldo += saldo * taxaDeJuros;
	}
	
	
	//Método final evita que o método seja sobrescrito
	@Override
	public final void saque(double valor) {
		saldo -= valor;
	}

}
 


===================================================================================================================== 
  Introdução ao polimorfismo
 
 
package application;

import java.util.Locale;

public class Programa {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		//usando a regra de saque da Classe Conta
		Conta conta1 = new Conta(1001, "IVAN", 1000.0);
		conta1.saque(200.0);
		
		//sobrescrevendo a regra de saque da classe Conta com a regra da Classe ContaPoupanca
		Conta conta2 = new ContaPoupanca(1002, "CARLOS", 1000.0, 0.01);
		conta2.saque(200.0);
		
		//sobrescrevendo a regra de saque da classe Conta com a regra da Classe ContaEmpresa
		Conta conta3 = new ContaEmpresa(1003, "MARIA", 1000.0, 500.0);
		conta3.saque(200.0);
		
		//POLIMORFISMO: duas variáveis do mesmo tipo se comportam de forma diferente
		//HERANÇA: ContaPoupanca herda o comportamento de Conta
		//UPCASTING: a atribuição de ContaPoupanca à variável x é feita em tempo de execução
		Conta y = new Conta(1020, "CLARA", 1000.0);
		Conta x = new ContaPoupanca(1030, "HERALDO", 1000.0, 0.01);
		
		x.saque(50.0);
		y.saque(50.0);
		
		System.out.println(conta1.getSaldo());
		System.out.println(conta2.getSaldo());
		System.out.println(conta3.getSaldo());
		System.out.println(x.getSaldo());
		System.out.println(y.getSaldo());
		
		sc.close();
	}
}
 
 
 


===================================================================================================================== 
  Exercício resolvido
 
 
package entities;

public class Funcionario {
	private String nome;
	private Integer horas;
	private Double valorPorHora;

	public Funcionario() {

	}

	public Funcionario(String nome, Integer horas, Double valorPorHora) {
		this.nome = nome;
		this.horas = horas;
		this.valorPorHora = valorPorHora;
	}

	public String getNome() {
		return nome;
	}

	public void setNome(String nome) {
		this.nome = nome;
	}

	public Integer getHoras() {
		return horas;
	}

	public void setHoras(Integer horas) {
		this.horas = horas;
	}

	public Double getValorPorHora() {
		return valorPorHora;
	}

	public void setValorPorHora(Double valorPorHora) {
		this.valorPorHora = valorPorHora;
	}

	public double pagamento() {
		return horas * valorPorHora;
	}

}
package entities;

public class FuncTerceirizado extends Funcionario {

	private Double cobrancaAdicional;

	public FuncTerceirizado() {
		super();
	}

	public FuncTerceirizado(String nome, Integer horas, Double valorPorHora, Double cobrancaAdicional) {
		super(nome, horas, valorPorHora);
		this.cobrancaAdicional = cobrancaAdicional;
	}

	public Double getCobrancaAdicional() {
		return cobrancaAdicional;
	}

	public void setCobrancaAdicional(Double cobrancaAdicional) {
		this.cobrancaAdicional = cobrancaAdicional;
	}

	@Override
	public double pagamento() {
		return super.pagamento() + cobrancaAdicional * 1.1;
	}

}

package application;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Scanner;

import entities.FuncTerceirizado;
import entities.Funcionario;

public class Programa {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);

		List<Funcionario> lista = new ArrayList<>();

		System.out.println("Quantidade de funcionários: ");
		int n = sc.nextInt();

		for (int i = 0; i < n; i++) {
			System.out.println("Dados do funcionário nº " + (i + 1) + ": ");
			System.out.print("Terceirizado? (S/N)");
			char tipoFunc = sc.next().charAt(0);

			System.out.print("Nome: ");
			sc.nextLine();
			String nome = sc.nextLine();
			System.out.print("Horas: ");
			Integer horas = sc.nextInt();
			System.out.print("Valor por hora: ");
			Double valorPorHora = sc.nextDouble();

			if (tipoFunc == 'S') {
				System.out.print("Cobrança adicional: ");
				Double cobrancaAdicional = sc.nextDouble();
				lista.add(new FuncTerceirizado(nome, horas, valorPorHora, cobrancaAdicional));
			} else {
				lista.add(new Funcionario(nome, horas, valorPorHora));
			}
		}

		System.out.println();
		System.out.println("PAGAMENTOS:");

		for (Funcionario func : lista) {
			System.out.println(func.getNome() + " - $ " + func.pagamento());
		}

		sc.close();

	}

}
 


===================================================================================================================== 
  Exercício de fixação
 
package entities;

public class Produto {
	private String nome;
	private Double preco;


	public Produto(String nome, Double preco) {
		this.nome = nome;
		this.preco = preco;
	}

	public String getNome() {
		return nome;
	}

	public void setNome(String nome) {
		this.nome = nome;
	}

	public Double getPreco() {
		return preco;
	}

	public void setPreço(Double preco) {
		this.preco = preco;
	}

	public String etiquetaDePreco() {
		return 
				 nome 
				+ " $ " 
				+ String.format("%.2f", preco);
	}

}
package entities;

import java.text.SimpleDateFormat;

public class ProdutoUsado extends Produto {

	private Date dataDeFabricacao;
	private static final SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");

	public ProdutoUsado(String nome, Double preco, Date dataDeFabricacao) {
		super(nome, preco);
		this.dataDeFabricacao = dataDeFabricacao;
	}

	public Date getDataDeFabricacao() {
		return dataDeFabricacao;
	}

	public void setDataDeFabricacao(Date dataDeFabricacao) {
		this.dataDeFabricacao = dataDeFabricacao;
	}

	@Override
	public String etiquetaDePreco() {
		return 
				 getNome() 
				+ " Usado " 
				+ " $ " 
				+ getPreco() 
				+ " (Data de fabricação: " 
				+ sdf.format(dataDeFabricacao)
				+ ")";
	}

}
package entities;

public class ProdutoImportado extends Produto {
	private Double taxaDeAlfandega;
	
	public ProdutoImportado(String nome, Double preco, Double taxaDeAlfandega) {
		super(nome, preco);
		this.taxaDeAlfandega = taxaDeAlfandega;
	}

	public Double getTaxaDeAlfandega() {
		return taxaDeAlfandega;
	}

	public void setTaxaDeAlfandega(Double taxaDeAlfandega) {
		this.taxaDeAlfandega = taxaDeAlfandega;
	}
	
	public Double precoTotal() {
		return getPreco() + taxaDeAlfandega;
	}
	
	@Override
	public String etiquetaDePreco() {
		return 
				 getNome() + " $ " 
				+ precoTotal() 
				+ " (Taxa de alfândega : $ " 
				+ taxaDeAlfandega
				+ ")";
	}
}
package application;

import java.text.ParseException;

public class Programa {

	public static void main(String[] args) throws ParseException {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);

		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");

		List<Produto> lista = new ArrayList<>();

		System.out.print("Entre com o número de produtos: ");
		int n = sc.nextInt();

		for (int i = 0; i < n; i++) {
			System.out.println("Produto nº " + (i + 1) + ": ");
			System.out.println("Comum, usado ou importado? (c/u/i)");
			char tipo = sc.next().charAt(0);

			System.out.print("Nome: ");
			String nome = sc.next();
			System.out.print("Preço: ");
			Double preco = sc.nextDouble();

			if (tipo == 'c' || tipo == 'C') {
				lista.add(new Produto(nome, preco));

			}

			else if (tipo == 'u' || tipo == 'U') {

				System.out.print("Data de fabricação: ");
				Date dataDeFabricacao = sdf.parse(sc.next());

				lista.add(new ProdutoUsado(nome, preco, dataDeFabricacao));
			} 
			
			else {
					System.out.print("Taxa de alfândega: ");
					Double taxaDeAlfandega = sc.nextDouble();
	
					lista.add(new ProdutoImportado(nome, preco, taxaDeAlfandega));
			}
		}

		System.out.println("ETIQUETA DE PREÇO: ");
		for (Produto pro : lista) {
			System.out.println(pro.etiquetaDePreco());
		}
		sc.close();
	}

}
 


===================================================================================================================== 
  Classes abstratas
 
 
 


===================================================================================================================== 
  Métodos abstratos
 
package entities;

import entities.enums.Cor;

//Como a Classe tem método abstrato implementado, ela também precisa ser abstrata
public abstract class Forma {
	private Cor cor;
	
	public Forma() {
		
	}
	
	public Forma(Cor cor) {
		this.cor = cor;
	}

	public Cor getCor() {
		return cor;
	}

	public void setCor(Cor cor) {
		this.cor = cor;
	}
	
	//Método abstrato área
	public abstract double area();
}
package entities.enums;

public enum Cor {
	PRETO,
	AZUL,
	VERMELHO;

}
package entities;

import entities.enums.Cor;

//Como esta Classe não é abstrata, ela é obrigada a sobrescrever o método abstrato da superclasse
public class Retangulo extends Forma {
	private double largura;
	private double altura;

	public Retangulo() {
		super();
	}

	public Retangulo(Cor cor, double largura, double altura) {
		super(cor);// passando a cor para a superclasse
		this.largura = largura;
		this.altura = altura;
	}

	public double getLargura() {
		return largura;
	}

	public void setLargura(double largura) {
		this.largura = largura;
	}

	public double getAltura() {
		return altura;
	}

	public void setAltura(double altura) {
		this.altura = altura;
	}

	// Métodod para sobrescrever
	@Override
	public double area() {
		return altura * largura;
	}

}
package entities;

import entities.enums.Cor;

public class Circulo extends Forma {
	private Double raio;

	public Circulo() {
		super();
	}

	public Circulo(Cor cor, Double raio) {
		super(cor);
		this.raio = raio;
	}

	public Double getRaio() {
		return raio;
	}

	public void setRaio(Double raio) {
		this.raio = raio;
	}

	@Override
	public double area() {
		return raio * raio * Math.PI;
	}

}
package application;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Scanner;

import entities.Circulo;
import entities.Forma;
import entities.Retangulo;
import entities.enums.Cor;

public class Programa {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);		
		/*
		 * É possível criar coleções e variáveis para classes abstratas
		 * desde que o objeto instanciado seja tipo concreto
		 */
		List<Forma> lista = new ArrayList<>();

		System.out.print("Entre com o número de formatos: ");
		int n = sc.nextInt();

		for (int i = 0; i < n; i++) {
			System.out.println("Forma nº " + (i + 1 + ": "));
			System.out.print("Retângulo ou círculo (r/c)?");
			char fig = sc.next().charAt(0);
			System.out.print("Cor (PRETO/AZUL/VERMELHO): ");
			Cor cor = Cor.valueOf(sc.next());// ATENÇÃO!!! - tipo Cor é enum por isso este tipo de atribuição

			if (fig == 'r' || fig == 'R') {
				System.out.print("Largura: ");
				double largura = sc.nextDouble();
				System.out.print("Altura: ");
				double altura = sc.nextDouble();
				/*
				 * Observe que na lista tipo Forma foi feito upcasting
				 * pela instanciação do tipo Retangulo, que é subclasse daquela
				 */
				lista.add(new Retangulo(cor, largura, altura));
			} else {
				System.out.print("Raio: ");
				double raio = sc.nextDouble();
				/*
				 * Observe que a lista é polimórfica, pois recebe
				 * argumentos tanto de Retângulo quanto de Círculo
				 */
				lista.add(new Circulo(cor, raio));
			}
		}		
		System.out.println();
		System.out.println("AREAS DAS FIGURAS GEOMÉTRICAS: ");
		for(Forma forma : lista) {
			System.out.println(String.format("%.2f", forma.area()));
		}
		sc.close();
	}
}
 


===================================================================================================================== 
  Exercício de fixação
 
 
 
package entities;

public abstract class Contribuinte {
	private String nome;
	private Double rendaAnual;

	public Contribuinte() {
	}

	public Contribuinte(String nome, Double rendaAnual) {
		super();
		this.nome = nome;
		this.rendaAnual = rendaAnual;
	}

	public String getNome() {
		return nome;
	}

	public void setNome(String nome) {
		this.nome = nome;
	}

	public Double getRendaAnual() {
		return rendaAnual;
	}

	public void setRendaAnual(Double rendaAnual) {
		this.rendaAnual = rendaAnual;
	}

	public abstract Double taxa();
}

package entities;

import java.awt.dnd.DropTargetDropEvent;

public class Pfisica extends Contribuinte {
	private Double despesaComSaude;

	public Pfisica() {
		super();
	}

	public Pfisica(String nome, Double rendaAnual, Double despesaComSaude) {
		super(nome, rendaAnual);
		this.despesaComSaude = despesaComSaude;
	}

	public Double getDespesaComSaude() {
		return despesaComSaude;
	}

	public void setDespesaComSaude(Double despesaComSaude) {
		this.despesaComSaude = despesaComSaude;
	}

	@Override
	public Double taxa() {
		if (getRendaAnual() >= 20000.0) {
			return getRendaAnual() * 0.25 - despesaComSaude * 0.5;
		} else {
			return getRendaAnual() * 0.15;
		}

	}

}
package entities;

public class Pjuridica extends Contribuinte {
	private Integer numeroDeFuncionarios;

	public Pjuridica() {
	}

	public Pjuridica(String nome, Double rendaAnual, Integer numeroDeFuncionarios) {
		super(nome, rendaAnual);
		this.numeroDeFuncionarios = numeroDeFuncionarios;
	}

	public Integer getNumeroDeFuncionarios() {
		return numeroDeFuncionarios;
	}

	public void setNumeroDeFuncionarios(Integer numeroDeFuncionarios) {
		this.numeroDeFuncionarios = numeroDeFuncionarios;
	}

	@Override
	public Double taxa() {
		if (numeroDeFuncionarios > 10) {
			return getRendaAnual() * 0.14;
		} else {
			return getRendaAnual() * 0.16;
		}

	}

}
package application;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Scanner;

import entities.Contribuinte;
import entities.Pfisica;
import entities.Pjuridica;

public class Programa {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);

		List<Contribuinte> lista = new ArrayList<>();

		System.out.print("Entre com o número de contribuintes: ");
		int n = sc.nextInt();

		for (int i = 0; i < n; i++) {
			System.out.print("Pessoa Física ou Jurídica (f/j)? ");
			char pessoa = sc.next().charAt(0);

			System.out.print("Nome: ");
			String nome = sc.next();
			System.out.print("Renda anual: ");
			Double rendaAnual = sc.nextDouble();

			if (pessoa == 'f' || pessoa == 'F') {
				System.out.print("Depesas com saúde: ");
				Double despesaComSaude = sc.nextDouble();
				lista.add(new Pfisica(nome, rendaAnual, despesaComSaude));
			} else {
				System.out.print("Número de funcionários: ");
				Integer numeroDeFuncionarios = sc.nextInt();
				lista.add(new Pjuridica(nome, rendaAnual, numeroDeFuncionarios));
			}
		}
		System.out.println();
		System.out.println("IMPOSTO PAGO: ");
		
		Double soma = 0.0;
		for(Contribuinte contri : lista) {
			System.out.println(contri.getNome()+ " $ " + String.format("%.2f", contri.taxa()));
			soma += contri.taxa();
		}
		System.out.println();
		System.out.print("TOTAL DE IMPOSTO: " + String.format("%.2f", soma));

		sc.close();

	}

}
 


===================================================================================================================== 
  Discussão inicial sobre exceções
 
 
 
 


===================================================================================================================== 
  Estrutura try-catch
 
import java.util.Locale;
import java.util.Scanner;

public class Program {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);

		String[] vect = sc.nextLine().split(" ");
		int posicao = sc.nextInt();
		System.out.println(vect[posicao]);

		/*
		 * Observe que este programa pode quebrar por diversos motivos: - Digitar um
		 * número de posição que não existe no vetor - Digitar uma letra em vez de um
		 * número
		 */

		// COMO TRATAR ESTES ERROS?

		sc.close();

	}

}

//VEJA NO CÓDIGO ABAIXO
import java.util.InputMismatchException;
import java.util.Locale;
import java.util.Scanner;

public class Program {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		//SEM TRATAMENTO DE ERRO
		
		/*String[] vect = sc.nextLine().split(" ");
		int posicao = sc.nextInt();
		System.out.println(vect[posicao]);

		/*
		 * Observe que este programa pode quebrar por diversos motivos: - Digitar um
		 * número de posição que não existe no vetor - Digitar uma letra em vez de um
		 * número
		 */

		// COMO TRATAR ESTES ERROS?
		
		try {
			String[] vect = sc.nextLine().split(" ");
			int posicao = sc.nextInt();
			System.out.println(vect[posicao]);
		}
		catch(ArrayIndexOutOfBoundsException e) {
			System.out.println("Posição inválida!");
		}
		catch(InputMismatchException e) {
			System.out.println("Erro na inserção!");
		}
		
		System.out.println("Programa encerrado.");

		sc.close();

	}

}
 


===================================================================================================================== 
  Pilha de chamadas de métodos
import java.util.InputMismatchException;
import java.util.Scanner;

public class Program3 {
	public static void main(String[] args) {
		// Chama o método1
		method1();
		// Imprime "FIM DO PROGRAMA" ao final da execução
		System.out.println("FIM DO PROGRAMA");
	}

	public static void method1() {
		// Imprime "***INÍCIO DO MÉTODO1***" na tela
		System.out.println("***INÍCIO DO MÉTODO1***");
		// Chama o método2
		method2();
		// Imprime "***FIM DO MÉTODO1***" na tela
		System.out.println("***FIM DO MÉTODO1***");
	}

	public static void method2() {
		// Imprime "***INÍCIO DO MÉTODO2***" na tela
		System.out.println("***INÍCIO DO MÉTODO2***");
		// Cria um objeto Scanner para ler da entrada padrão
		Scanner sc = new Scanner(System.in);
		try {
			// Lê a linha digitada pelo usuário e a separa em um vetor de strings
			String[] vect = sc.nextLine().split(" ");
			// Lê a posição inteira informada pelo usuário
			int position = sc.nextInt();
			// Imprime o elemento na posição informada pelo usuário
			System.out.println(vect[position]);
		} catch (ArrayIndexOutOfBoundsException e) {
			// Trata o caso em que a posição informada é inválida
			System.out.println("Posição inválida!");
			// Imprime o rastreamento da Stack na tela
			e.printStackTrace();
			// Avança para a próxima linha de entrada
			sc.next();
		} catch (InputMismatchException e) {
			// Trata o caso em que o usuário informa um valor que não é inteiro
			System.out.println("Erro de input");
		}
		// Fecha o objeto Scanner
		sc.close();
		// Imprime "***FIM DO MÉTODO2***" na tela
		System.out.println("***FIM DO MÉTODO2***");
	}

	/*
	 * Observe que printStackTrace proporciona imprimir 
	 * o rastreamento do Stack com todas as etapas
	 * que geraram a exceção.
	 * Observe, também, que o programa não quebra. 
	 * Ele continua a funcionar.
	 */
}
O método printStackTrace imprime na saída de erro (geralmente o console) a pilha de chamadas que levou ao lançamento da exceção. Isso inclui o nome da classe e o método onde a exceção foi lançada, bem como a linha de código onde isso aconteceu.

A importância desse método é que ele permite aos desenvolvedores diagnosticar rapidamente a causa raiz de um erro e identificar facilmente a origem de um problema no código. Ao utilizar printStackTrace, os desenvolvedores podem ter uma visão geral do que aconteceu no momento do erro e tomar medidas para corrigir o problema. Além disso, também pode ser útil para documentar o erro em relatórios de bug ou para resolução de problemas com o suporte.
 


===================================================================================================================== 
  Bloco finally
 
import java.io.File;
import java.io.IOException;
import java.util.Scanner;

public class Program4 {
	public static void main(String[] args) {
		//Declarando uma variável do tipo File com o caminho do arquivo
		File file = new File("C:\\temp\\in.txt");
		
		//Declarando uma variável do tipo Scanner com valor inicial null
		Scanner sc = null;
		
		//Iniciando um bloco try para abertura do arquivo
		try {
			//Atribuindo ao objeto sc um novo objeto Scanner a partir do arquivo
			sc = new Scanner(file);
			
			//Enquanto houver uma próxima linha no arquivo
			while (sc.hasNextLine()) {
				//Imprime a próxima linha
				System.out.println(sc.nextLine());
			}
		//Tratamento de exceção em caso de erro na abertura do arquivo
		} catch (IOException e) {
			System.out.println("Erro na abertura do arquivo: " + e.getMessage());
		
		//Bloco finally é executado de qualquer forma, independentemente de haver ou não exceção
		} finally {
			//Verifica se o objeto sc não é nulo antes de fechar o arquivo
			if (sc != null) {
				sc.close();
			}
			System.out.println("Bloco finally executado! ");
		}
	}
}
 


===================================================================================================================== 
  Criando exceções personalizadas
 


===================================================================================================================== 
  Sugestão de pacotes "model"
 
 
 
 
 


===================================================================================================================== 
  Solução muito ruim
package model.entities;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.TimeUnit;

public class Reserva {
	private Integer numeroDoQuarto;
	private Date checkIn;
	private Date checkOut;
	
	private static SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");

	public Reserva(Integer numeroDoQuarto, Date checkIn, Date checkOut) {
		this.numeroDoQuarto = numeroDoQuarto;
		this.checkIn = checkIn;
		this.checkOut = checkOut;
	}

	public Integer getNumeroDoQuarto() {
		return numeroDoQuarto;
	}

	public void setNumeroDoQuarto(Integer numeroDoQuarto) {
		this.numeroDoQuarto = numeroDoQuarto;
	}

	public Date getCheckIn() {
		return checkIn;
	}

	public Date getCheckOut() {
		return checkOut;
	}
	
	//calculando a duração, em dias, com base em duas datas
	public long duracao() {
		//pegando a diferença entre as datas em milissegundos
		long diferenca = checkOut.getTime() - checkIn.getTime();
		//convertendo milissegundos em dias
		 return TimeUnit.DAYS.convert(diferenca, TimeUnit.MILLISECONDS);
	}
	
	public void atualizaDatas(Date checkIn, Date checkOut) {
		this.checkIn = checkIn;
		this.checkOut = checkOut;
	}
	
	@Override
	public String toString() {
		return "Quarto "
				+ numeroDoQuarto
				+ ", check-in: "
				+ sdf.format(checkIn)
				+", check-out: "
				+ sdf.format(checkOut)
				+ ", "
				+ duracao()
				+ " noites";
		
	}

}
package application;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.Scanner;

import model.entities.Reserva;

public class Programa {
											//throws para propagar exceção na classe main
	public static void main(String[] args) throws ParseException {
		/*
		 * SOLUÇÃO MUITO RUIM!:
		 * Regras de validação no programa principal
		 */
		
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
		
		System.out.print("Quarto número: ");
		int numero = sc.nextInt();
		System.out.println("Check-in data (dd/MM/yyyy): ");
		/*
		 * sdf.parse pode gerar uma exceção, por isso o compilador
		 * reclama para tratar a exceção com try-catch ou propagar com 
		 * throws na Classe main.
		 * Feito o throws, em qualquer lugar na Classe main onde houver 
		 * esta exceção gerada pelo sdf.parse, ela será tratada.
		 * Ou seja, foi propagado o tratamento para toda a Classe main
		 */
		Date checkIn = sdf.parse(sc.next());
		System.out.println("Check-out data (dd/MM/yyyy): ");
		Date checkOut = sdf.parse(sc.next());
		
		//Testando se a data de check-out é maior que a de check-in
		if(!checkOut.after(checkIn)) {
			System.out.println("Erro na reserva! Data do check-out precisa ser posterior à data do check-in ");
		}else {
			Reserva reserva = new Reserva(numero, checkIn, checkOut);
			System.out.println("Reserva: " + reserva);
			
			System.out.println();
			System.out.println("Entre com a data para atualizar a reserva: ");
			
			System.out.println("Check-in data (dd/MM/yyyy): ");
			 checkIn = sdf.parse(sc.next());
			System.out.println("Check-out data (dd/MM/yyyy): ");
			 checkOut = sdf.parse(sc.next());
			 
			 //Testando as condições das datas de atualização da reserva
			 Date agora = new Date();
			 if(checkIn.before(agora) || checkOut.before(agora)) {
				 System.out.println("Erro na reserva! As datas da resera têm que ser futuras");
			 }else if(!checkOut.after(checkIn)) {
				 System.out.println("Erro na reserva! A data de check-out tem que ser posterior à data de check-in");
			 }else {
			 
			 //Método responsável por atualizar datas
			 reserva.atualizaDatas(checkIn, checkOut);
			 System.out.println("Reserva: " + reserva);
			 }
		}
	
		sc.close();
	}

}
 


===================================================================================================================== 
  Solução ruim
package model.entities;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.TimeUnit;

public class Reserva {
	private Integer numeroDoQuarto;
	private Date checkIn;
	private Date checkOut;

	private static SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");

	public Reserva(Integer numeroDoQuarto, Date checkIn, Date checkOut) {
		this.numeroDoQuarto = numeroDoQuarto;
		this.checkIn = checkIn;
		this.checkOut = checkOut;
	}

	public Integer getNumeroDoQuarto() {
		return numeroDoQuarto;
	}

	public void setNumeroDoQuarto(Integer numeroDoQuarto) {
		this.numeroDoQuarto = numeroDoQuarto;
	}

	public Date getCheckIn() {
		return checkIn;
	}

	public Date getCheckOut() {
		return checkOut;
	}

	// calculando a duração, em dias, com base em duas datas
	public long duracao() {
		// pegando a diferença entre as datas em milissegundos
		long diferenca = checkOut.getTime() - checkIn.getTime();
		// convertendo milissegundos em dias
		return TimeUnit.DAYS.convert(diferenca, TimeUnit.MILLISECONDS);
	}
	
	//Regras de validação
	public String atualizaDatas(Date checkIn, Date checkOut) {
		Date agora = new Date();
		if (checkIn.before(agora) || checkOut.before(agora)) {
			return "Erro na reserva! As datas da resera têm que ser futuras";
		} 
		
		if (!checkOut.after(checkIn)) {
			return "Erro na reserva! A data de check-out tem que ser posterior à data de check-in";
		}
		this.checkIn = checkIn;
		this.checkOut = checkOut;
		
		return null;
	}

	@Override
	public String toString() {
		return "Quarto " + numeroDoQuarto + ", check-in: " + sdf.format(checkIn) + ", check-out: "
				+ sdf.format(checkOut) + ", " + duracao() + " noites";

	}

}
package application;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.Scanner;

import model.entities.Reserva;

public class Programa {
	// throws para propagar exceção na classe main
	public static void main(String[] args) throws ParseException {
		/*
		 * SOLUÇÃO MUITO RUIM!: Regras de validação na Classe Reserva
		 */

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");

		System.out.print("Quarto número: ");
		int numero = sc.nextInt();
		System.out.println("Check-in data (dd/MM/yyyy): ");
		/*
		 * sdf.parse pode gerar uma exceção, por isso o compilador reclama para tratar a
		 * exceção com try-catch ou propagar com throws na Classe main. Feito o throws,
		 * em qualquer lugar na Classe main onde houver esta exceção gerada pelo
		 * sdf.parse, ela será tratada. Ou seja, foi propagado o tratamento para toda a
		 * Classe main
		 */
		Date checkIn = sdf.parse(sc.next());
		System.out.println("Check-out data (dd/MM/yyyy): ");
		Date checkOut = sdf.parse(sc.next());

		// Testando se a data de check-out é maior que a de check-in
		if (!checkOut.after(checkIn)) {
			System.out.println("Erro na reserva! Data do check-out precisa ser posterior à data do check-in ");
		} else {
			Reserva reserva = new Reserva(numero, checkIn, checkOut);
			System.out.println("Reserva: " + reserva);

			System.out.println();
			System.out.println("Entre com a data para atualizar a reserva: ");

			System.out.println("Check-in data (dd/MM/yyyy): ");
			checkIn = sdf.parse(sc.next());
			System.out.println("Check-out data (dd/MM/yyyy): ");
			checkOut = sdf.parse(sc.next());
			// Método responsável por atualizar datas
			String erro = reserva.atualizaDatas(checkIn, checkOut);
			if (erro != null) {
				System.out.println("Erro na reserva: " + erro);
			}
			System.out.println("Reserva: " + reserva);
		}

		sc.close();
	}

}
 


===================================================================================================================== 
  Solução boa
package model.entities;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.TimeUnit;

public class Reserva {
	private Integer numeroDoQuarto;
	private Date checkIn;
	private Date checkOut;

	private static SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");

	public Reserva(Integer numeroDoQuarto, Date checkIn, Date checkOut) {
		this.numeroDoQuarto = numeroDoQuarto;
		this.checkIn = checkIn;
		this.checkOut = checkOut;
	}

	public Integer getNumeroDoQuarto() {
		return numeroDoQuarto;
	}

	public void setNumeroDoQuarto(Integer numeroDoQuarto) {
		this.numeroDoQuarto = numeroDoQuarto;
	}

	public Date getCheckIn() {
		return checkIn;
	}

	public Date getCheckOut() {
		return checkOut;
	}

	// calculando a duração, em dias, com base em duas datas
	public long duracao() {
		// pegando a diferença entre as datas em milissegundos
		long diferenca = checkOut.getTime() - checkIn.getTime();
		// convertendo milissegundos em dias
		return TimeUnit.DAYS.convert(diferenca, TimeUnit.MILLISECONDS);
	}

	// Regras de validação
	public void atualizaDatas(Date checkIn, Date checkOut) {
		Date agora = new Date();
		if (checkIn.before(agora) || checkOut.before(agora)) {
			throw new IllegalArgumentException("Erro na reserva! As datas da resera têm que ser futuras");
		}
		if (!checkOut.after(checkIn)) {
			throw new IllegalArgumentException(
					"Erro na reserva! A data de check-out tem que ser posterior à data de check-in");
		}
		this.checkIn = checkIn;
		this.checkOut = checkOut;
	}

	@Override
	public String toString() {
		return "Quarto " + numeroDoQuarto + ", check-in: " + sdf.format(checkIn) + ", check-out: "
				+ sdf.format(checkOut) + ", " + duracao() + " noites";

	}

}
package application;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.Scanner;

import model.entities.Reserva;

public class Programa {
	public static void main(String[] args) {
		/*
		 * SOLUÇÃO BOA: Tratando exceções
		 */

			Locale.setDefault(Locale.US);
			Scanner sc = new Scanner(System.in);
			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
			
			try {
			System.out.print("Quarto número: ");
			int numero = sc.nextInt();
			System.out.println("Check-in data (dd/MM/yyyy): ");
			Date checkIn = sdf.parse(sc.next());
			System.out.println("Check-out data (dd/MM/yyyy): ");
			Date checkOut = sdf.parse(sc.next());
			Reserva reserva = new Reserva(numero, checkIn, checkOut);
			System.out.println("Reserva: " + reserva);
			System.out.println();
			System.out.println("Entre com a data para atualizar a reserva: ");
			System.out.println("Check-in data (dd/MM/yyyy): ");
			checkIn = sdf.parse(sc.next());
			System.out.println("Check-out data (dd/MM/yyyy): ");
			checkOut = sdf.parse(sc.next());
			// Método responsável por atualizar datas
			reserva.atualizaDatas(checkIn, checkOut);
			System.out.println("Reserva: " + reserva);
		}catch(ParseException e) {
			System.out.println("Formato de data inválido");
		}catch(IllegalArgumentException e) {
			System.out.println("Erro na reserva: " + e.getMessage());
		}
		
		sc.close();
	}

}
 


===================================================================================================================== 
  Exceção personalizada 
package model.entities;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.TimeUnit;

import model.exceptions.DomainException;

public class Reserva {
	private Integer numeroDoQuarto;
	private Date checkIn;
	private Date checkOut;

	private static SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");

	public Reserva(Integer numeroDoQuarto, Date checkIn, Date checkOut) throws DomainException {
		//Tratando a exceção dentro do contrutor
		if (!checkOut.after(checkIn)) {
			throw new DomainException("Erro na reserva! A data de check-out tem que ser posterior à data de check-in");
		}
		
		this.numeroDoQuarto = numeroDoQuarto;
		this.checkIn = checkIn;
		this.checkOut = checkOut;
	}

	public Integer getNumeroDoQuarto() {
		return numeroDoQuarto;
	}

	public void setNumeroDoQuarto(Integer numeroDoQuarto) {
		this.numeroDoQuarto = numeroDoQuarto;
	}

	public Date getCheckIn() {
		return checkIn;
	}

	public Date getCheckOut() {
		return checkOut;
	}

	// calculando a duração, em dias, com base em duas datas
	public long duracao() {
		// pegando a diferença entre as datas em milissegundos
		long diferenca = checkOut.getTime() - checkIn.getTime();
		// convertendo milissegundos em dias
		return TimeUnit.DAYS.convert(diferenca, TimeUnit.MILLISECONDS);
	}

	// Regras de validação                                 //Exceção propagada na assinatura do método
	public void atualizaDatas(Date checkIn, Date checkOut) throws DomainException {
		Date agora = new Date();
		if (checkIn.before(agora) || checkOut.before(agora)) {
			throw new DomainException("Erro na reserva! As datas da resera têm que ser futuras");
		}
		if (!checkOut.after(checkIn)) {
			throw new DomainException("Erro na reserva! A data de check-out tem que ser posterior à data de check-in");
		}
		this.checkIn = checkIn;
		this.checkOut = checkOut;
	}

	@Override
	public String toString() {
		return "Quarto " + numeroDoQuarto + ", check-in: " + sdf.format(checkIn) + ", check-out: "
				+ sdf.format(checkOut) + ", " + duracao() + " noites";

	}

}

package model.exceptions;

public class DomainException extends Exception {
	/*
	 * serialVersionUID - Indicado pelo compilador, pois a Classe DomainException é tipo serializable:
	 * os objetos pode ser convertidos para bytes para trafegar em rede ou ser
	 * gravados em arquivos
	 */
	private static final long serialVersionUID = 1L;
	
	public DomainException(String msg) {
		super(msg);/*Repassando a mensagem para o construtor da superclasse
					para permitir instanciar a exceção personalizada passando uma mensagem 
					para ela. A mensagem fica armazenada dentro da exceção.
		 				*/
		
	}
}

package application;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.Scanner;

import model.entities.Reserva;
import model.exceptions.DomainException;

public class Programa {
	public static void main(String[] args) {
		/*
		 * SOLUÇÃO BOA: Tratando exceções
		 */

			Locale.setDefault(Locale.US);
			Scanner sc = new Scanner(System.in);
			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
			
			try {
			System.out.print("Quarto número: ");
			int numero = sc.nextInt();
			System.out.println("Check-in data (dd/MM/yyyy): ");
			Date checkIn = sdf.parse(sc.next());
			System.out.println("Check-out data (dd/MM/yyyy): ");
			Date checkOut = sdf.parse(sc.next());
			Reserva reserva = new Reserva(numero, checkIn, checkOut);
			System.out.println("Reserva: " + reserva);
			System.out.println();
			System.out.println("Entre com a data para atualizar a reserva: ");
			System.out.println("Check-in data (dd/MM/yyyy): ");
			checkIn = sdf.parse(sc.next());
			System.out.println("Check-out data (dd/MM/yyyy): ");
			checkOut = sdf.parse(sc.next());
			// Método responsável por atualizar datas
			reserva.atualizaDatas(checkIn, checkOut);
			System.out.println("Reserva: " + reserva);
		}catch(ParseException e) {
			System.out.println("Formato de data inválido");
		}catch(DomainException e) {
			System.out.println("Erro na reserva: " + e.getMessage());
		}
		
		sc.close();
	}

}
 


===================================================================================================================== 
  Usando RunTimeException para exceção personalizada 
package model.entities;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.TimeUnit;

import model.exceptions.DomainException;

public class Reserva {
	private Integer numeroDoQuarto;
	private Date checkIn;
	private Date checkOut;

	private static SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");

	public Reserva(Integer numeroDoQuarto, Date checkIn, Date checkOut) {
		//Tratando a exceção dentro do contrutor - se checkOut for anterior a checkIn
		if (!checkOut.after(checkIn)) {
			throw new DomainException("Erro na reserva! A data de check-out tem que ser posterior à data de check-in");
		}		
		this.numeroDoQuarto = numeroDoQuarto;
		this.checkIn = checkIn;
		this.checkOut = checkOut;
	}

	public Integer getNumeroDoQuarto() {
		return numeroDoQuarto;
	}

	public void setNumeroDoQuarto(Integer numeroDoQuarto) {
		this.numeroDoQuarto = numeroDoQuarto;
	}

	public Date getCheckIn() {
		return checkIn;
	}

	public Date getCheckOut() {
		return checkOut;
	}

	// calculando a duração, em dias, com base em duas datas
	public long duracao() {
		// pegando a diferença entre as datas em milissegundos
		long diferenca = checkOut.getTime() - checkIn.getTime();
		// convertendo milissegundos em dias
		return TimeUnit.DAYS.convert(diferenca, TimeUnit.MILLISECONDS);
	}

	// Regras de validação                                 //Exceção propagada na assinatura do método
	public void atualizaDatas(Date checkIn, Date checkOut) {
		Date agora = new Date();
		if (checkIn.before(agora) || checkOut.before(agora)) {
			throw new DomainException("Erro na reserva! As datas da resera têm que ser futuras");
		}
		if (!checkOut.after(checkIn)) {
			throw new DomainException("Erro na reserva! A data de check-out tem que ser posterior à data de check-in");
		}
		this.checkIn = checkIn;
		this.checkOut = checkOut;
	}

	@Override
	public String toString() {
		return "Quarto " + numeroDoQuarto + ", check-in: " + sdf.format(checkIn) + ", check-out: "
				+ sdf.format(checkOut) + ", " + duracao() + " noites";

	}

}
package model.exceptions;

public class DomainException extends RuntimeException {
	/*
	 * Usando RunTimeException em vez de Exception, não será necessário propagar
	 * throws nos métodos, pois não é mais obrigatório o tratamento de erro.
	 * serialVersionUID - Indicado pelo compilador, pois a Classe DomainException é
	 * tipo serializable: os objetos pode ser convertidos para bytes para trafegar
	 * em rede ou ser gravados em arquivos
	 */
	private static final long serialVersionUID = 1L;

	public DomainException(String msg) {
		super(msg);/*
					 * Repassando a mensagem para o construtor da superclasse para permitir
					 * instanciar a exceção personalizada passando uma mensagem para ela. A mensagem
					 * fica armazenada dentro da exceção.
					 */

	}
}
package application;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.Scanner;

import model.entities.Reserva;
import model.exceptions.DomainException;

public class Programa {
	public static void main(String[] args) {
		/*
		 * SOLUÇÃO BOA: Tratando exceções
		 */

			Locale.setDefault(Locale.US);
			Scanner sc = new Scanner(System.in);
			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
			
			try {
			System.out.print("Quarto número: ");
			int numero = sc.nextInt();
			System.out.println("Check-in data (dd/MM/yyyy): ");
			Date checkIn = sdf.parse(sc.next());
			System.out.println("Check-out data (dd/MM/yyyy): ");
			Date checkOut = sdf.parse(sc.next());
			Reserva reserva = new Reserva(numero, checkIn, checkOut);
			System.out.println("Reserva: " + reserva);
			System.out.println();
			System.out.println("Entre com a data para atualizar a reserva: ");
			System.out.println("Check-in data (dd/MM/yyyy): ");
			checkIn = sdf.parse(sc.next());
			System.out.println("Check-out data (dd/MM/yyyy): ");
			checkOut = sdf.parse(sc.next());
			// Método responsável por atualizar datas
			reserva.atualizaDatas(checkIn, checkOut);
			System.out.println("Reserva: " + reserva);
		}catch(ParseException e) {
			System.out.println("Formato de data inválido");
		}catch(DomainException e) {
			System.out.println("Erro na reserva: " + e.getMessage());
		}
		
		sc.close();
	}

}
 
 
 


===================================================================================================================== 
  Exercício de fixação
 
 
 
 


===================================================================================================================== 
  Exceção personalizada
package model.conta;

import model.exceptions.DomainException;

public class Conta {
	
	// Declaração de variáveis privadas
	private Integer numero;
	private String nome;
	private Double saldo;
	private Double limiteDeSaque;
	
	// Construtor vazio
	public Conta() {		
	}
	
	// Construtor com argumentos
	public Conta(Integer numero, String nome, Double saldo, Double limiteDeSaque) {
		this.numero = numero;
		this.nome = nome;
		this.saldo = saldo;
		this.limiteDeSaque = limiteDeSaque;
	}

	// Método para retornar o número da conta
	public Integer getNumero() {
		return numero;
	}

	// Método para setar o número da conta
	public void setNumero(Integer numero) {
		this.numero = numero;
	}

	// Método para retornar o nome do titular da conta
	public String getNome() {
		return nome;
	}

	// Método para setar o nome do titular da conta
	public void setNome(String nome) {
		this.nome = nome;
	}

	// Método para retornar o saldo da conta
	public Double getSaldo() {
		return saldo;
	}

	// Método para retornar o limite de saque da conta
	public Double getLimiteDeSaque() {
		return limiteDeSaque;
	}
	
	// Método para efetuar um depósito
	public void deposito(Double valor) {
		saldo = saldo + valor;
	}
	
	// Método para efetuar um saque
	public void saque(Double valor) {
		if(valor > saldo) {
			throw new DomainException("Valor excede o saldo da conta.");
		}else if(valor > limiteDeSaque) {
			throw new DomainException("Valor excede o limite de saque.");
		}
		saldo = saldo - valor;
	}

}

package application;

import java.util.Locale;
import java.util.Scanner;

import model.conta.Conta;
import model.exceptions.DomainException;


public class Programa {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		try {
		System.out.println("Entre com os dados da conta:");
		System.out.print("Número: ");
		int numero = sc.nextInt();
		System.out.print("Nome: ");
		String nome = sc.next();
		System.out.print("Deposito inicial: ");
		Double valor = sc.nextDouble();
		System.out.print("Limite de saque: ");
		Double limiteDeSaque = sc.nextDouble();
		Conta c = new Conta(numero, nome, valor, limiteDeSaque);
		System.out.println();
		System.out.print("Entre com o valor para saque: ");
		valor = sc.nextDouble();
		c.saque(valor);
		System.out.print("Novo saldo: " + c.getSaldo());
		}
		catch(DomainException e) {
			System.out.println(e.getMessage());
		}
		
		sc.close();

	}

}
package model.exceptions;

public class DomainException extends RuntimeException {
	private static final long serialVersionUID = 1L;
	
	public DomainException(String msg) {
		super(msg);
	}	
}

 


===================================================================================================================== 
  Tratando exceções
package entities;

public class Conta {

	// Declaração das variáveis de instância
	private Integer numero;
	private String nome;
	private Double saldo;
	private Double limiteDeSaque;

	// Construtor padrão
	public Conta() {
	}

	// Construtor com parâmetros
	public Conta(Integer numero, String nome, Double saldo, Double limiteDeSaque) {
		this.numero = numero;
		this.nome = nome;
		this.saldo = saldo;
		this.limiteDeSaque = limiteDeSaque;
	}

	// Getters e setters
	public Integer getNumero() {
		return numero;
	}

	public void setNumero(Integer numero) {
		this.numero = numero;
	}

	public String getNome() {
		return nome;
	}

	public void setNome(String nome) {
		this.nome = nome;
	}

	public Double getSaldo() {
		return saldo;
	}

	public Double getLimiteDeSaque() {
		return limiteDeSaque;
	}

	// Método deposito
	public void deposito(Double valor) {
		saldo = saldo + valor;
	}

	public void saque(Double valor) {
		if (valor > saldo) {
			throw new IllegalArgumentException("Valor excede o saldo da conta.");
		} else if (valor > limiteDeSaque)
			throw new IllegalArgumentException("Valor excede o limite de saque.");

		saldo = saldo - valor;
	}
}

package application;

import java.util.Locale;
import java.util.Scanner;

public class Programa {

    public static void main(String[] args) {
        Locale.setDefault(Locale.US);
        Scanner sc = new Scanner(System.in);

        try {
            // Entrada de dados da conta
            System.out.println("Entre com os dados da conta:");
            System.out.print("Número: ");
            int numero = sc.nextInt();
            System.out.print("Nome: ");
            String nome = sc.next();
            System.out.print("Deposito inicial: ");
            Double valor = sc.nextDouble();
            System.out.print("Limite de saque: ");
            Double limiteDeSaque = sc.nextDouble();
            
            // Criação da conta
            Conta c = new Conta(numero, nome, valor, limiteDeSaque);
            System.out.println();
            
            // Realização de saque
            System.out.print("Entre com o valor para saque: ");
            valor = sc.nextDouble();
            c.saque(valor);
            
            // Exibição do novo saldo
            System.out.print("Novo saldo: " + c.getSaldo());
        } catch (RuntimeException e) {
            System.out.println(e.getMessage());
        }
        sc.close();
    }

 


===================================================================================================================== 
  Trabalhando com arquivos
 


===================================================================================================================== 
  Lendo arquivo texto com classes File e Scanner
 
package application;

import java.io.File;
import java.io.IOException;
import java.util.Locale;
import java.util.Scanner;

public class Programa {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		
		//Instanciando objeto do tipo File. Este objeto vai incapsular todo o processo de acessar o arquivo
		File file = new File("/home/ivan_carlos/Documentos/Cursos Online/Curso Java/in.txt");
		Scanner sc = null;//Começando com null pra ela ter um valor inicial
		
		
		/*
		 * Quando se instancia um Scanner a partir de um arquivo, ele pode retornar
		 * uma exceção. Por isso, é necessário fazer essa instanciação dentro de 
		 * um bloco try
		 */
		try {
			sc = new Scanner(file);
			
			//Enquanto existir uma nova linha no arquivo, ela será impressa
			while (sc.hasNextLine()) {
				System.out.println(sc.nextLine());
			}
		} catch (IOException e) {
			System.out.println("Erro!" + e.getMessage());
		}
		
		//BOA PRÁTICA: Bloco finally para fechar o Scanner
		finally {
			if(sc != null) {
				sc.close();
			}
		}
	}
}
 


===================================================================================================================== 
  FileReader e BufferedReader
 
ABRINDO E FECHANDO MANUELMENTE AS STREAMS FileReader e BufferedReader
package application;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

//ABRINDO E FECHANDO MANUELMENTE AS STREAMS FileReader e BufferedReader

public class Programa2 {

	public static void main(String[] args) {		
		String caminho = "/home/ivan_carlos/Documentos/Cursos Online/Curso Java/in.txt";
		
		FileReader fr = null;
		BufferedReader br = null;
		
		try {
			/*
			 * Instanciando objeto do tipo FileReader e colocando como caminho
			 * o caminho do arquivo. Estabelece uma stream, uma sequência de leitura, 
			 * a partir do arquivo que estiver no caminho "caminho"
			 */
			fr = new FileReader(caminho);
			
			/*
			 * BufferedReader é instanciado a partir do FileReader. 
			 * Ele é uma abstração maior. A partir da stream mais básica,
			 * instacia-se a stream com esquema de Buffer para ficar mais 
			 * rápida a leitura
			 * 
			 */
			br = new BufferedReader(fr);
			
			/*
			 * readLine vai ler uma linha do arquivo. Se o arquivo estiver
			 * no final, o readLine retorna null. Por isso precisa de while
			 * em seguida para testar se o readLine vai retornar null.
			 */
			String line = br.readLine();
			
			/*
			 * Enquanto line não retornar null, ele imprime a linha lida e 
			 * lê a próxima linha
			 */
			while(line != null) {
				System.out.println(line);
				line = br.readLine();
			}			
		}
		catch (IOException e) {
			System.out.println("Erro! " + e.getMessage());
		}
				
		//ATENÇÃO!
		/*
		 * Na hora de fechar os streams pode haver exceção. Por isso
		 * precisa abrir um bloco try
		 */
		finally {
			try {
			if(br != null) {
				br.close();
			}
			if(fr != null) {
				fr.close();
			}
			}
			catch(IOException e){
				e.printStackTrace();
			}
		}
	}
}
 


===================================================================================================================== 
  Bloco try-with-resources
 
package application;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class Programa3 {

    public static void main(String[] args) {
        // Define o caminho para o arquivo de texto que será lido
        String caminho = "/home/ivan_carlos/Documentos/Cursos Online/Curso Java/in.txt";

        // Utiliza a classe BufferedReader para ler o arquivo
        try (BufferedReader br = new BufferedReader(new FileReader(caminho))) {
            // Lê a primeira linha do arquivo
            String line = br.readLine();

            // Enquanto houver linhas no arquivo
            while (line != null) {
                // Imprime a linha lida
                System.out.println(line);
                // Lê a próxima linha
                line = br.readLine();
            }
        } catch (IOException e) {
            // Em caso de erro na leitura do arquivo, imprime a mensagem de erro
            System.out.println("Erro ao ler o arquivo! " + e.getMessage());
        }
    }

}

//MELHOR FORMA DE LER ARQUIVOS.
 


===================================================================================================================== 
  FileWriter e BufferedWriter
 
 
package application;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class Programa4 {

	public static void main(String[] args) {
		
		//Criando um vetor de Strings
		String[] lines = new String[] {"Bom dia", "Boa tarde", "Boa noite"};
		
		//Criando um arquivo
		String caminho = "/home/ivan_carlos/Documentos/Cursos Online/Curso Java/out.txt";
		
		//Gravando os dados no arquivo
		try(BufferedWriter bw = new BufferedWriter(new FileWriter(caminho))){
			
			for(String line : lines) {
				bw.write(line);
				
				//inserir quebra de linha
				bw.newLine();
			}
		}
		catch (IOException e) {
			e.printStackTrace();
		}
		
		/*
		 *  Dessa forma, toda vez que o programa for rodado, 
		 *  um novo arquivo será criado e os dados serão 
		 *  gravados novamente. Para isso não acontecer,
		 *  Coloca-se true como segundo argumento de FileWriter
		 */
	}
	
}
package application;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class Programa5 {

	public static void main(String[] args) {
		//Criando um vetor de Strings
		String[] lines = new String[] {"Bom dia", "Boa tarde", "Boa noite"};
		
		//Criando um arquivo
		String caminho = "/home/ivan_carlos/Documentos/Cursos Online/Curso Java/out.txt";
		
		//Gravando os dados no arquivo
		try(BufferedWriter bw = new BufferedWriter(new FileWriter(caminho, true))){
			
			for(String line : lines) {
				bw.write(line);
				
				//inserir quebra de linha
				bw.newLine();
			}
		}
		catch (IOException e) {
			e.printStackTrace();
		}
		
		/*
		 *  Dessa forma, pode-se acrescentar mais linhas
		 *  ao arquivo sem ter que criá-lo novamente
		 */
	}
}
 


===================================================================================================================== 
  Manipulando pastas com File
package application;

import java.io.File;
import java.util.Scanner;

public class Programa {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		//Solicitando que um caminho de pasta seja digitado
		System.out.println("Digite um caminho de uma pasta: ");
		String strCaminho = sc.nextLine();
		
		//Instanciando objeto do tipo File, recebendo strCaminho como argumento
		File caminho = new File(strCaminho);
		
		//GERANDO UM LISTAGEM DE ENDEREÇOS DE ARQUIVOS 
		/*
		 * Instancia-se uma variável do tipo vetor de File recebendo
		 * caminho.listFiles e, como argumento, a função File :: isDirectory
		 */
		
		File[] pastas = caminho.listFiles(File::isDirectory);
		System.out.println("Pastas:");
		
		//Para listar todos os endereços de pastas dentro do endereço diditado
		for(File pasta : pastas) {
			System.out.println(pasta);
		}
		
		//GERANDO LISTAGEM DE ARQUIVOS
		/*
		 * Instancia-se uma variável do tipo vetor de File recebendo
		 * caminho.listFiles e, como argumento, a função File :: isFile
		 */
		
		File[] arquivos = caminho.listFiles(File::isFile);
		System.out.println("Arquivos:");
		
		for(File arquivo : arquivos) {
			System.out.println(arquivo);
		}	
		
		//CRIANDO UMA SUBPASTA A PARTIR DO ENDEREÇO DIGITADO
		boolean success = new File(strCaminho + "\\subdir").mkdir();
		System.out.println("Diretória cridado com sucesso! " + success);
		
		//INFORMAÇÕES SOBRE CAMINHO DO ARQUIVO
		System.out.println("Digite o caminho do arquivo: ");
		String strCaminhoArquivo = sc.nextLine();
		
		//Instanciando um novo objeto do tipo File com strCaminhoArquivo como argumento
		File caminhoArquivo = new File(strCaminhoArquivo);
		
		//Imprimindo o nome do arquivo com getName
		System.out.println("getName: " + caminhoArquivo.getName());
		
		//Imprimindo o caminho do arquivo com getParent
		System.out.println("getParent: " + caminhoArquivo.getParent());
		
		//Imprimindo o caminho completo com getPath
		System.out.println("getPath: " + caminhoArquivo.getPath());
		sc.close();
	}
}
 


===================================================================================================================== 
  Exercício proposto
 
 
package entities;

public class Produto {

	// Declaração das variáveis de instância do produto
	private String nome;
	private Double preco;
	private Integer quantidade;

// Construtor padrão
	public Produto() {
	}

// Construtor com argumentos
	public Produto(String nome, Double preco, Integer quantidade) {
		this.nome = nome;
		this.preco = preco;
		this.quantidade = quantidade;
	}

// Getters e Setters para as variáveis de instância
	public String getNome() {
		return nome;
	}

	public void setNome(String nome) {
		this.nome = nome;
	}

	public Double getPreco() {
		return preco;
	}

	public void setPreco(Double preco) {
		this.preco = preco;
	}

	public Integer getQuantidade() {
		return quantidade;
	}

	public void setQuantidade(Integer quantidade) {
		this.quantidade = quantidade;
	}

// Método para calcular o total de compra
	public double total() {
		return preco * quantidade;
	}
}
package application;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Scanner;

import entities.Produto;

public class Program {

	public static void main(String[] args) throws ParseException {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		List<Produto> list = new ArrayList<>();
		
		//Solicitando o caminho do arquivo
		System.out.println("Entre com o caminho do arquivo:");
		String caminhoArquivoStr = sc.nextLine();
		
		//Instanciando objeto do tipo File com a variável caminhoArquivoStr como argumento
		File caminhoArquivo = new File(caminhoArquivoStr);
		
		//Pegandoo caminho da pasta de origem
		String caminhoPastaOrigemStr = caminhoArquivo.getParent();
		
		//Criando pasta out
		boolean success = new File(caminhoPastaOrigemStr + "/out").mkdir();
		
		//Criando arquivo de saída 
		String arquivoSaidaStr = caminhoPastaOrigemStr + "/out/sumary.csv";
		
		//Fazendo a leitura do arquivo
		/*
		 * Com bloco try, vai tentar ler o arquivo. Se conseguir, retorna os itens 
		 * Se não conseguir, ele retorna o catch.
		 */
		try(BufferedReader br = new BufferedReader(new FileReader(caminhoArquivoStr))){
			
			//Lendo o arquivo
			String itemCsv = br.readLine();
			
			//Lendo o arquivo enquanto existir linha
			while(itemCsv != null) {
				
				//Criando um vetor de String para receber itemCsv com valores separados pelo split
				String[] campos = itemCsv.split(",");
				String nome = campos[0];
				
				//Pegando o valores e convertendo de String para Double
				double preco = Double.parseDouble(campos[1]);
				int quantidade = Integer.parseInt(campos[2]);
				
				//Adicionando valores na lista
				list.add(new Produto(nome, preco, quantidade));
				itemCsv = br.readLine();
			}	
			
			//Gravando os itens com o valor total no arquivo de saída
			try(BufferedWriter bw = new BufferedWriter(new FileWriter(arquivoSaidaStr))){
				
				for(Produto item : list) {
					bw.write(item.getNome() + "," + String.format("%.2f", item.total()));
					//Inserindo quebra de linha
					bw.newLine();
				}
				
				System.out.println(arquivoSaidaStr + "Arquivo criado!");
				
			}catch(IOException e) {
				System.out.println("Erro ao escrever arquivo: " + e.getMessage());
			}
			
		}catch(IOException e) {
			System.out.println("Erro na leitura do arquivo: " + e.getMessage());
		}	
		sc.close();
	}
}

 


===================================================================================================================== 
  Interface
 
 
 
 
 
 
 
 
 


===================================================================================================================== 
  Resolução sem inteface
package model.entities;

public class Veiculo {
    // Declare a variável 'modelo' como uma variável privada
	private String modelo;
	
	// construtor sem parâmetros
    public Veiculo() {
	}

	// construtor com parâmetro
    public Veiculo(String modelo) {
		this.modelo = modelo;
	}

	// método getter para a variável 'modelo'
    public String getModelo() {
		return modelo;
	}
	
	// método setter para a variável 'modelo'
    public void setModelo(String modelo) {
		this.modelo = modelo;
	}
}

package model.entities;

public class Fatura {
    // Declare a variável 'pagBasico' como uma variável privada
	private Double pagBasico;
    // Declare a variável 'imposto' como uma variável privada
	private Double imposto;
	
	// construtor sem parâmetros
    public Fatura() {
	}

	// construtor com parâmetros
    public Fatura(Double pagBasico, Double imposto) {
		this.pagBasico = pagBasico;
		this.imposto = imposto;
	}

	// método getter para a variável 'pagBasico'
    public Double getPagBasico() {
		return pagBasico;
	}
	
	// método setter para a variável 'pagBasico'
    public void setPagBasico(Double pagBasico) {
		this.pagBasico = pagBasico;
	}

	// método getter para a variável 'imposto'
    public Double getImposto() {
		return imposto;
	}
	
	// método setter para a variável 'imposto'
    public void setImposto(Double imposto) {
		this.imposto = imposto;
	}
	
	// método para calcular o pagamento total (pagBasico - imposto)
    public Double getPagTotal() {
		return getPagBasico() - getImposto();
	}
}

package model.entities;

import java.time.LocalDateTime;

public class AluguelDeCarro {
    // Declare a variável 'inicio' como uma variável privada
	private LocalDateTime inicio;
    // Declare a variável 'fim' como uma variável privada
	private LocalDateTime fim;
	
	//Criação de objetos das Classes Veiculo e Fatura através de composição
	private Veiculo veiculo;//ATENÇÃO!!! Associação com o objeto tipo Veículo
	private Fatura fatura;//ATENÇÃO!!! Associação com o objeto tipo Fatura
	
	// Construtor sem parâmetros
    public AluguelDeCarro() {
	}
	
	/*
	 * ATENÇÃO!!! Observe que, quando vc aluga, a fatura ainda não existe.
	 * Por isso, o construtor não tem Fatura como argumento
	 */
	// Construtor com parâmetros 
    public AluguelDeCarro(LocalDateTime inicio, LocalDateTime fim, Veiculo veiculo) {
		this.inicio = inicio;
		this.fim = fim;
		this.veiculo = veiculo;
	}

	// método getter para a variável 'inicio'
    public LocalDateTime getInicio() {
		return inicio;
	}
	
	// método setter para a variável 'inicio'
    public void setInicio(LocalDateTime inicio) {
		this.inicio = inicio;
	}

	// método getter para a variável 'fim'
    public LocalDateTime getFim() {
		return fim;
	}
	
	// método setter para a variável 'fim'
    public void setFim(LocalDateTime fim) {
		this.fim = fim;
	}

	// método getter para o objeto 'veiculo'
    public Veiculo getVeiculo() {
		return veiculo;
	}
	
	// método setter para o objeto 'veiculo'
    public void setVeiculo(Veiculo veiculo) {
		this.veiculo = veiculo;
	}

	// método getter para o objeto 'fatura'
    public Fatura getFatura() {
		return fatura;
	}
	
	// método setter para o objeto 'fatura'
    public void setFatura(Fatura fatura) {
		this.fatura = fatura;
	}
}

package model.services;

import java.time.Duration;

import model.entities.AluguelDeCarro;
import model.entities.Fatura;

public class ServicoDeAluguel {
	
	private Double precoPorHora;
	private Double precoPorDia;
	
	private ServicoDeImpostoBrasil servicoDeImposto;//Composição de objetos
	
	/*
	 * Não foi inserido o construtor sem argumentos porque
	 * é importante obrigar, ao instanciar o objeto, que se 
	 * informe os argumentos do construtor abaixo
	 */
	
	public ServicoDeAluguel(Double precoPorHora, Double precoPorDia, ServicoDeImpostoBrasil servicoDeImposto) {
		this.precoPorHora = precoPorHora;
		this.precoPorDia = precoPorDia;
		this.servicoDeImposto = servicoDeImposto;
	}
	
	//Processando a fatura
	public void processaFatura(AluguelDeCarro aluguelDeCarro) {
		
		//Duração de tempo entre duas datas em minutos
		double minutos = Duration.between(aluguelDeCarro.getInicio(), aluguelDeCarro.getFim()).toMinutes();
		//Calculando a fração de hora
		double horas = minutos / 60.0;
		
		//Testando se as horas são maiores ou menores que 12
		double pagamentoBasico;
		if(horas <= 12) {
			pagamentoBasico = precoPorHora * Math.ceil(horas);//Math.ceil para arredondar pra cima
		}else {
			pagamentoBasico = precoPorHora * Math.ceil(horas / 24.0);
		}
		
		//Calculando o imposto
		double imposto = servicoDeImposto.imposto(pagamentoBasico);
		
		//Criando a fatura
		aluguelDeCarro.setFatura(new Fatura(pagamentoBasico, imposto));
	}

}
package model.services;

public class ServicoDeImpostoBrasil {
	
	//Método para calcular o imposto a ser pago
	public double imposto(double valor) {
		//Se o valor for menor ou igual a 100.0, o imposto será de 20%
		if(valor <= 100.0) {
			return valor * 0.20;
		}else {
		//Se o valor for maior que 100.0, o imposto será de 15%
			return valor * 0.15;
		}
	}
}

package application;

import java.time.LocalDateTime;

public class Programa {

	public static void main(String[] args) {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		//Criando um objeto de formato de hora
		DateTimeFormatter fmt = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");
		
		System.out.println("Entre com os dados do aluguel:");
		System.out.print("Modelo do carro: ");
		String modelo = sc.nextLine();
		System.out.print("Data e hora da retirada (dd/MM/yyyy hh:mm): ");
		
		//fmt para ler com o formato do objeto tipo DateTimeFormatter
		LocalDateTime inicio = LocalDateTime.parse(sc.nextLine(), fmt);
		
		System.out.print("Data e hora de retorno (dd/MM/yyyy hh:mm): ");
		LocalDateTime fim = LocalDateTime.parse(sc.nextLine(), fmt);
		
		/*
		 * ATENÇÃO!!! Necessário instanciar novo Veiculo no argumento 
		 * pois na Classe AluguelDeCarro o objeto veiculo é do tipo Veiculo
		 */
		//Instanciando o objeto e inserindo os argumentos digitados
		AluguelDeCarro al = new AluguelDeCarro(inicio, fim, new Veiculo(modelo));
		
		System.out.print("Entre com o preço por hora: ");
		double precoPorHora = sc.nextDouble();
		
		System.out.print("Entre com o preço por dia: ");
		double precoPorDia = sc.nextDouble();
		
		//Instanciando o objeto e inserindo os argumentos digitados
		ServicoDeAluguel servicoDeAluguel = new ServicoDeAluguel(precoPorHora, precoPorDia, new ServicoDeImpostoBrasil());
		
		servicoDeAluguel.processaFatura(al);
		System.out.println();
		System.out.println("FATURA:");
		System.out.println("Pagamento básico: " + String.format("%.2f", al.getFatura().getPagBasico()) );
		System.out.println("Imposto: " + String.format("%.2f", al.getFatura().getImposto()) );
		System.out.println("Pagamento total: " + String.format("%.2f", al.getFatura().getPagTotal()));
		
		
		sc.close();

	}

}
 


===================================================================================================================== 
  Solução com inteface
 
package model.entities;

public class Veiculo {

// Atributo para armazenar o modelo do veículo
	private String modelo;

// Construtor padrão sem argumentos
	public Veiculo() {
	}

// Construtor com argumento para inicializar o modelo do veículo
	public Veiculo(String modelo) {
		this.modelo = modelo;
	}

// Método para obter o modelo do veículo
	public String getModelo() {
		return modelo;
	}

// Método para definir o modelo do veículo
public void setModelo(String modelo) {
	this.modelo = modelo;
}

package model.entities;

public class Fatura {

//atributo que armazena o valor básico da fatura
	private Double pagBasico;
//atributo que armazena o valor do imposto da fatura
	private Double imposto;

//Construtor padrão
	public Fatura() {
	}

//Construtor com os valores da fatura
	public Fatura(Double pagBasico, Double imposto) {
		this.pagBasico = pagBasico;
		this.imposto = imposto;
	}

//Método para obter o valor básico da fatura
	public Double getPagBasico() {
		return pagBasico;
	}

//Método para definir o valor básico da fatura
	public void setPagBasico(Double pagBasico) {
		this.pagBasico = pagBasico;
	}

//Método para obter o valor do imposto da fatura
	public Double getImposto() {
		return imposto;
	}

//Método para definir o valor do imposto da fatura
	public void setImposto(Double imposto) {
		this.imposto = imposto;
	}

//Método para obter o valor total da fatura
	public Double getPagTotal() {
		return getPagBasico() + getImposto();
	}
}
package model.entities;

import java.time.LocalDateTime;

public class AluguelDeCarro {
	
	private LocalDateTime inicio;
	private LocalDateTime fim;
	
	//Composição de objetos das Classes Veiculo e Fatura 
	private Veiculo veiculo;//ATENÇÃO!!! Associação com o objeto tipo Veículo
	private Fatura fatura;//ATENÇÃO!!! Associação com o objeto tipo Fatura
	
	public AluguelDeCarro() {
	}
	
	/*
	 * ATENÇÃO!!! Observe que, quando vc aluga, a fatura ainda não existe.
	 * Por isso, o construtor não tem Fatura como argumento
	 */
	public AluguelDeCarro(LocalDateTime inicio, LocalDateTime fim, Veiculo veiculo) {
		this.inicio = inicio;
		this.fim = fim;
		this.veiculo = veiculo;
	}

	public LocalDateTime getInicio() {
		return inicio;
	}

	public void setInicio(LocalDateTime inicio) {
		this.inicio = inicio;
	}

	public LocalDateTime getFim() {
		return fim;
	}

	public void setFim(LocalDateTime fim) {
		this.fim = fim;
	}

	public Veiculo getVeiculo() {
		return veiculo;
	}

	public void setVeiculo(Veiculo veiculo) {
		this.veiculo = veiculo;
	}

	public Fatura getFatura() {
		return fatura;
	}

	public void setFatura(Fatura fatura) {
		this.fatura = fatura;
	}

}
package model.services;

public interface ServicoDeImposto {
	
	double imposto(double valor);

}
package model.services;

public class ServicoDeImpostoBrasil implements ServicoDeImposto {

    public double imposto(double valor) {
        // Se o valor for menor ou igual a 100, aplica-se uma taxa de 20%
        if(valor <= 100.0) {
            return valor * 0.20;
        }
        // Caso contrário, aplica-se uma taxa de 15%
        else {
            return valor * 0.15;
        }
    }
}

package model.services;

import java.time.Duration;

public class ServicoDeAluguel {
	
	private Double precoPorHora;
	private Double precoPorDia;
	
	private ServicoDeImposto servicoDeImposto;//Composição de objetos
	
	/*
	 * Não foi inserido o construtor sem argumentos porque
	 * é importante obrigar, ao instanciar o objeto, que se 
	 * informe os argumentos do construtor abaixo
	 */
	
	public ServicoDeAluguel(Double precoPorHora, Double precoPorDia, ServicoDeImposto servicoDeImposto) {
		this.precoPorHora = precoPorHora;
		this.precoPorDia = precoPorDia;
		this.servicoDeImposto = servicoDeImposto;
	}
	
	//Processando a fatura
	public void processaFatura(AluguelDeCarro aluguelDeCarro) {
		
		//Duração de tempo entre duas datas em minutos
		double minutos = Duration.between(aluguelDeCarro.getInicio(), aluguelDeCarro.getFim()).toMinutes();
		//Calculando a fração de hora
		double horas = minutos / 60.0;
		
		//Testando se as horas são maiores ou menores que 12
		double pagamentoBasico;
		if(horas <= 12.0) {
			pagamentoBasico = precoPorHora * Math.ceil(horas);//Math.ceil para arredondar pra cima
		}else {
			pagamentoBasico = precoPorDia * Math.ceil(horas / 24.0);
		}
		
		//Calculando o imposto
		double imposto = servicoDeImposto.imposto(pagamentoBasico);
		
		//Criando a fatura
		aluguelDeCarro.setFatura(new Fatura(pagamentoBasico, imposto));
	}

}
 


===================================================================================================================== 
  Inversão de controle, Injeção de dependência
 
 
 
 
 


===================================================================================================================== 
  Exercício de fixação
 
 
 
 
 
 
package services;

public class ServicoPaypal implements ServicoDePagOnline{
	
	//Hard code de constante para não escrever diretamente no método
	private static final double TAXA_PAGAMENTO = 0.02;
	private static final double JURO_MENSAL = 0.01;
	
	//Implementar métodos com base na regra do Paypal no exercício
	@Override
	public double taxaDePagamento(double valor) {
		return valor * TAXA_PAGAMENTO;
	}

	@Override
	public double juros(double valor, int meses) {
		return valor * JURO_MENSAL * meses;
	}
	
	/*
	 * toda Classe que implementar SevicoDePagOnline será obrigada a
	 * implementar esses dois métodos declarados naquela Classe.
	 */
	/*
	 * ATENÇÃO!!! Observe que as regras de cobrança estão aqui.
	 * Estas regras são assinadas pela Classe ServicoDePagOnline.
	 * A partir dela é que a aplicação vai acessar e solicitar resposta
	 * Inclusive é possível fazer upcasting instanciando ServicoPaypal
	 * como tipo ServicoDePagOnline. Ex.: ServicoDePagOnline  ps = new ServicoPaypal();
	 */
}
package services;

public interface ServicoDePagOnline {
	
	double taxaDePagamento(double valor);//Assinatura do método
	double juros(double valor, int meses);//Assinatura do método
	
	/*
	 * Esta é a declaração da interface que qualquer serviço
	 * de pagamento terá que implementar. É um contrato. Se
	 * a Classe for SevicoDePagOnline, ela será obrigada a
	 * implementar esses dois métodos declarados. 
	 */
}
package services;

import java.util.Calendar;

public class ServicoContrato {
	
	/*
	 * ATENÇÃO!!!
	 * Precisamos ter cuidado para não haver autoacoplamento dentro da Classe.
	 * Por isso, é necessário haver uma injeção de dependência ou inversão
	 * de controle. Pode ser feita via framework ou mesmo no braço por meio 
	 * de construtor. 
	 * O princípio é: A classe deve estar aberta para extensão, mas fechada 
	 * alteração.
	 * Inversão de controle é vc não deixar a Classe responsável por qual
	 * instância ela vai precisar para executar. Esse controle vai para outro
	 * lugar. Um agente externo entragará esta instância para a Classe.
	 * O ato de fornecer a instância para esta classe é chamado de injeção de 
	 * dependência
	 */
	
	private ServicoDePagOnline servicoDePagOnline;
	
	public ServicoContrato(ServicoDePagOnline servicoDePagOnline) {
		this.servicoDePagOnline = servicoDePagOnline;
	}
	
	//Método responsável por calcular as parcelas
	public void processaContrato(Contrato contrato, int meses) {
		
		double parcelaBasica = contrato.getValorTotal() / meses;
		for(int i = 1; i <= meses; i++) {
			double taxaAtualizada = parcelaBasica + servicoDePagOnline.juros(parcelaBasica, i);
			double taxaCheia = taxaAtualizada + servicoDePagOnline.taxaDePagamento(taxaAtualizada);
			/*
			 * Usando a função auxiliar para acrescentar i meses
			 * à data do contrato
			 */
			Date dataVencimento = addMeses(contrato.getData(), i);	
			contrato.getParcelas().add(new Parcelas(dataVencimento, taxaCheia));
		}		
	}
	
	//Função auxiliar para acrescentar meses a uma data
	private Date addMeses(Date data, int N) {
		Calendar calendario = Calendar.getInstance();
		calendario.setTime(data);
		calendario.add(Calendar.MONTH, N);
		return calendario.getTime();
	}
}
package entities;

import java.text.SimpleDateFormat;
import java.util.Date;

public class Parcelas {
	
	private static SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	
	private Date dataDeVencimento;
	private Double valor;
	
	public Parcelas() {
	}

	public Parcelas(Date dataDeVencimento, Double valor) {
		super();
		this.dataDeVencimento = dataDeVencimento;
		this.valor = valor;
	}

	public Date getDataDeVencimento() {
		return dataDeVencimento;
	}

	public void setDataDeVencimento(Date dataDeVencimento) {
		this.dataDeVencimento = dataDeVencimento;
	}

	public Double getValor() {
		return valor;
	}

	public void setValor(Double valor) {
		this.valor = valor;
	}

	@Override
	public String toString() {
		return sdf.format(dataDeVencimento) + " - " + String.format("%.2f", valor);
	}
	
	
}
package entities;

import java.util.ArrayList;

public class Contrato {
	
	private Integer numero;
	private Date data;
	private Double valorTotal;
	
	/*
	 * No diagrama, existe relação entre Contrato e Parcelas
	 * Cada contrato pode ter várias parcelas. Por isso
	 * instancia-se a lista tipo Parcelas
	 */
	List<Parcelas> parcelas = new ArrayList<Parcelas>();	
	
	public Contrato(){
	}

	public Contrato(Integer numero, Date data, Double valorTotal) {
		this.numero = numero;
		this.data = data;
		this.valorTotal = valorTotal;
	}

	public Integer getNumero() {
		return numero;
	}

	public void setNumero(Integer numero) {
		this.numero = numero;
	}

	public Date getData() {
		return data;
	}

	public void setData(Date data) {
		this.data = data;
	}

	public Double getValorTotal() {
		return valorTotal;
	}

	public void setValorTotal(Double valorTotal) {
		this.valorTotal = valorTotal;
	}

	public List<Parcelas> getParcelas() {
		return parcelas;
	}
	/*
	 * No caso de lista/coleções, retira-se o método set
	 * pois não faz sentido trocar "setar" a minha lista por outra
	 * Deixa-se somente o método get
	 */
	
	/*
	 * ServicoDeContrato tem o método para implementar o contrato. 
	 * O papel desse método é gerar as parcelas. Porém, o exercício
	 * fala que devemos implementar um serviço de pagamento online, que,
	 * por enquanto, é o Paypal. Observe o "por enquanto": significa que
	 * as regras desse serviço pode mudar. A empresa de serviço pode mudar...
	 * Podem ser acrescentadas novas regras ao serviço de contrato.
	 * Por isso, ServicoDeContrato não terá ligação direta com ServicoPaypal
	 * ServicoDeContrato vai ter uma dependência com uma inteface
	 * ServicoDePagOnline, que vai, ela sim, definir as operações, vai
	 * apenas assinar as operações.
	 * PROJETE PARA INTERFACE, NÃO PROJETE PARA IMPLEMENTAÇÃO.
	 * 
	 */
}
package application;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.Scanner;

import entities.Contrato;
import entities.Parcelas;
import services.ServicoContrato;
import services.ServicoPaypal;

public class Programa {

	public static void main(String[] args) throws ParseException {
		
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
		
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Entre com os dados do contrato");
		System.out.println("Número: ");
		Integer numero = sc.nextInt(); 
		System.out.print("Data (dd/MM/yyyy): ");
		Date data = sdf.parse(sc.next());
		System.out.print("Valor do contrato: ");
		Double valorTotal = sc.nextDouble();
		
		//Instanciando um novo contrato
		Contrato contrato = new Contrato(numero, data, valorTotal);
		
		System.out.print("Entre com o número de parcelas: ");
		int N = sc.nextInt();
		
		//Criando um novo serviço de contrato com injeção de dependência
		ServicoContrato cs = new ServicoContrato(new ServicoPaypal());
		
		cs.processaContrato(contrato, N);
		
		System.out.println();
		System.out.println("Parcelas:");
		for(Parcelas pr : contrato.getParcelas()) {
			System.out.println(pr);
		}	
		sc.close();
	}
}
 


===================================================================================================================== 
  Herdar vs. cumprir contrato
 
 
 
 


===================================================================================================================== 
  Solução com apenas a Classe abstrata
package model.entities;

import model.enums.Cor;

public class Circulo extends Forma {

	private Double radius;
	
	/*
	 * Construtor com argumento Tipo Cor herdado
	 * da superclasse Forma
	 */
	public Circulo(Cor cor, Double radius) {
		super(cor);
		this.radius = radius;
	}

	public Double getRadius() {
		return radius;
	}

	public void setRadius(Double radius) {
		this.radius = radius;
	}
	
	/*
	 * Método herdado da Classe Forma, com @override para
	 * garantir o polimorfismo do método.
	 */
	/*
	 * Por estender Forma, esta classe pode entregar o
	 * método setColor para a classe principal. 
	 */
	@Override
	public double area() {
		return Math.PI * radius * radius;
	}
}
package model.entities;

import model.enums.Cor;

public class Retangulo extends Forma {
	
	//Atributos da Classe
	private Double width;
	private Double height;
	
	//Construtor com argumento Cor herdado da superclasse
	public Retangulo(Cor cor, Double width, Double height) {
		super(cor);//Enviando argumento cor para superclasse
		this.width = width;
		this.height = height;
	}

	public Double getWidth() {
		return width;
	}

	public void setWidth(Double width) {
		this.width = width;
	}

	public Double getHeight() {
		return height;
	}

	public void setHeight(Double height) {
		this.height = height;
	}
	
	/*
	 * Por estender Forma, esta classe pode entregar o
	 * método setColor para a classe principal. 
	 */

	@Override
	public double area() {
		return width * height;
	}
}
package model.entities;

import model.enums.Cor;

//Classe abstrata 
public abstract class Forma {
	
	//Atributo tipo Enum tipo Cor
	private Cor cor;

	public Forma(Cor cor) {
		this.cor = cor;
	}

	public Cor getColor() {
		return cor;
	}

	public void setColor(Cor cor) {
		this.cor = cor;
	}
	
	/*
	 * Método abstrato, que será herdado pelas Classes concretas 
	 * que estenderem a Classe Forma 
	 */
	public abstract double area();
}
package model.enums;

public enum Color {
	BLACK,
	WHITE;
}
package application;

import model.entities.Circulo;
import model.entities.Forma;
import model.entities.Retangulo;
import model.enums.Cor;

public class Program {

	public static void main(String[] args) {
		
		Forma s1 = new Circulo(Cor.BLACK, 2.0);
		Forma s2 = new Retangulo(Cor.WHITE, 3.0, 4.0);
		
		System.out.println("Circle color: " + s1.getColor());
		System.out.println("Circle area: " + String.format("%.3f", s1.area()));
		System.out.println("Rectangle color: " + s2.getColor());
		System.out.println("Rectangle area: " + String.format("%.3f", s2.area()));
	}
}
 


===================================================================================================================== 
  Solução com interface e Classe abstrata
package model.entities;

import model.enums.Cor;

/*
 * Combinação de interface com Classe abstrata para permitir
 * o reuso de cor. Com implements Forma, esta classe obriga
 * as subclasses a implementarem o método área.
 */
public abstract class FormaAbstrata implements Forma {

	private Cor cor;

	public FormaAbstrata(Cor cor) {
		this.cor = cor;
	}

	public Cor getColor() {
		return cor;
	}

	public void setColor(Cor cor) {
		this.cor = cor;
	}
	
	/*
	 * Interface não pode ter atributos, por isso, 
	 * para que seja permitido o reuso de cor,
	 * foi preciso criar esta classe abstrata
	 * com atributo cor, que será herdado pelas
	 * Classes concretas 
	 */
}
package model.entities;

import model.enums.Cor;

/*
 * Ao estender FormaAbstrata, esta Classe herda não só 
 * o atributo cor, mas o método área, que precisa ser 
 * implementado
 */
public class Circulo extends FormaAbstrata {

	private Double radius;

	public Circulo(Cor cor, Double radius) {
		super(cor);//Enviando para a superclasse.
		this.radius = radius;
	}

	public Double getRadius() {
		return radius;
	}

	public void setRadius(Double radius) {
		this.radius = radius;
	}

	//Método área implementado da Superclasse
	@Override
	public double area() {
		return Math.PI * radius * radius;
	}
}
package model.entities;

import model.enums.Cor;

/*
 * Ao estender FormaAbstrata, esta Classe herda não só 
 * o atributo cor, mas o método área, que precisa ser 
 * implementado
 */
public class Retangulo extends FormaAbstrata {

	private Double width;
	private Double height;

	public Retangulo(Cor cor, Double width, Double height) {
		super(cor);
		this.width = width;
		this.height = height;
	}

	public Double getWidth() {
		return width;
	}

	public void setWidth(Double width) {
		this.width = width;
	}

	public Double getHeight() {
		return height;
	}

	public void setHeight(Double height) {
		this.height = height;
	}

	//Método área implementado da Superclasse
	@Override
	public double area() {
		return width * height;
	}
}
package model.entities;

//Interface que define a operação área.
public interface Forma {	
	double area();
}
package application;

import java.awt.Color;

import model.entities.Circulo; // importa a classe Circulo
import model.entities.FormaAbstrata; // importa a classe FormaAbstrata
import model.entities.Retangulo; // importa a classe Retangulo
import model.enums.Cor; // importa o enum Cor

public class Program {

    public static void main(String[] args) {

        // Cria uma instância de Circulo
        FormaAbstrata s1 = new Circulo(Cor.BLACK, 2.0);
        
        // Cria uma instância de Retangulo
        FormaAbstrata s2 = new Retangulo(Cor.WHITE, 3.0, 4.0);
        
        // Imprime a cor do círculo
        System.out.println("Circle color: " + s1.getColor());
        
        // Imprime a área do círculo
        System.out.println("Circle area: " + String.format("%.3f", s1.area()));
        
        // Imprime a cor do retângulo
        System.out.println("Rectangle color: " + s2.getColor());
        
        // Imprime a área do retângulo
        System.out.println("Rectangle area: " + String.format("%.3f", s2.area()));
    }
}

https://www.udemy.com/course/java-curso-completo/learn/lecture/10852496


===================================================================================================================== 
overview
 


===================================================================================================================== 
  Herança múltipla e o problema do diamante
 
package devices;

// Superclasse dispositivo
public abstract class Device {

    // Atributo que armazena o número de série do dispositivo
    public String serialNumber;

    // Construtor que inicializa o número de série do dispositivo
    public Device(String serialNumber) {
        this.serialNumber = serialNumber;
    }
    
    // Método que retorna o número de série do dispositivo
    public String getSerialNumber() {
        return serialNumber;
    }

    // Método que atribui um novo número de série para o dispositivo
    public void setSerialNumber(String serialNumber) {
        this.serialNumber = serialNumber;
    }

    // Método abstrato que processa um documento
    public abstract void processDoc(String doc);
}

package devices;

// Impressora é uma subclasse de Device, por isso estende Device
public class Printer extends Device {

    // Construtor que recebe um número de série como parâmetro e o passa para o construtor da classe pai Device
	public Printer(String serialNumber) {
		super(serialNumber);
	}

	// Sobrescreve o método processDoc herdado de Device
	@Override
	public void processDoc(String doc) {
		System.out.println("Printer processing: " + doc);
	}

    // Método que imprime uma string dizendo "Printing: " seguida do parâmetro doc passado
	public void print(String doc) {
		System.out.println("Printing: " + doc);
	}
}

package devices;

// Scanner é uma subclasse de Device, por isso estende Device
public class Scanner extends Device {

    // Construtor que recebe um número de série como parâmetro e o passa para o construtor da classe pai Device
	public Scanner(String serialNumber) {
		super(serialNumber);
	}

	// Sobrescreve o método processDoc herdado de Device
	@Override
	public void processDoc(String doc) {
		System.out.println("Scanner processing: " + doc);
	}

    // Método que retorna uma string "Scanned content"
	public String scan() {
		return "Scanned content";
	}
}
package application;

import devices.Printer;
import devices.Scanner;

public class Program {

// Método principal que é executado quando o programa é iniciado
public static void main(String[] args) {

	// Criando um novo objeto Printer com o número de modelo "1080"
	Printer p = new Printer("1080");
	
	// Processando o documento "My Letter"
	p.processDoc("My Letter");
	
	// Imprimindo o documento "My Letter"
	p.print("My Letter");
	
	// Criando um novo objeto Scanner com o número de modelo "2003"
	Scanner s = new Scanner("2003");
	
	// Processando o documento "My Email"
	s.processDoc("My Email");
	
	// Escaneando o documento e imprimindo o resultado
	System.out.println("Resultado do escaneamento: " + s.scan());
}

}
 
package devices;

//Estende Device e implementa Scanner e Printer
public class ComboDevice extends Device implements Scanner, Printer {

	public ComboDevice(String serialNumber) {
		super(serialNumber);//Encaminhando para a superclasse
	}

	@Override
	public void print(String doc) {
		System.out.println("Combo printing: " + doc);
	}

	@Override
	public String scan() {
		return "Combo scan result";
	}

	@Override
	public void processDoc(String doc) {
		System.out.println("Combo processing: " + doc);
	}
	
	/*
	 * Devido à implementação dos métodos print e scan em
	 * intefaces, agora podemos contruir a lógica do 
	 * dispositivo multifuncional. Pois esta Classe pode
	 * herdar da Superclasse e implementar os contratos 
	 * das interfaces, sem que haja herança múltipla.
	 */
}
package devices;

//Estende Device e implementa Printer
public class ConcretePrinter extends Device implements Printer {

	public ConcretePrinter(String serialNumber) {
		super(serialNumber);
	}

	//Método herdado de Device
	@Override
	public void processDoc(String doc) {
		System.out.println("Printer processing: " + doc);
	}

	//Método implementado de Printer
	@Override
	public void print(String doc) {
		System.out.println("Printing: " + doc);
	}
}
package devices;

//Estende Device e implementa Scanner
public class ConcreteScanner extends Device implements Scanner {

	public ConcreteScanner(String serialNumber) {
		super(serialNumber);//Enviando para a superclasse
	}

	//Método herdado de Device
	@Override
	public void processDoc(String doc) {
		System.out.println("Scanner processing: " + doc);
	}
	
	//Método implementado de Scanner
	@Override
	public String scan() {
		return "Scanned content";
	}
}
package devices;

//Classe abstrata/mãe com atributo que é recebido das subclasses
public abstract class Device {

	public String serialNumber;

	//Argumento para o construtor recebido das subclasses
	public Device(String serialNumber) {
		this.serialNumber = serialNumber;
	}

	public String getSerialNumber() {
		return serialNumber;
	}

	public void setSerialNumber(String serialNumber) {
		this.serialNumber = serialNumber;
	}

	/*
	 * Função processDoc declarada para que as subclasses
	 * desta sejam obrigadas a implementar cada qual sua função
	 * para que o polimorfismo seja garantido
	 */
	public abstract void processDoc(String doc);
}
package devices;
//Inteface Printer com a função print declarada
public interface Printer {

	void print(String doc);
}
package devices;
//Inteface Scanner com a função scan declarada
public interface Scanner {

	String scan();
}
package application;

import devices.ComboDevice;
import devices.ConcretePrinter;
import devices.ConcreteScanner;

public class Program {

	public static void main(String[] args) {
		System.out.println("IMPRESSORA:");
		ConcretePrinter p = new ConcretePrinter("1080");
		p.processDoc("Documento processado na impressora");
		p.print("Documento impresso");
		System.out.println("SCANNER:");
		ConcreteScanner s = new ConcreteScanner("2003");
		s.processDoc("Documento processado no scanner");
		System.out.println("Documento escaneado: " + s.scan());
		System.out.println("MULTIFUNCIONAL");
		ComboDevice cd = new ComboDevice("3080");
		cd.processDoc("Documento processado na multifuncional");
		cd.print("Documento impresso na multifuncional");
		System.out.println("Documento escaneado na multifuncional: " + s.scan());
	}
}
https://www.udemy.com/course/java-curso-completo/learn/lecture/10852498?start=540


===================================================================================================================== 
overview
 


===================================================================================================================== 
  Interface Comparable
 
 
package application;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Program {
    public static void main(String[] args) {
        // Cria uma lista vazia
        List<String> list = new ArrayList<>();
        // Armazena o caminho do arquivo
        String path = "/home/ivan_carlos/Documentos/Cursos Online/Curso Java/input.csv";
        try (BufferedReader br = new BufferedReader(new FileReader(path))) {
            // Lê a primeira linha do arquivo
            String name = br.readLine();
            // Enquanto houver linhas para serem lidas
            while (name != null) {
                // Adiciona a linha lida à lista
                list.add(name);
                // Lê a próxima linha
                name = br.readLine();
            }
            // Ordena a lista
            Collections.sort(list);
            // Imprime cada elemento da lista
            for (String s : list) {
                System.out.println(s);
            }
        } catch (IOException e) {
            // Exibe uma mensagem de erro caso ocorra algum problema ao ler o arquivo
            System.out.println("Error: " + e.getMessage());
        }
    }
}

 
package entities;

/*
 * Para ordenar a lista Employee pelo método sort, é necessário que 
 * a Classe Employee implemente a interface Comparable
 */
public class Employee implements Comparable<Employee> {
	private String name;
	private Double salary;

	public Employee(String name, Double salary) {
		this.name = name;
		this.salary = salary;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Double getSalary() {
		return salary;
	}

	public void setSalary(Double salary) {
		this.salary = salary;
	}

	//Método implementado da Classe Comparable
	/*
	 * compareTo - este método serve para comparar um objeto com outro
	 * Quando se define que uma classe é comparável, é necessário dizer
	 * como a comparação será feita. Este método retorna um número negativo,
	 * zero ou um número positivo a depender de se o objeto for menor, igual 
	 * ou maior que o objeto comparado. Se quisermos comparar os salários,
	 * é só substituir name por salary. Se quisermos inverter a onrdem do sort,
	 * é só colocar um - na frente: -name.compareTo(other.getName())
	 */
	@Override
	public int compareTo(Employee other) {
		//Comparando o nome do funcionário com o nome de outro funcionário
		return name.compareTo(other.getName());
	}
}
package application;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import entities.Employee;

public class Program {
	public static void main(String[] args) {
		// Instanciando lista de Strings
		List<Employee> list = new ArrayList<>();
		// Definindo o caminho do arquivo
		String path = "/home/ivan_carlos/Documentos/Cursos Online/Curso Java/input.csv";

		// Instanciando BufferedReader dentro de um bloco try
		try (BufferedReader br = new BufferedReader(new FileReader(path))) {
			String employeeCsv = br.readLine();

			// Enquanto a linha for diferente de null, adiciona o valor e lê a próxima linha
			while (employeeCsv != null) {
				/*
				 * pegando a linha do CSV e recortando em 2 criando vetor de Strings onde cada
				 * posição será um campo. A posição zero será o nome, e a posição 1 será o salário
				 */

				String[] fields = employeeCsv.split(",");
				/*
				 * Depois de recortada a linha em duas posições, passa as posições 0 e 1 da
				 * linha como argumentos do construtor da Classe Employee e adiciona à lista. O
				 * construtor entenderá pela posição de cada argumento.
				 */
				list.add(new Employee(fields[0], Double.parseDouble(fields[1])));
				employeeCsv = br.readLine();
			}

			// Operação padrão da Classe nativa Collections
			Collections.sort(list);

			// Percorre a lista e imprime cada um dos elementos
			for (Employee emp : list) {
				System.out.println(emp.getName() + ", " + emp.getSalary());
			}

			// Se employeeCsv retornar null
		} catch (IOException e) {
			System.out.println("Error: " + e.getMessage());
		}
	}
}
 


===================================================================================================================== 
  Default methods
 
 
 
 
 
 
 


===================================================================================================================== 
  Implementação sem default
package services;

import java.security.InvalidParameterException;

// Classe BrazilInterestService é responsável por calcular o pagamento de juros em empréstimos
public class BrazilInterestService {

    // Atributo privado para armazenar a taxa de juros
    private double interestRate;

    // Construtor para inicializar o atributo "interestRate" com o valor passado como parâmetro
    public BrazilInterestService(double interestRate) {
        this.interestRate = interestRate;
    }

    // Método para obter o valor do atributo "interestRate"
    public double getInterestRate() {
        return interestRate;
    }
    
    // Método para calcular o pagamento de juros
    public double payment(double amount, int months) {
        // Valida se o número de meses é maior que zero
        if (months < 1) {
            throw new InvalidParameterException("Months must be greater than zero");
        }
        // Calcula o pagamento de juros usando a fórmula amount * (1 + interestRate / 100)^months
        return amount * Math.pow(1.0 + interestRate / 100.0, months);
    }
}

package application;

import java.util.Locale;
import java.util.Scanner;

import services.BrazilInterestService;

public class Program {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		
		System.out.print("Amount: ");
		double amount = sc.nextDouble();
		System.out.print("Months: ");
		int months = sc.nextInt();
		
		BrazilInterestService is = new BrazilInterestService(2.0);
		double payment = is.payment(amount, months);
		
		System.out.println("Payment after " + months + " months:");
		System.out.println(String.format("%.2f", payment));
		
		sc.close();
	}

	//PERGUNTA: E se existir um serviço de juros de outro país. Por exemplo: UsaInterestService com juros de 1%?
	//ele precisará ter interestRate e payment também. Observe que payment existe tanto em
	//BrazilInterestService quanto em UsaInterestService. Haverá uma repetição de código nas duas classes
	//Para não haver repetição e permitir que a aplicação tenha polimorfimso, precisaremos criar uma interface
	//A interface será InterestService e terá duas operações: getInterestRate, para devolver a taxa de juros.
	//e payment, que retorna a quantia que será paga depois de uma quantidade de meses 
	// e será herdada nas nas classes BrazilInterestService e UsaInterestService. 
}
 


===================================================================================================================== 
  Implementação com Default methods
package services;

import java.security.InvalidParameterException;

public interface ServDeJuros {

	double getInterestRate();
	
	/*
	 * Método default para não ser preciso repeti-lo nas Classes filhas
	 * Dessa forma, o compilador entende que este método é padrão 
	 * também das classes que implementem esta interface
	 */
	default double payment(double amount, int months) {
		if (months < 1) {
			throw new InvalidParameterException("Months must be greater than zero");
		}
		/*
		 * Atenção!!! Foi preciso pegar o valor pelo getInterestRate.
		 * Pois é ele que está declarado aqui na interface
		 */
		return amount * Math.pow(1.0 + getInterestRate() / 100.0, months);
	}
	
	/*
	 * Feita a implementação do método de pagamento, as classes
	 * que implementarem esta interface não precisarão sequer
	 * falar sobre este método. A própria linguagem já entende 
	 * que a classe que implementa esta interface também implementa
	 * a função padrão - default.
	 */
}
package services;

public class ServDeJurosBrasil implements ServDeJuros {

	private double interestRate;

	public ServDeJurosBrasil(double interestRate) {
		this.interestRate = interestRate;
	}
	
	/*
	 * Este método não pode ser padrão, porque depende
	 * de variável que está aqui no serviço, e, também, 
	 * porque interface não pode ter construtor nem atributo
	 */
	@Override
	public double getInterestRate() {
		return interestRate;
	}
}
package services;

public class ServDeJurosUsa implements ServDeJuros {

	private double interestRate;

	public ServDeJurosUsa(double interestRate) {
		this.interestRate = interestRate;
	}
	
	/*
	 * Este método não pode ser padrão, porque depende
	 * de variável que está aqui no serviço, e, também, 
	 * porque interface não pode ter construtor nem atributo
	 */
	@Override
	public double getInterestRate() {
		return interestRate;
	}
}
package application;

import java.util.Locale;
import java.util.Scanner;

import services.ServDeJuros;
import services.ServDeJurosBrasil;

public class Program {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);

		System.out.print("Valor: ");
		double amount = sc.nextDouble();
		System.out.print("Meses: ");
		int months = sc.nextInt();
		
		//Variável do tipo InterestService, mas instanciada com Classe específica.
		ServDeJuros sjb = new ServDeJurosBrasil(2.0);
		double payment = sjb.payment(amount, months);

		System.out.println("Payment after " + months + " months:");
		System.out.println(String.format("%.2f", payment));

		sc.close();
	}
}
 


===================================================================================================================== 
  Introdução aos Generics
 
 
package services;

import java.util.ArrayList;
import java.util.List;

public class PrintService {

	private List<Integer> list = new ArrayList<>();

	public void addValue(Integer value) {
		list.add(value);
	}

	public Integer first() {
		if (list.isEmpty()) {
			throw new IllegalStateException("List is empty");
		}
		return list.get(0);
	}

	public void print() {
		System.out.print("[");
		if (!list.isEmpty()) {
			System.out.print(list.get(0));
		}
		for (int i = 1; i < list.size(); i++) {
			System.out.print(", " + list.get(i));
		}
		System.out.println("]");
	}
	/*
	 * ATENÇÃO!
	 * Observe que esta classe só funciona para tipos inteiros
	 * Mas e se eu quiser, em vez de digitar números, digitar 
	 * momes de pessoas? Veja que a lista retorna inteiro, que 
	 * o método first trabalha com inteiro...
	 * Da forma como está, seria necessário criar uma nova Classe
	 * para receber e trabalhar com string.
	 */
}
package application;

import java.util.Scanner;
import services.PrintService;

public class Program {

    public static void main(String[] args) {
        // Cria um objeto Scanner para ler a entrada do teclado
        Scanner sc = new Scanner(System.in);
        
        // Cria um objeto PrintService
        PrintService ps = new PrintService();
        
        // Pede ao usuário quantos valores serão lidos
        System.out.print("How many values? ");
        int n = sc.nextInt();
        
        // Lê n valores do teclado
        for (int i = 0; i < n; i++) {
            int value = sc.nextInt();
            // Adiciona cada valor lido ao objeto PrintService
            ps.addValue(value);
        }

        // Chama o método print() do objeto PrintService
        ps.print();
        // Imprime o primeiro valor armazenado
        System.out.println("First: " + ps.first());
        
        // Fecha o objeto Scanner
        sc.close();

 
package services;

import java.util.ArrayList;
import java.util.List;

public class PrintService {
	
	/*
	 * Solução com Object. Em Java tudo é object. Então esta lista
	 * em tese aceitará números e strings.
	 * Porém esta não é a melhor solução.
	 */
	private List<Object> list = new ArrayList<>();

	public void addValue(Object value) {
		list.add(value);
	}

	public Object first() {
		if (list.isEmpty()) {
			throw new IllegalStateException("List is empty");
		}
		return list.get(0);
	}

	public void print() {
		System.out.print("[");
		if (!list.isEmpty()) {
			System.out.print(list.get(0));
		}
		for (int i = 1; i < list.size(); i++) {
			System.out.print(", " + list.get(i));
		}
		System.out.println("]");
	}
}
package application;

import java.util.Scanner;

import services.PrintService;

public class Program {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);

		PrintService ps = new PrintService();
		
		System.out.print("How many values? ");
		int n = sc.nextInt();
		
		//Adicionando à minha lista o nome MARIA
		ps.addValue("MARIA");
		
		for (int i = 0; i < n; i++) {
			Integer value = sc.nextInt();
			ps.addValue(value);
		}

		ps.print();
		
		/*
		 * Observe que há um problema de performance, pois foi necessaŕio
		 * fazer um casting. Se fosse tipo primitivo, seria necessário fazer
		 * boxing e unboxing
		 */
		Integer x = (Integer) ps.first();
		System.out.println("First: " + x);
		
		sc.close();
	}
	/*
	 * Dessa forma, ao digitar os números o programa vai apresentar
	 * a exceção declarando que não tem como transformar MARIA para
	 * inteiro.
	 * Temos assim um problema se segurança de tipos
	 */
}
 
package services;

import java.util.ArrayList;
import java.util.List;

public class PrintService<T> {

	/*
	 * Generics parametrizado com um tipo T. Esse tipo T pode
	 * ser um tipo qualquer: pode ser string, inteiro, enfim...
	 * Este tipo T vai garantir o reuso, ms também vai garantir
	 * o type sefety - só vai aceitar o tipo para o qual foi instanciado.
	 */
	private List<T> list = new ArrayList<>();

	public void addValue(T value) {
		list.add(value);
	}

	public T first() {
		if (list.isEmpty()) {
			throw new IllegalStateException("List is empty");
		}
		return list.get(0);
	}

	public void print() {
		System.out.print("[");
		if (!list.isEmpty()) {
			System.out.print(list.get(0));
		}
		for (int i = 1; i < list.size(); i++) {
			System.out.print(", " + list.get(i));
		}
		System.out.println("]");
	}
}

package application;

import java.util.Scanner;

import services.PrintService;

public class Program {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);

		PrintService<Integer> ps = new PrintService<>();
		
		System.out.print("How many values? ");
		int n = sc.nextInt();
		
		for (int i = 0; i < n; i++) {
			Integer value = sc.nextInt();
			ps.addValue(value);
		}

		ps.print();
		Integer x = ps.first();
		System.out.println("First: " + x);
		
		sc.close();
	}
	/*
	 * Com a lista do tipo T - generics - criada na Classe PrintService,
	 * não é mais necessário o casting e ainda fica garantido o type safety
	 */
}
 


===================================================================================================================== 
  Genéricos delimitados
 
 


===================================================================================================================== 
  Implementação inicial
package services;

import java.util.List;

public class CalculationService {

	//Recebe um lista de inteiros
	public static Integer max(List<Integer> list) {
		//Programação defensiva para verificar se a lista está vazia
		if (list.isEmpty()) {
			throw new IllegalStateException("List can't be empty");
		}
		
		//Encontra o maior elemento de uma lista
		Integer max = list.get(0);
		for (Integer item : list) {
			//Se o elemento item for maior que max e ainda maior que zero, atualiza max
			if (item.compareTo(max) > 0) {
				max = item;
			}
		}
		//Retorna o maior elemento da lista
		return max;
	}
	
	/*
	 * Oberserve que o método encontra o maior em uma lista de inteiros
	 * Porém, queremos que ele encontre o maior em uma lista de produtos
	 * Então eu vou precisar adaptar meu programa para trabalhar com uma lista 
	 * de produtos
	 */
}
package entities;

// Classe Product representa um produto com nome e preço
public class Product {

    // Atributo privado para armazenar o nome do produto
    private String name;
    // Atributo privado para armazenar o preço do produto
    private Double price;
    
    // Construtor para inicializar os atributos "name" e "price" com os valores passados como parâmetros
    public Product(String name, Double price) {
        this.name = name;
        this.price = price;
    }

    // Método para obter o valor do atributo "name"
    public String getName() {
        return name;
    }

    // Método para atribuir um valor ao atributo "name"
    public void setName(String name) {
        this.name = name;
    }

    // Método para obter o valor do atributo "price"
    public Double getPrice() {
        return price;
    }

    // Método para atribuir um valor ao atributo "price"
    public void setPrice(Double price) {
        this.price = price;
    }

    // Sobrescrevendo o método toString()
    @Override
    public String toString() {
        // Retorna uma string com o nome e preço do produto formatado para duas casas decimais
        return name + ", " + String.format("%.2f", price);
    }
}

package application;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import services.CalculationService;

public class Program {

	public static void main(String[] args) {

		List<Integer> list = new ArrayList<>();

		String path = "/home/ivan_carlos/Documentos/Cursos Online/Curso Java/in.txt";

		try (BufferedReader br = new BufferedReader(new FileReader(path))) {
			
			//Abre o arquivo
			String line = br.readLine();
			//Lê todos os elementos e insere na lista
			while (line != null) {
				list.add(Integer.parseInt(line));
				line = br.readLine();
			}
			
			Integer x = CalculationService.max(list);
			System.out.println("Max:");
			System.out.println(x);

		} catch (IOException e) {
			System.out.println("Error: " + e.getMessage());
		}
	}
}
 


===================================================================================================================== 
  Adaptado para trabalhar com lista de produtos
package services;

import java.util.List;

public class CalculationService {

	/*
	 * Precisa especificar que o tipo T do método é um tipo Comparable
	 * Assim, este método trabalhará com qualquer tipo T, desde que ele seja 
	 * qualquer subtipo de comparable T. 
	 * T extends Comparable<? super T> - tipo comparável T ou qualquer 
	 * superclasse de T
	 */
	public static <T extends Comparable<? super T>> T max(List<T> list) {
		if (list.isEmpty()) {
			throw new IllegalStateException("List can't be empty");
		} 
		//Pega o primeiro elemento da lista
		T max = list.get(0);
		//Percorre os elementos da lista
		for (T item : list) {
			//Compara o elemento item com o max
			if (item.compareTo(max) > 0) {
				//Renova max
				max = item;
			}
		}
		//Retorna max
		return max;
	}
	//OBSERVE QUE AGORA O MÉTODO ESTÁ GENÉRICO
}
package entities;

public class Product implements Comparable<Product> {

	private String name;
	private Double price;
	
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Double getPrice() {
		return price;
	}

	public void setPrice(Double price) {
		this.price = price;
	}

	@Override
	public String toString() {
		return name + ", " + String.format("%.2f", price);
	}

	
	@Override
	public int compareTo(Product other) {
		return price.compareTo(other.getPrice());
	}
	/*
	 * Compara este preço de um produto que está na classe 
	 * com outro preço que vem como argumento.
	 */
}
package application;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import entities.Product;
import services.CalculationService;

public class Program {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		
		List<Product> list = new ArrayList<>();

		String path = "/home/ivan_carlos/Documentos/Cursos Online/Curso Java/in.txt";

		try (BufferedReader br = new BufferedReader(new FileReader(path))) {

			String line = br.readLine();
			while (line != null) {
				
				//Criando um vetor de string para receber os elementos cortados
				String[] fields = line.split(",");
				//Inserindo os elementos na lista na posição 0 e 1
				list.add(new Product(fields[0], Double.parseDouble(fields[1])));
				line = br.readLine();
			}
			
			Product x = CalculationService.max(list);
			System.out.println("Most expensive:");
			System.out.println(x);

		} catch (IOException e) {
			System.out.println("Error: " + e.getMessage());
		} 
	}
}
 
 


===================================================================================================================== 
  Tipos curinga (wildcard types)
 
 
package application;

import java.util.Arrays;
import java.util.List;

public class Program {
	public static void main(String[] args) {
		//Instancia uma lista de inteiros
		List<Integer> myInts = Arrays.asList(5, 2, 10);
		//Chamada da função imprime elementos da lista
		printList(myInts);
		
		//Chamada da função imprime elementos da lista
		List<String> myStrs = Arrays.asList("MARIA", "ALEX", "BOB");
		printList(myStrs);
	}
	
	/*
	 * Observe que a função printList imprime pode ser chamada 
	 * para imprimir qualquer tipo de lista. Isso só ocorre 
	 * porque a função tem como argumento uma lista tipo coringa: List<?>
	 */

	/*
	 * Este é o supertipo de qualquer tipo de lista List<?>
	 * Com tipos curinga, podemos fazer métodos que imprimem 
	 * listas de qualquer tipo
	 */
	//Recebe listas de qualquer tipo e as imprime.
	public static void printList(List<?> list) {
		for (Object obj : list) {
			System.out.println(obj);
		}
	}
	/*
	 * Generics são invariantes: o tipo list<Object> não é o supertipo
	 * de qualquer tipo de lista. Uma lista de Integer - list<Integer> -
	 * não é subtipo de uma lista de Object list<Object>. Integer é subtipo
	 * de Object mas a lista de Integer não é subtipo da lista de Object.
	 * Dessa forma, nã dá para fazer upcasting.
	 */
}
 
package application;

import java.util.ArrayList;
import java.util.List;

public class Program {
    public static void main(String[] args) {
        // Cria uma lista com o tipo genérico "?"
        List<?> list = new ArrayList<Integer>();
        
        // Tentando adicionar um elemento à lista
        // Isso gera um erro de compilação, pois o tipo genérico "?" não permite adicionar elementos
        list.add(3); 
    }
}
 


===================================================================================================================== 
  Curingas delimitados (bounded wildcards)
 


===================================================================================================================== 
  Problema 1
 
package entities;

// Interface Shape declara um método para calcular a área de uma forma geométrica.
public interface Shape {

    // Declaração do método area() sem implementação.
    double area();
}

package entities;

// A classe Rectangle implementa a interface Shape
public class Rectangle implements Shape {

    // Atributo privado para armazenar a largura do retângulo
    private double width;
    // Atributo privado para armazenar a altura do retângulo
    private double height;
    
    // Construtor para inicializar os atributos "width" e "height" com os valores passados como parâmetros
    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }

    // Método para obter o valor do atributo "width"
    public double getWidth() {
        return width;
    }

    // Método para atribuir um valor ao atributo "width"
    public void setWidth(double width) {
        this.width = width;
    }

    // Método para obter o valor do atributo "height"
    public double getHeight() {
        return height;
    }

    // Método para atribuir um valor ao atributo "height"
    public void setHeight(double height) {
        this.height = height;
    }

    // Sobrescrevendo o método area() da interface Shape
    @Override
    public double area() {
        // A fórmula para calcular a área de um retângulo é largura * altura
        return width * height;
    }
}

package entities;

// A classe Circle implementa a interface Shape
public class Circle implements Shape {

    // Atributo privado para armazenar o raio do círculo
    private double radius;

    // Construtor para inicializar o atributo "radius" com o valor passado como parâmetro
    public Circle(double radius) {
        super();
        this.radius = radius;
    }

    // Método para obter o valor do atributo "radius"
    public double getRadius() {
        return radius;
    }

    // Método para atribuir um valor ao atributo "radius"
    public void setRadius(double radius) {
        this.radius = radius;
    }

    // Sobrescrevendo o método area() da interface Shape
    @Override
    public double area() {
        // A fórmula para calcular a área de um círculo é PI * raio^2
        return Math.PI * radius * radius;
    }
}

package application;

import java.util.ArrayList;
import java.util.List;

import entities.Circle;
import entities.Rectangle;
import entities.Shape;

public class Program {

	public static void main(String[] args) {
		
		//Lista Shape
		List<Shape> myShapes = new ArrayList<>();
		myShapes.add(new Rectangle(3.0, 2.0));
		myShapes.add(new Circle(2.0));
		
		//Lista Circle
		List<Circle> myCircles = new ArrayList<>();
		myCircles.add(new Circle(2.0));
		myCircles.add(new Circle(3.0));
		
		/*
		 * Observe que círculo também é uma figura. Porém, se o método
		 * totalArea tivesse como argumento uma List<Shape>, o compilador
		 * ia reclamar. Porque o List<Shape> não é supertipo de List<Circle>
		 * Por isso precisa ser tipo curinga. 
		 */
		
		System.out.println("Total area: " + totalArea(myShapes));
		
		/*
		 * Porém, Observe que não adianta apenas o tipo da lista ser curinga, ela 
		 * precisa estender Shape. List<? extends Shape>. Assim eu digo que minha
		 * lista pode ser Shape ou qualquer tipo que seja subtipode Shape.
		 * Dessa forma, o método também aceitará um lista do tipo Circle
		 */
		
		System.out.println("Total area: " + totalArea(myCircles));
	}
	
	//Método que recebe lista Shape ou qualquer subtipo de Shape
	public static double totalArea(List<? extends Shape> list) {
		double sum = 0.0;
		for (Shape s : list) {
			sum += s.area();
		}
		return sum;
	}
}
 


===================================================================================================================== 
  Problema 2 (princípio get/put)
 
 
 
package application;

import java.util.ArrayList;
import java.util.List;

import entities.Circle;
import entities.Rectangle;
import entities.Shape;

public class Program {

	public static void main(String[] args) {
		
		//Instanciando uma lista de Integer
		List<Integer> intList = new ArrayList<Integer>();
		//Adicionando valores à lista
		intList.add(10);
		intList.add(5);
		
		/*
		 * Criando uma lista de qualquer tipo que seja subtipo de Number
		 * com a variável list recebendo uma lista de Integer.
		 * Eu estou atribuindo uma lista que é mais específica para uma
		 * variável de um tipo mais genérico.
		 */
		
		//Pode acessar os elementos da lista
		List<? extends Number> list = intList;
		Number x = list.get(0);
		/*
		 * Porém não pode adicionar elementos à lista, porque o compilador
		 * não sabe se este número inteiro vai ser compatível com algum
		 * possível tipo Number que possa ser a minha lista.
		 * 
		 * Ou seja, nesse caso, é permitido acessar os elementos mas não
		 * é permitido adicionar elementos à lista.
		 * 
		 * ISSO SE CHAMA COVARIÂNCIA: É quando a operação de get é permitida
		 * mas a operação de inserir não é permitida. 
		 */
		list.add(20); // erro de compilacao
	}

}
 
package application;

import java.util.ArrayList;
import java.util.List;

import entities.Circle;
import entities.Rectangle;
import entities.Shape;

public class Program {

	public static void main(String[] args) {
		//Criando uma lista de Object onde eu posso adicionar elementos de qualquer tipo
		List<Object> myObjs = new ArrayList<Object>();
		
		//Adicoinando elementos à lista
		myObjs.add("Maria");
		myObjs.add("Alex");
		
		/*
		 * Declarando uma lista do tipo qualquer tipo super Number.
		 * Ou seja, pode ser um Number ou qualquer supertipo de Number
		 * Dessa forma, ela pode ser tanto Number quanto Object
		 */
		List<? super Number> myNums = myObjs;
		
		//É permitido adicionar tipo Number ou objetos do supertipo Number: Object
		myNums.add(10);
		myNums.add(3.14);
		
		/*
		 * Porém agora eu não posso acessar os objetos da lista. 
		 * ISSO SE CHAMA CONTRAVARIÂNCIA: Na contravariância, quando você 
		 * define um tipo que pode ser um tipo ou qualquer supertipo dele,
		 * aí você vai ter um erro se você tentar obter um objeto, porém
		 * você pode adicionar.
		 */
		Number x = myNums.get(0); // erro de compilacao
	}
}
 
package application;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Program {

	public static void main(String[] args) {
		List<Integer> myInts = Arrays.asList(1, 2, 3, 4);
		List<Double> myDoubles = Arrays.asList(3.14, 6.28);
		List<Object> myObjs = new ArrayList<Object>();
		copy(myInts, myObjs);
		copy(myDoubles, myObjs);
	}
	
	/*
	 * COMO FICARÁ O MÉTODO COPY?
	 * ESte método vai receber uma lista de números mais específica
	 * Então alista de origem será List<? extends Number>: lista de 
	 * qualquer tipo que extendes Number. A lista de destino vai ser 
	 * uma lista de qualquer tipo que pode ser um supertipo de NUmber
	 * List<? super Number> destiny
	 */
	public static void copy(List<? extends Number> source, List<? super Number> destiny) {
		/*
		 * Para cada number Number na liss5ta de origem,
		 * adiciona number à lista de destino.
		 * A lista de origem é uma caso de Covariância - eu posso acessar os elementos
		 * A lista de destino é um caso de Contravariância - eu posso adicionar elementos
		 */
		for(Number number : source) {
			destiny.add(number);
		}
	}
}
 


===================================================================================================================== 
  hashCode e equals
 
 
 
 
package entities;

import java.util.Objects;

public class Client {
	private String name;
	private String email;
	
	public Client(String name, String email) {
		this.name = name;
		this.email = email;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}
	
	
	/*
	 * hashCode e equals gerado pela IDE.
	 * O que está endo feito é: 
	 * -gera o hasCode dos objetos a serem comparados
	 * -depois é feito o equals com os hashCodes dos objetos
	 * 
	 * ATENÇÃO!
	 * hashCode é muito mais rápido, mas pode haver colisões e 
	 * apresentar falso positivo(muito difícil)
	 * equals é mais lento, porem não erra. Ele acerta 100% das 
	 * comparações
	 */
	@Override
	public int hashCode() {
		return Objects.hash(email, name);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Client other = (Client) obj;
		return Objects.equals(email, other.email) && Objects.equals(name, other.name);
	}
	
}
package application;

import entities.Client;

public class Program {

	public static void main(String[] args) {
		
		//Criando objetos c1 e c2 com nome e email
		Client c1 = new Client("MARIA", "maria @gmail.com");
		Client c2 = new Client("MARIA", "maria @gmail.com");
		
		/*
		 * Criando referências para Strings
		 * Neste caso, o compilador dará um tratamento
		 * diferenciado. Dessa forma, o resultado da comparação
		 * == será true
		 */
		String s1 = "Test";
		String s2 = "Test";
		
		/*
		 * Agora, criando objetos, o compilador vai alocar
		 * cada um em hips diferentes. Dessa forma, ao se comparar
		 * == os elementos, o resultado retornará false.
		 */
		String p1 = new String ("Test");
		String p2 = new String ("Test");
		
		//Imprimindo o hashCode e comparando os objetos
		System.out.println(c1.hashCode());
		System.out.println(c2.hashCode());
		System.out.println(c1.equals(c2));
		
		/*
		 * Observe que o print == não compara números mas
		 * referência de  memória. Dois objetos diferentes foram
		 * armazenados  no hip. Por isso, o resultado
		 * retornou false. Pois os objetos estão armazenados em 
		 * locais diferentes.
		 */
		System.out.println(c1 == c2);
		System.out.println(s1 == s2);
		System.out.println(p1 == p2);
	}
}
 


===================================================================================================================== 
  Set
 
 
 


===================================================================================================================== 
  HashSet
package application;

import java.util.HashSet;

public class Program {
	public static void main(String[] args) {
		
		//Instanciando um hashSet do tipo String
		Set<String> set = new HashSet<>();
		
		//Adicionando elelemtos ao conjunto
		set.add("TV");
		set.add("Tablet");
		set.add("Notebook");
		
		
		//Testando a condição: se no elemento existe Notebook
		System.out.println(set.contains("Notebook"));
		
		//Imprimindo os elementos do conjunto
		for (String p : set) {
			System.out.println(p);
		}
		/*
		 * hashSet é o método mais rápido de todos, porém
		 * ele não garante a ordem.
		 */
	}
}
 


===================================================================================================================== 
  TreeSet
package application;

import java.util.Set;

public class Program {
	public static void main(String[] args) {
		
		//Instanciando um TreeSet do tipo String
		Set<String> set = new TreeSet<>();
		
		//Adicionando elelemtos ao conjunto
		set.add("Tv");
		set.add("Tablet");
		set.add("Notebook");
		
		
		//Testando a condição: se no elemento existe Notebook
		System.out.println(set.contains("Notebook"));
		
		//Imprimindo os elementos do conjunto
		for (String p : set) {
			System.out.println(p);
		}
		/*
		 * TreeSet ordena os dados. Como neste caso o 
		 * conjunto é de String, ele ordenou por String
		 */
	}
}
 


===================================================================================================================== 
  LinkedHashSet
package application;

import java.util.LinkedHashSet;

public class Program {
	public static void main(String[] args) {
		
		//Instanciando um LinkedHashSet do tipo String
		Set<String> set = new LinkedHashSet<>();
		
		//Adicionando elelemtos ao conjunto
		set.add("Tv");
		set.add("Tablet");
		set.add("Notebook");
		
		
		//Testando a condição: se no elemento existe Notebook
		System.out.println(set.contains("Notebook"));
		
		//Imprimindo os elementos do conjunto
		for (String p : set) {
			System.out.println(p);
		}
		/*
		 * LinkedHashSet mantém a ordem em que os elementos
		 * foram inseridos. 
		 */
	}
}
 


===================================================================================================================== 
  Operações com Set
package application;

import java.util.LinkedHashSet;

public class Program {
	public static void main(String[] args) {
		
		//Instanciando um LinkedHashSet do tipo String
		Set<String> set = new LinkedHashSet<>();
		
		//Adicionando elelemtos ao conjunto
		set.add("Tv");
		set.add("Tablet");
		set.add("Notebook");
		
		//EXECUTANDO OPERAÇÕES COM SET
		
		//Removendo elementos:
		set.remove("Tablet");
		
		//Removendo objetos por predicado:
		//x tal que 1ª letra x = a 'T'
		set.removeIf(x -> x.charAt(0) == 'T');
		
		
		//Imprimindo os elementos do conjunto
		for (String p : set) {
			System.out.println(p);
		}
		/*
		 * LinkedHashSet mantém a ordem em que os elementos
		 * foram inseridos. 
		 */
	}
}
 


===================================================================================================================== 
  Operações com conjuntos
package application;

import java.util.Arrays;

public class Program {
	public static void main(String[] args) {
		
		//Criando os conjuntos com TreeSet
		Set<Integer> a = new TreeSet<>(Arrays.asList(0, 2, 4, 5, 6, 8, 10));
		Set<Integer> b = new TreeSet<>(Arrays.asList(5, 6, 7, 8, 9, 10));
		
		//OPERAÇÕES COM CONJUNTOS:
		
		//união dos conjuntos
		//Criando um conjunto c que será uma cópia do conjunto a
		Set<Integer> c = new TreeSet<>(a);
		//juntando conjunto c com b
		c.addAll(b);
		System.out.println(c);

		//intesecção dos conjuntos
		//Criando um conjunto d que será uma cópia do conjunto a
		Set<Integer> d = new TreeSet<>(a);
		//retainAll - somente os elementos em comum nos conjuntos
		d.retainAll(b);
		System.out.println(d);

		//difference
		//Criando um conjunto e que será uma cópia do conjunto a
		Set<Integer> e = new TreeSet<>(a);
		//remove do conjunto e todos que estão no b
		e.removeAll(b);
		System.out.println(e);
	}
}
 


===================================================================================================================== 
  Como o Set testa igualdade?
 
package application;

import java.util.HashSet;
import java.util.Set;

import entities.Product;

public class Program {
	public static void main(String[] args) {
		
		//Criando um conjunto de Product
		Set<Product> set = new HashSet<>();
		
		//Adcionando produtos
		set.add(new Product("TV", 900.0));
		set.add(new Product("Notebook", 1200.0));
		set.add(new Product("Tablet", 400.0));
		
		//Instanciando um novo Produto Notebook, 1200.0
		Product prod = new Product("Notebook", 1200.0);
		
		//Testando se o Produto criado existe no conjunto
		System.out.println(set.contains(prod));
	}
	/*
	 * Se a classe Product não tiver a implementação do 
	 * hashCode / equals, o teste vai retornar false.
	 * Como o Notebook adicionado lá no início e o adicionado
	 * no final estão em instâncias diferentes, por isso o resultado
	 * do teste retorna false.
	 * 
	 * Para comparar um produto por conteúdo: se onome é igual,
	 * se o preço é igual...é preciso implementar as operações
	 * hashCode e equals na classe Product. Assim, a comparação será
	 * feita por conteúdo e não por referência de ponteiro de objeto
	 */
}
 


===================================================================================================================== 
  Como TreeSet compara os elementos?
 
package entities;

import java.util.Objects;

//A interface Product implementa Comparable
/*
 * Esta implementação é necessaŕia pois os elementos 
 * do conjunto são comparados e ordenados. Sem a implementação
 * o programa retorna exception
 */
public class Product implements Comparable<Product> {
	private String name;
	private Double price;

	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Double getPrice() {
		return price;
	}

	public void setPrice(Double price) {
		this.price = price;
	}

	@Override
	public int hashCode() {
		return Objects.hash(name, price);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Product other = (Product) obj;
		return Objects.equals(name, other.name) && Objects.equals(price, other.price);
	}

	@Override
	public String toString() {
		return "Product [name=" + name + ", price=" + price + "]";
	}

	/*
	 * Método compareTo, que deve ser implementado toda vez que 
	 * a interface Comparable é implementada
	 */
	@Override
	public int compareTo(Product other) {
		//Comparando o nome deste produto com o nome do outro produto
		return name.toUpperCase().compareTo(other.getName().toUpperCase());
	}
}
package application;

import java.util.Set;
import java.util.TreeSet;

import entities.Product;

public class Program {
	public static void main(String[] args) {
		
		//Criando um conjunto TreeSet
		Set<Product> set = new TreeSet<>();
		
		//Adicionando elementos ao conjunto
		set.add(new Product("TV", 900.0));
		set.add(new Product("Notebook", 1200.0));
		set.add(new Product("Tablet", 400.0));
		
		//Imprimindo os elementos
		for (Product p : set) {
			System.out.println(p);
		}
		/*
		 * Quando se usa o TreeSet, a classe que trabalha o conjunto
		 * precisa implementar a interface Comparable
		 */
	}
}
 


===================================================================================================================== 
  Exercício resolvido (Set)
 
 
package entities;

import java.util.Date;

public class LogEntry {

    // Atributo privado para armazenar o nome de usuário
    private String username;
    // Atributo privado para armazenar a data e hora da entrada de log
    private Date moment;
    
    // Construtor para inicializar os atributos com os valores passados como parâmetros
    public LogEntry(String username, Date moment) {
        this.username = username;
        this.moment = moment;
    }

    // Método para obter o valor do atributo "username"
    public String getUsername() {
        return username;
    }

    // Método para atribuir um valor ao atributo "username"
    public void setUsername(String username) {
        this.username = username;
    }

    // Método para obter o valor do atributo "moment"
    public Date getMoment() {
        return moment;
    }

    // Método para atribuir um valor ao atributo "moment"
    public void setMoment(Date moment) {
        this.moment = moment;
    }
    
    // hashCode e equals foram gerados automaticamente
    // hashCode é usado para ajudar a comparar objetos da classe LogEntry
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((username == null) ? 0 : username.hashCode());
        return result;
    }

    // equals é usado para comparar se um objeto é igual a outro objeto da classe LogEntry
    // Ele compara apenas o atributo "username" para determinar a igualdade
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        LogEntry other = (LogEntry) obj;
        if (username == null) {
            if (other.username != null)
                return false;
        } else if (!username.equals(other.username))
            return false;
        return true;
    }
}

package application;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.time.Instant;
import java.util.Date;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

import entities.LogEntry;

public class Program {

	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
		
		//Solicitando o caminho do arquivo
		System.out.print("Enter file full path: ");
		String path = sc.nextLine();
		
		//Abrindo e lendo o arquivo com BufferedReader
		try (BufferedReader br = new BufferedReader(new FileReader(path))) {
			
			//Criando um conjunto de logs tipo HashSet
			/*
			 * O hashSet foi usado pela maior velocidade e porque
			 * a comparação vai ser feita apenas em números, não 
			 * importando a ordem em que cada elemento foi armazenado.
			 */
			Set<LogEntry> set = new HashSet<>();
			
			//Lendo a primeira linha
			String line = br.readLine();
			
			//Enquanto a linha for diferente de nula, inicia o processamento
			while (line != null) {
				
				//Recortando a String baseada no espaço em branco
				String[] fields = line.split(" ");
				//Armazenando o nome do usuário na posição zero
				String username = fields[0];
				//Armazenando a data na posição 1
				Date moment = Date.from(Instant.parse(fields[1]));
				
				//Inserindo os objetos no conjunto Set 
				/*
				 * Se tentar inserir algum dado repetido, ela será
				 * barrada pela própria estrutura de Set de forma 
				 * nativa. Set não permite inserções iguais no conjunto. 
				 */
				set.add(new LogEntry(username, moment));
				
				//Lendo a próxima linha
				line = br.readLine();
			}
			//Imprime o total de users na tela pelo tamanhodo conjunto
			System.out.println("Total users: " + set.size());

		} catch (IOException e) {
			System.out.println("Error: " + e.getMessage());
		}
		sc.close();
	}
}
 


===================================================================================================================== 
  Exercício proposto (Set)
 
 
package application;

import java.text.ParseException;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class Program {

	public static void main(String[] args) throws ParseException {

		Scanner sc = new Scanner(System.in);
		
		//Declaração de variáveis:
		//"a" do tipo "Set" (conjunto) de números inteiros
		Set<Integer> a = new HashSet<>();
		//"b" do tipo "Set" (conjunto) de números inteiros
		Set<Integer> b = new HashSet<>();
		//"c" do tipo "Set" (conjunto) de números inteiros
		Set<Integer> c = new HashSet<>();
		
		//Solicita ao usuário quantos alunos há no curso A e armazena a resposta em "n"
		System.out.print("How many students for course A? ");
		int n = sc.nextInt();
		//Utiliza um loop para ler "n" números inteiros e adicioná-los ao conjunto "a"
		for (int i=0; i<n; i++) {
			int number = sc.nextInt();
			a.add(number);
		}
		//Solicita ao usuário quantos alunos há no curso B e armazena a resposta em "n"
		System.out.print("How many students for course B? ");
		n = sc.nextInt();
		//Utiliza um loop para ler "n" números inteiros e adicioná-los ao conjunto "b"
		for (int i=0; i<n; i++) {
			int number = sc.nextInt();
			b.add(number);
		}		
		//Solicita ao usuário quantos alunos há no curso C e armazena a resposta em "n"
		System.out.print("How many students for course C? ");
		n = sc.nextInt();
		//Utiliza um loop para ler "n" números inteiros e adicioná-los ao conjunto "c"
		for (int i=0; i<n; i++) {
			int number = sc.nextInt();
			c.add(number);
		}
		
		//Cria um novo conjunto "total" como uma cópia de "a"
		Set<Integer> total = new HashSet<>(a);
		//Adiciona todos os elementos de "b" e "c" ao conjunto "total"
		total.addAll(b);
		total.addAll(c);
		
		//Imprime o tamanho do conjunto "total" (ou seja, o total de alunos únicos em todos os cursos)
		System.out.println("Total students: " + total.size());

		sc.close();
	}
}
 


===================================================================================================================== 
  Map
 
 
 


===================================================================================================================== 
  Exemplo 1
package application;

import java.util.Map;
import java.util.TreeMap;

public class Program {
	public static void main(String[] args) {
		// Cria um novo TreeMap para armazenar pares de chave-valor
		Map<String, String> cookies = new TreeMap<>();

		// Adiciona um par chave-valor "username": "maria" ao mapa
		cookies.put("username", "maria");

		// Adiciona um par chave-valor "email": "maria@gmail.com" ao mapa
		cookies.put("email", "maria@gmail.com");

		// Adiciona um par chave-valor "phone": "99771122" ao mapa
		cookies.put("phone", "99771122");

		// Remove o par chave-valor com a chave "email" do mapa
		cookies.remove("email");

		// Atualiza o valor do par chave-valor com a chave "phone" para "99771133"
		cookies.put("phone", "99771133");

		// Verifica se o mapa contém a chave "phone" e imprime o resultado
		System.out.println("Contains 'phone' key: " + cookies.containsKey("phone"));

		// Imprime o valor associado à chave "phone"
		System.out.println("Phone number: " + cookies.get("phone"));

		// Imprime o valor associado à chave "email"
		System.out.println("Email: " + cookies.get("email"));

		// Imprime o tamanho do mapa (número de pares chave-valor)
		System.out.println("Size: " + cookies.size());

		// Imprime todos os pares chave-valor no mapa
		System.out.println("ALL COOKIES:");
		for (String key : cookies.keySet()) {
			System.out.println(key + ": " + cookies.get(key));
		}
	}
}

 


===================================================================================================================== 
  Exemplo 2
package entities;

import java.util.Objects;

public class Product {
	// Declaração de variáveis privadas
	private String name;
	private Double price;

	// Construtor
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

	// Método para retornar o nome do produto
	public String getName() {
		return name;
	}

	// Método para setar o nome do produto
	public void setName(String name) {
		this.name = name;
	}

	// Método para retornar o preço do produto
	public Double getPrice() {
		return price;
	}

	// Método para setar o preço do produto
	public void setPrice(Double price) {
		this.price = price;
	}

	// Sobrescrita do método hashCode para verificação de igualdade de objetos
	@Override
	public int hashCode() {
		return Objects.hash(name, price);
	}

	// Sobrescrita do método equals para verificação de igualdade de objetos
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Product other = (Product) obj;
		return Objects.equals(name, other.name) && Objects.equals(price, other.price);
	}
}
package application;

import java.util.HashMap;
import java.util.Map;

import entities.Product;

public class Program {
	public static void main(String[] args) {
		// Criação de um mapa chamado stock
		Map<Product, Double> stock = new HashMap<>();
		// Criação de 3 produtos
		Product p1 = new Product("Tv", 900.0);
		Product p2 = new Product("Notebook", 1200.0);
		Product p3 = new Product("Tablet", 400.0);
		// Adicionando os produtos ao mapa com suas respectivas quantidades
		stock.put(p1, 10000.0);
		stock.put(p2, 20000.0);
		stock.put(p3, 15000.0);
		// Criação de um quarto produto
		Product ps = new Product("Tv", 900.0);
		// Verifica se o mapa contém o produto ps como chave
		System.out.println("Contains 'ps' key: " + stock.containsKey(ps));
	}
	/*
	 * HasMap se utiliza dos métodos equals e hashCode para comparar
	 * elementos de chave. Se não existe equals nem hashCode, ele vai
	 * usar a comparação de ponteiros.
	 * 
	 */
}
 


===================================================================================================================== 
  Exercício proposto (Map)
 
 
package application;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.text.ParseException;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Scanner;

public class Program {
	public static void main(String[] args) throws ParseException {

		// Criação de um objeto Scanner para ler dados do teclado
		Scanner sc = new Scanner(System.in);

		// Criação de um mapa chamado votes
		Map<String, Integer> votes = new LinkedHashMap<>();

		// Pede para o usuário informar o caminho completo do arquivo
		System.out.print("Informe o caminho completo do arquivo: ");
		String path = sc.nextLine();

		// Tenta ler o arquivo
		try (BufferedReader br = new BufferedReader(new FileReader(path))) {
			// Lê a primeira linha do arquivo
			String line = br.readLine();
			// Enquanto houver linhas a serem lidas
			while (line != null) {
				// Quebra a linha lida em um vetor de campos
				String[] fields = line.split(",");
				// O primeiro campo é o nome
				String name = fields[0];
				// O segundo campo é a contagem de votos
				int count = Integer.parseInt(fields[1]);

				// Se o mapa já contém o nome como chave, adiciona a contagem ao valor já
				// existente
				if (votes.containsKey(name)) {
					int votesSoFar = votes.get(name);
					votes.put(name, count + votesSoFar);
				} else {
					// Se não, adiciona o nome e a contagem ao mapa
					votes.put(name, count);
				}

				// Lê a próxima linha
				line = br.readLine();
			}

			// Imprime o conteúdo do mapa
			for (String key : votes.keySet()) {
				System.out.println(key + ": " + votes.get(key));
			}

		} catch (IOException e) {
			// Exibe uma mensagem de erro caso ocorra algum problema ao ler o arquivo
			System.out.println("Erro: " + e.getMessage());
		}

		// Fecha o Scanner
		sc.close();
	}
}
 


===================================================================================================================== 
  Uma experiência comComparator
 
 


===================================================================================================================== 
  Comparator padrão
// Declaração do pacote da aplicação
package application;

// Importação da classe Comparator da biblioteca java.util
import java.util.Comparator;

// Declaração da classe MyComparator que implementa a interface Comparator
public class MyComparator implements Comparator<Product> {

// Sobrescrita do método compare da interface Comparator
	@Override
	public int compare(Product p1, Product p2) {
		// Compara os nomes dos produtos em letra maiúscula e retorna o resultado
		return p1.getName().toUpperCase().compareTo(p2.getName().toUpperCase());
	}
}
// Declaração do pacote da aplicação
package application;

// Importação da classe ArrayList da biblioteca java.util
import java.util.ArrayList;

// Importação da interface List da biblioteca java.util
import java.util.List;

// Importação da classe Product do pacote entities
import entities.Product;

public class Program {

// Método main, ponto de início da aplicação
	public static void main(String[] args) {

		// Criação de uma lista de produtos
		List<Product> list = new ArrayList<>();

		// Adição de itens à lista
		list.add(new Product("TV", 900.00));
		list.add(new Product("Notebook", 1200.00));
		list.add(new Product("Tablet", 450.00));

		// Ordenação da lista usando o comparador MyComparator
		/*
		 * list.sort precisa de argumento Comparator, que é uma
		 * interface funcional, uma interface que tem apenas
		 * 1 método abstrato. Dentro da interface list existe um 
		 * default method sort, e este método sort recebe um Comparator
		 * como argumento.
		 */
		list.sort(new MyComparator());

		// Impressão dos itens da lista
		for (Product p : list) {
			System.out.println(p);
		}
	}
}
// Declaração do pacote da aplicação
package entities;

// Declaração da classe Product
public class Product {

// Declaração das variáveis de instância
	private String name;
	private Double price;

// Construtor default
	public Product() {
	}

// Construtor com parâmetros
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

// Método para obter o nome do produto
	public String getName() {
		return name;
	}

// Método para definir o nome do produto
	public void setName(String name) {
		this.name = name;
	}

// Método para obter o preço do produto
	public Double getPrice() {
		return price;
	}

// Método para definir o preço do produto
	public void setPrice(Double price) {
		this.price = price;
	}

// Sobrescrita do método toString para retornar uma representação em forma de string do objeto
	@Override
	public String toString() {
		return "Product [name=" + name + ", price=" + price + "]";
	}
	/*
	 * Observe que o método Comparator não está nesta classe, pois se o criterio de
	 * comparação mudar, a classe teria que ser alterada. Desta forma, fere-se o
	 * princípio de que a classe precisa estar fechada para edição.
	 */
}
 


===================================================================================================================== 
  Classe anônima
package application;

// Importa a biblioteca java.util.Comparator
import java.util.Comparator;

// Declaração da classe MyComparator que implementa a interface Comparator para a classe Product
public class MyComparator implements Comparator<Product> {

    // Sobrescreve o método compare da interface Comparator
	@Override
	public int compare(Product p1, Product p2) {
        // Compara os nomes dos produtos convertendo para letras maiúsculas antes de comparar
		return p1.getName().toUpperCase().compareTo(p2.getName().toUpperCase());
	}
}
package entities; // declaração do pacote onde a classe está localizada

public class Product { // declaração da classe Product

	private String name; // declaração da variável de instância "name" do tipo String
	private Double price; // declaração da variável de instância "price" do tipo Double

	public Product() { // construtor padrão (sem argumentos) da classe Product
	}

	public Product(String name, Double price) { // construtor da classe Product que recebe dois argumentos: "name" e
												// "price"
		this.name = name; // atribui o valor do argumento "name" à variável de instância "name"
		this.price = price; // atribui o valor do argumento "price" à variável de instância "price"
	}

	public String getName() { // método que retorna o valor da variável de instância "name"
		return name;
	}

	public void setName(String name) { // método que atribui um valor à variável de instância "name"
		this.name = name;
	}

	public Double getPrice() { // método que retorna o valor da variável de instância "price"
		return price;
	}

	public void setPrice(Double price) { // método que atribui um valor à variável de instância "price"
		this.price = price;
	}

	@Override
	public String toString() { // sobrescrita do método toString para personalizar a exibição dos valores das
								// variáveis de instância "name" e "price"
		return "Product [name=" + name + ", price=" + price + "]";
	}
}
package application;

import java.util.ArrayList;

public class Program {

	public static void main(String[] args) {

		List<Product> list = new ArrayList<>();

		// Adiciona três produtos à lista
		list.add(new Product("TV", 900.00));
		list.add(new Product("Notebook", 1200.00));
		list.add(new Product("Tablet", 450.00));

		// Cria um objeto do tipo Comparator para comparar os produtos pelo nome
		Comparator<Product> comp = new Comparator<Product>() {
			// Sobrescreve o método compare da interface Comparator
			@Override
			public int compare(Product p1, Product p2) {
				// Compara os nomes dos produtos convertendo para letras maiúsculas antes de
				// comparar
				return p1.getName().toUpperCase().compareTo(p2.getName().toUpperCase());
			}
		};

		// Ordena a lista de produtos usando o comparador criado
		list.sort(comp);

		// Imprime os produtos na tela
		for (Product p : list) {
			System.out.println(p);
		}
	}
}
 


===================================================================================================================== 
  Lambda 1
// Declaração do pacote da aplicação
package application;

// Importação da classe Comparator da biblioteca java.util
import java.util.Comparator;

// Declaração da classe MyComparator que implementa a interface Comparator
public class MyComparator implements Comparator<Product> {

// Sobrescrita do método compare da interface Comparator
	@Override
	public int compare(Product p1, Product p2) {
		// Compara os nomes dos produtos em letra maiúscula e retorna o resultado
		return p1.getName().toUpperCase().compareTo(p2.getName().toUpperCase());
	}
}
package entities;

public class Product {

	// Declaração das variáveis de instância
	private String name;
	private Double price;

	// Construtor default
	public Product() {
	}

	// Construtor com parâmetros
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

	// Método para obter o nome do produto
	public String getName() {
		return name;
	}

	// Método para definir o nome do produto
	public void setName(String name) {
		this.name = name;
	}

	// Método para obter o preço do produto
	public Double getPrice() {
		return price;
	}

	// Método para definir o preço do produto
	public void setPrice(Double price) {
		this.price = price;
	}

	// Sobrescrita do método toString para retornar uma representação em forma de
	// string do objeto
	@Override
	public String toString() {
		return "Product [name=" + name + ", price=" + price + "]";
	}
}
package application;

import java.util.ArrayList;

public class Program {

	public static void main(String[] args) {

		  // Criação de uma lista de produtos
	    List<Product> list = new ArrayList<>();

	    // Adição de itens à lista
	    list.add(new Product("TV", 900.00));
	    list.add(new Product("Notebook", 1200.00));
	    list.add(new Product("Tablet", 450.00));

	    // Criação de um comparador através de uma expressão lambda
	    Comparator<Product> comp = (p1, p2) -> {
	        // Compara os nomes dos produtos em letra maiúscula e retorna o resultado
	        return p1.getName().toUpperCase().compareTo(p2.getName().toUpperCase());
	    };

	    // Ordenação da lista usando o comparador comp
	    list.sort(comp);

	    // Impressão dos itens da lista
	    for (Product p : list) {
	        System.out.println(p);
	    }
	}
}
 


===================================================================================================================== 
  Lambda 2
package application;

import java.util.Comparator;

import entities.Product;

/**
 * Classe responsável por comparar dois objetos do tipo Product pelo nome.
 */
public class MyComparator implements Comparator<Product> {

	/**
	 * Compara dois objetos do tipo Product pelo nome.
	 */
	@Override
	public int compare(Product p1, Product p2) {
		return p1.getName().toUpperCase().compareTo(p2.getName().toUpperCase());
	}
}
package entities;

/**
 * Classe que representa um produto, com seu nome e preço.
 */
public class Product {

	private String name; // nome do produto
	private Double price; // preço do produto

	/**
	 * Construtor padrão.
	 */
	public Product() {
	}

	/**
	 * Construtor que inicializa o nome e preço do produto.
	 * 
	 *  name  nome do produto
	 *  price preço do produto
	 */
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

	/**
	 * Retorna o nome do produto.
	 * 
	 *  nome do produto
	 */
	public String getName() {
		return name;
	}

	/**
	 * Define o nome do produto.
	 * 
	 *  name nome do produto
	 */
	public void setName(String name) {
		this.name = name;
	}

	/**
	 * Retorna o preço do produto.
	 * 
	 *  preço do produto
	 */
	public Double getPrice() {
		return price;
	}

	/**
	 * Define o preço do produto.
	 * 
	 *  price preço do produto
	 */
	public void setPrice(Double price) {
		this.price = price;
	}

	/**
	 * Retorna uma representação em String do objeto.
	 */
	@Override
	public String toString() {
		return "Product [name=" + name + ", price=" + price + "]";
	}
}
package application;

import java.util.ArrayList;

public class Program {

	public static void main(String[] args) {

		// Criação de uma lista de produtos
		List<Product> list = new ArrayList<>();

		// Adição de itens à lista
		list.add(new Product("TV", 900.00));
		list.add(new Product("Notebook", 1200.00));
		list.add(new Product("Tablet", 450.00));

		// Criação de um comparador através de uma expressão lambda
		Comparator<Product> comp = (p1, p2) -> p1.getName().toUpperCase().compareTo(p2.getName().toUpperCase());

		// Ordenação da lista usando o comparador comp
		list.sort(comp);

		// Impressão dos itens da lista
		for (Product p : list) {
			System.out.println(p);
		}
	}
}
 


===================================================================================================================== 
  Lambda 3
package application;

import java.util.Comparator; // importa a interface Comparator
import entities.Product; // importa a classe Product

/**
 * Classe responsável por comparar dois objetos do tipo Product pelo nome.
 */
public class MyComparator implements Comparator<Product> {

	/**
	 * Compara dois objetos do tipo Product pelo nome.
	 */
	@Override
	public int compare(Product p1, Product p2) {
		return p1.getName().toUpperCase().compareTo(p2.getName().toUpperCase());
	}
}
package entities;

/**
 * Classe que representa um produto, com seus atributos nome e preço.
 */
public class Product {

	private String name; // nome do produto
	private Double price; // preço do produto

	/**
	 * Construtor padrão.
	 */
	public Product() {
	}

	/**
	 * Construtor que inicializa o nome e preço do produto.
	 * 
	 * @param name  nome do produto
	 * @param price preço do produto
	 */
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

	/**
	 * Retorna o nome do produto.
	 * 
	 * @return nome do produto
	 */
	public String getName() {
		return name;
	}

	/**
	 * Define o nome do produto.
	 * 
	 * @param name nome do produto
	 */
	public void setName(String name) {
		this.name = name;
	}

	/**
	 * Retorna o preço do produto.
	 * 
	 * @return preço do produto
	 */
	public Double getPrice() {
		return price;
	}

	/**
	 * Define o preço do produto.
	 * 
	 * @param price preço do produto
	 */
	public void setPrice(Double price) {
		this.price = price;
	}

	/**
	 * Retorna uma representação em String do objeto Product.
	 */
	@Override
	public String toString() {
		return "Product [name=" + name + ", price=" + price + "]";
	}
}
package application;

import java.util.ArrayList;

public class Program {

	public static void main(String[] args) {

		// Criação de uma lista de produtos
		List<Product> list = new ArrayList<>();

		// Adição de itens à lista
		list.add(new Product("TV", 900.00));
		list.add(new Product("Notebook", 1200.00));
		list.add(new Product("Tablet", 450.00));

		// Ordenação da lista usando uma expressão lambda como comparador
		list.sort((p1, p2) -> p1.getName().toUpperCase().compareTo(p2.getName().toUpperCase()));

		// Impressão dos itens da lista
		for (Product p : list) {
			System.out.println(p);
		}
	}
}
 
 


===================================================================================================================== 
  Programação funcional e cálculo lambda
 
 
package application;

import java.util.Comparator; // importa a interface Comparator

/**
 * Classe responsável por comparar dois objetos do tipo Product pelo nome.
 */
public class MyComparator implements Comparator<Product> {

	/**
	 * Compara dois objetos do tipo Product pelo nome.
	 */
	@Override
	public int compare(Product p1, Product p2) {
		return p1.getName().toUpperCase().compareTo(p2.getName().toUpperCase());
	}
}
package entities;

/**
 * Classe que representa um produto, com seus atributos nome e preço.
 */
public class Product {

	private String name; // nome do produto
	private Double price; // preço do produto

	/**
	 * Construtor padrão.
	 */
	public Product() {
	}

	/**
	 * Construtor que inicializa o nome e preço do produto.
	 * 
	 * @param name  nome do produto
	 * @param price preço do produto
	 */
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

	/**
	 * Retorna o nome do produto.
	 * 
	 * @return nome do produto
	 */
	public String getName() {
		return name;
	}

	/**
	 * Define o nome do produto.
	 * 
	 * @param name nome do produto
	 */
	public void setName(String name) {
		this.name = name;
	}

	/**
	 * Retorna o preço do produto.
	 * 
	 * @return preço do produto
	 */
	public Double getPrice() {
		return price;
	}

	/**
	 * Define o preço do produto.
	 * 
	 * @param price preço do produto
	 */
	public void setPrice(Double price) {
		this.price = price;
	}

	/**
	 * Retorna uma representação em String do objeto Product.
	 */
	@Override
	public String toString() {
		return "Product [name=" + name + ", price=" + price + "]";
	}
}
package application;

import java.util.Arrays;

public class Program {
// Declaração de uma variável global, iniciada com valor 3.
	public static int globalValue = 3;

	public static void main(String[] args) {
		// Declaração de um array de inteiros inicializado com os valores 3, 4 e 5
		int[] vect = new int[] { 3, 4, 5 };
		// Chama a função changeOddValues e passa o array como parâmetro.
		changeOddValues(vect);
		// Imprime o array em formato de string.
		System.out.println(Arrays.toString(vect));

	}

	/*
	 * Essa função recebe um array de inteiros como parâmetro e percorre cada
	 * posição do array verificando se o valor é ímpar. Se for ímpar, adiciona a
	 * variável global globalValue ao valor. Essa função acessa dados externos (a
	 * variável globalValue) e isso pode causar efeitos colaterais inesperados no
	 * programa.
	 */
	public static void changeOddValues(int[] numbers) {
		for (int i = 0; i < numbers.length; i++) {
			if (numbers[i] % 2 != 0) {
				numbers[i] += globalValue;
			}
		}
	}
}
 
package application;

import java.util.Comparator; // importa a interface Comparator

/**
 * Classe responsável por comparar dois objetos do tipo Product pelo nome.
 */
public class MyComparator implements Comparator<Product> {

	/**
	 * Compara dois objetos do tipo Product pelo nome.
	 */
	@Override
	public int compare(Product p1, Product p2) {
		return p1.getName().toUpperCase().compareTo(p2.getName().toUpperCase());
	}
}
package entities;

/**
 * Classe que representa um produto, com seus atributos nome e preço.
 */
public class Product {

	private String name; // nome do produto
	private Double price; // preço do produto

	/**
	 * Construtor padrão.
	 */
	public Product() {
	}

	/**
	 * Construtor que inicializa o nome e preço do produto.
	 * 
	 * @param name  nome do produto
	 * @param price preço do produto
	 */
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

	/**
	 * Retorna o nome do produto.
	 * 
	 * @return nome do produto
	 */
	public String getName() {
		return name;
	}

	/**
	 * Define o nome do produto.
	 * 
	 * @param name nome do produto
	 */
	public void setName(String name) {
		this.name = name;
	}

	/**
	 * Retorna o preço do produto.
	 * 
	 * @return preço do produto
	 */
	public Double getPrice() {
		return price;
	}

	/**
	 * Define o preço do produto.
	 * 
	 * @param price preço do produto
	 */
	public void setPrice(Double price) {
		this.price = price;
	}

	/**
	 * Retorna uma representação em String do objeto Product.
	 */
	@Override
	public String toString() {
		return "Product [name=" + name + ", price=" + price + "]";
	}
}
package application;

import java.util.ArrayList;

public class Program {

/*
 * O método compareProducts compara os preços de dois produtos e retorna 
 * um valor inteiro. O método utiliza o método getPrice() da classe Product 
 * para comparar os preços.
 */
public static int compareProducts(Product p1, Product p2) {
    return p1.getPrice().compareTo(p2.getPrice());
}

/*
 * Uma variável global que pode ser acessada por qualquer método dentro desta classe
 */
public static int globalValue = 3;

public static void main(String[] args) {
    List<Product> list = new ArrayList<>();
    
    /*
     * Adicionando os produtos na lista
     */
    list.add(new Product("TV", 900.00));
    list.add(new Product("Notebook", 1200.00));
    list.add(new Product("Tablet", 450.00));

    /*
     * Ordenando a lista de produtos usando o método compareProducts
     */
	/*
	 * Na programação funcional, eu posso passar uma função como objeto de outra
	 * função. Isso significa que eu posso falar que uma função é um objeto de
	 * primeira ordem. Ela pode ser passada como argumento de outra função. Na
	 * programação funcional isso é comum.
	 */
    list.sort(Program::compareProducts);

    /*
     * Imprimindo cada item da lista
     */
    list.forEach(System.out::println);
}
}
 
package application;

import java.util.Comparator; // importa a interface Comparator

/**
 * Classe responsável por comparar dois objetos do tipo Product pelo nome.
 */
public class MyComparator implements Comparator<Product> {

	/**
	 * Compara dois objetos do tipo Product pelo nome.
	 */
	@Override
	public int compare(Product p1, Product p2) {
		return p1.getName().toUpperCase().compareTo(p2.getName().toUpperCase());
	}
}
package entities;

/**
 * Classe que representa um produto, com seus atributos nome e preço.
 */
public class Product {

	private String name; // nome do produto
	private Double price; // preço do produto

	/**
	 * Construtor padrão.
	 */
	public Product() {
	}

	/**
	 * Construtor que inicializa o nome e preço do produto.
	 * 
	 * @param name  nome do produto
	 * @param price preço do produto
	 */
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

	/**
	 * Retorna o nome do produto.
	 * 
	 * @return nome do produto
	 */
	public String getName() {
		return name;
	}

	/**
	 * Define o nome do produto.
	 * 
	 * @param name nome do produto
	 */
	public void setName(String name) {
		this.name = name;
	}

	/**
	 * Retorna o preço do produto.
	 * 
	 * @return preço do produto
	 */
	public Double getPrice() {
		return price;
	}

	/**
	 * Define o preço do produto.
	 * 
	 * @param price preço do produto
	 */
	public void setPrice(Double price) {
		this.price = price;
	}

	/**
	 * Retorna uma representação em String do objeto Product.
	 */
	@Override
	public String toString() {
		return "Product [name=" + name + ", price=" + price + "]";
	}
}
package application;

import java.util.ArrayList;

public class Program {

	public static void main(String[] args) {
		List<Product> list = new ArrayList<>();
		list.add(new Product("TV", 900.00));
		list.add(new Product("Notebook", 1200.00));
		list.add(new Product("Tablet", 450.00));
		
		/*
		 * A expressão lambda não obriga a declarar o tipo de p1 e p2
		 * existe uma inferência de tipos. O compilador já reconhece o 
		 * tipo do objeto. O compilador deduziu que os tipos da variáveis 
		 * são Product. 
		 */
		/*
		 * Função Lambda representa uma função anônima de primeira classe
		 */
		list.sort((p1, p2) -> p1.getPrice().compareTo(p2.getPrice()));
		list.forEach(System.out::println);
	}
}
 
 
 
 


===================================================================================================================== 
  Interface funcional
 
 
 
package util;

import java.util.function.Predicate;

import entities.Product;

//Classe ProductPredicate implementa a interface Predicate, específica para trabalhar com objetos do tipo Product
public class ProductPradicate implements Predicate<Product> {
	// Sobrescreve o método test da interface Predicate
	@Override
	public boolean test(Product p) {
		// retorna verdadeiro se o preço do produto for maior ou igual a 100.0
		return p.getPrice() >= 100.0;
	}

	/*
	 * // A classe ProductPredicate é utilizada para verificar se um produto tem
	 * preço maior ou igual a 100.0.A classe Predicate é uma interface funcional que
	 * contém apenas um método, test, que retorna um boolean e recebe um objeto
	 * genérico. Ela é usada para definir regras de validação ou filtros para
	 * objetos de determinado tipo.
	 */

}
package entities;

/**
 * Classe que representa um produto, com seus atributos nome e preço.
 */
public class Product {

	private String name; // nome do produto
	private Double price; // preço do produto

	/**
	 * Construtor padrão.
	 */
	public Product() {
	}

	/**
	 * Construtor que inicializa o nome e preço do produto.
	 * 
	 * @param name  nome do produto
	 * @param price preço do produto
	 */
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

	/**
	 * Retorna o nome do produto.
	 * 
	 * @return nome do produto
	 */
	public String getName() {
		return name;
	}

	/**
	 * Define o nome do produto.
	 * 
	 * @param name nome do produto
	 */
	public void setName(String name) {
		this.name = name;
	}

	/**
	 * Retorna o preço do produto.
	 * 
	 * @return preço do produto
	 */
	public Double getPrice() {
		return price;
	}

	/**
	 * Define o preço do produto.
	 * 
	 * @param price preço do produto
	 */
	public void setPrice(Double price) {
		this.price = price;
	}

	/**
	 * Retorna uma representação em String do objeto Product.
	 */
	@Override
	public String toString() {
		return "Product [name=" + name + ", price=" + price + "]";
	}
}
package application;

import java.util.ArrayList;

public class Program {

	public static void main(String[] args) {
		List<Product> list = new ArrayList<>(); // cria uma lista de produtos
		list.add(new Product("TV", 900.00)); // adiciona um produto "TV" com preço 900.00
		list.add(new Product("Notebook", 50.00)); // adiciona um produto "Notebook" com preço 50.00
		list.add(new Product("Tablet", 350.00)); // adiciona um produto "Tablet" com preço 350.00
		list.add(new Product("Tablet", 80.90)); // adiciona um produto "Tablet" com preço 80.90

		// removeIf recebe como argumento um pradicate. Neste caso, uma Lambda
		// remove os produtos cujo preço seja maior ou igual a 100
		list.removeIf(p -> p.getPrice() >= 100);

		// imprime os produtos restantes na lista
		for (Product p : list) {
			System.out.println(p);
		}
	}
}
 
 
 
package util;

import java.util.function.Predicate;

//Classe ProductPredicate implementa a interface Predicate, específica para trabalhar com objetos do tipo Product
public class ProductPradicate implements Predicate<Product> {
	// Sobrescreve o método test da interface Predicate
	@Override
	public boolean test(Product p) {
		// retorna verdadeiro se o preço do produto for maior ou igual a 100.0
		return p.getPrice() >= 100.0;
	}
	/*
	 * // A classe ProductPredicate é utilizada para verificar se um produto tem
	 * preço maior ou igual a 100.0.A classe Predicate é uma interface funcional que
	 * contém apenas um método, test, que retorna um boolean e recebe um objeto
	 * genérico. Ela é usada para definir regras de validação ou filtros para
	 * objetos de determinado tipo.
	 */
}
package entities;

/**
 * Classe que representa um produto, com seus atributos nome e preço.
 */
public class Product {

	private String name; // nome do produto
	private Double price; // preço do produto

	/**
	 * Construtor padrão.
	 */
	public Product() {
	}

	/**
	 * Construtor que inicializa o nome e preço do produto.
	 * 
	 * @param name  nome do produto
	 * @param price preço do produto
	 */
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

	/**
	 * Retorna o nome do produto.
	 * 
	 * @return nome do produto
	 */
	public String getName() {
		return name;
	}

	/**
	 * Define o nome do produto.
	 * 
	 * @param name nome do produto
	 */
	public void setName(String name) {
		this.name = name;
	}

	/**
	 * Retorna o preço do produto.
	 * 
	 * @return preço do produto
	 */
	public Double getPrice() {
		return price;
	}

	/**
	 * Define o preço do produto.
	 * 
	 * @param price preço do produto
	 */
	public void setPrice(Double price) {
		this.price = price;
	}

	/**
	 * Retorna uma representação em String do objeto Product.
	 */
	@Override
	public String toString() {
		return "Product [name=" + name + ", price=" + price + "]";
	}
}
package application;

import java.util.ArrayList;

public class Program {

	public static void main(String[] args) {
		List<Product> list = new ArrayList<>(); // cria uma lista de produtos
		list.add(new Product("TV", 900.00)); // adiciona um produto "TV" com preço 900.00
		list.add(new Product("Notebook", 50.00)); // adiciona um produto "Notebook" com preço 50.00
		list.add(new Product("Tablet", 350.00)); // adiciona um produto "Tablet" com preço 350.00
		list.add(new Product("Tablet", 80.90)); // adiciona um produto "Tablet" com preço 80.90
		
		//Recebendo ProductPredicate como predicado
		list.removeIf(new ProductPradicate());

		// imprime os produtos restantes na lista
		for (Product p : list) {
			System.out.println(p);
		}
	}
}
Reference method com método estático
package util;

import java.util.function.Predicate;

//Classe ProductPredicate implementa a interface Predicate, específica para trabalhar com objetos do tipo Product
public class ProductPradicate implements Predicate<Product> {
	// Sobrescreve o método test da interface Predicate
	@Override
	public boolean test(Product p) {
		// retorna verdadeiro se o preço do produto for maior ou igual a 100.0
		return p.getPrice() >= 100.0;
	}

	/*
	 * // A classe ProductPredicate é utilizada para verificar se um produto tem
	 * preço maior ou igual a 100.0.A classe Predicate é uma interface funcional que
	 * contém apenas um método, test, que retorna um boolean e recebe um objeto
	 * genérico. Ela é usada para definir regras de validação ou filtros para
	 * objetos de determinado tipo.
	 */

}
package entities;

/**
 * Classe que representa um produto, com seus atributos nome e preço.
 */
public class Product {

	private String name; // nome do produto
	private Double price; // preço do produto

	/**
	 * Construtor padrão.
	 */
	public Product() {
	}

	/**
	 * Construtor que inicializa o nome e preço do produto.
	 * 
	 * @param name  nome do produto
	 * @param price preço do produto
	 */
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

	/**
	 * Retorna o nome do produto.
	 * 
	 * @return nome do produto
	 */
	public String getName() {
		return name;
	}

	/**
	 * Define o nome do produto.
	 * 
	 * @param name nome do produto
	 */
	public void setName(String name) {
		this.name = name;
	}

	/**
	 * Retorna o preço do produto.
	 * 
	 * @return preço do produto
	 */
	public Double getPrice() {
		return price;
	}

	/**
	 * Define o preço do produto.
	 * 
	 * @param price preço do produto
	 */
	public void setPrice(Double price) {
		this.price = price;
	}
	
	public static boolean staticProductPredicate(Product p) {
		return p.getPrice() >= 100.0;
	}

	/**
	 * Retorna uma representação em String do objeto Product.
	 */
	@Override
	public String toString() {
		return "Product [name=" + name + ", price=" + price + "]";
	}
}
package application;

import java.util.ArrayList;

public class Program {

	public static void main(String[] args) {
		List<Product> list = new ArrayList<>(); // cria uma lista de produtos
		list.add(new Product("TV", 900.00)); // adiciona um produto "TV" com preço 900.00
		list.add(new Product("Notebook", 50.00)); // adiciona um produto "Notebook" com preço 50.00
		list.add(new Product("Tablet", 350.00)); // adiciona um produto "Tablet" com preço 350.00
		list.add(new Product("Tablet", 80.90)); // adiciona um produto "Tablet" com preço 80.90
		
		/*
		 * Usando method reference. Classe onde o método está :: nome do método
		 * isso também é aceito no sistema Lambda do Java
		 */
		list.removeIf(Product::staticProductPredicate);

		// imprime os produtos restantes na lista
		for (Product p : list) {
			System.out.println(p);
		}
	}
}
Reference method com método não estático
package entities;

/**
 * Classe que representa um produto, com seus atributos nome e preço.
 */
public class Product {

	private String name; // nome do produto
	private Double price; // preço do produto

	/**
	 * Construtor padrão.
	 */
	public Product() {
	}

	/**
	 * Construtor que inicializa o nome e preço do produto.
	 * 
	 * @param name  nome do produto
	 * @param price preço do produto
	 */
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

	/**
	 * Retorna o nome do produto.
	 * 
	 * @return nome do produto
	 */
	public String getName() {
		return name;
	}

	/**
	 * Define o nome do produto.
	 * 
	 * @param name nome do produto
	 */
	public void setName(String name) {
		this.name = name;
	}

	/**
	 * Retorna o preço do produto.
	 * 
	 * @return preço do produto
	 */
	public Double getPrice() {
		return price;
	}

	/**
	 * Define o preço do produto.
	 * 
	 * @param price preço do produto
	 */
	public void setPrice(Double price) {
		this.price = price;
	}
	
	/*
	 * Lembre-se: método estático trabalha com valores que recebe como argumento
	 */
	public static boolean staticProductPredicate(Product p) {
		return p.getPrice() >= 100.0;
	}
	
	/*
	 * Lembre-se: método não estático trabalha com valores da própria Classe,
	 * acessa atributos desta Classe
	 */
	public boolean nonStaticProductPredicate() {
		return price >= 100.0;
	}

	/**
	 * Retorna uma representação em String do objeto Product.
	 */
	@Override
	public String toString() {
		return "Product [name=" + name + ", price=" + price + "]";
	}
}
package util;

import java.util.function.Predicate;

//Classe ProductPredicate implementa a interface Predicate, específica para trabalhar com objetos do tipo Product
public class ProductPradicate implements Predicate<Product> {
	// Sobrescreve o método test da interface Predicate
	@Override
	public boolean test(Product p) {
		// retorna verdadeiro se o preço do produto for maior ou igual a 100.0
		return p.getPrice() >= 100.0;
	}

	/*
	 * // A classe ProductPredicate é utilizada para verificar se um produto tem
	 * preço maior ou igual a 100.0.A classe Predicate é uma interface funcional que
	 * contém apenas um método, test, que retorna um boolean e recebe um objeto
	 * genérico. Ela é usada para definir regras de validação ou filtros para
	 * objetos de determinado tipo.
	 */

}
package application;

import java.util.ArrayList;

public class Program {

	public static void main(String[] args) {
		List<Product> list = new ArrayList<>(); // cria uma lista de produtos
		list.add(new Product("TV", 900.00)); // adiciona um produto "TV" com preço 900.00
		list.add(new Product("Notebook", 50.00)); // adiciona um produto "Notebook" com preço 50.00
		list.add(new Product("Tablet", 350.00)); // adiciona um produto "Tablet" com preço 350.00
		list.add(new Product("Tablet", 80.90)); // adiciona um produto "Tablet" com preço 80.90
		
		/*
		 * Usando method reference. Classe onde o método está :: nome do método
		 * isso também é aceito no sistema Lambda do Java
		 */
		list.removeIf(Product::nonStaticProductPredicate);

		// imprime os produtos restantes na lista
		for (Product p : list) {
			System.out.println(p);
		}
	}
}
Expressão lambda declarada
package entities;

/**
 * Classe que representa um produto, com seus atributos nome e preço.
 */
public class Product {

	private String name; // nome do produto
	private Double price; // preço do produto

	/**
	 * Construtor padrão.
	 */
	public Product() {
	}

	/**
	 * Construtor que inicializa o nome e preço do produto.
	 * 
	 * @param name  nome do produto
	 * @param price preço do produto
	 */
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

	/**
	 * Retorna o nome do produto.
	 * 
	 * @return nome do produto
	 */
	public String getName() {
		return name;
	}

	/**
	 * Define o nome do produto.
	 * 
	 * @param name nome do produto
	 */
	public void setName(String name) {
		this.name = name;
	}

	/**
	 * Retorna o preço do produto.
	 * 
	 * @return preço do produto
	 */
	public Double getPrice() {
		return price;
	}

	/**
	 * Define o preço do produto.
	 * 
	 * @param price preço do produto
	 */
	public void setPrice(Double price) {
		this.price = price;
	}
	
	/*
	 * Lembre-se: método estático trabalha com valores que recebe como argumento
	 */
	public static boolean staticProductPredicate(Product p) {
		return p.getPrice() >= 100.0;
	}
	
	/*
	 * Lembre-se: método não estático trabalha com valores da própria Classe,
	 * acessa atributos desta Classe
	 */
	public boolean nonStaticProductPredicate() {
		return price >= 100.0;
	}

	/**
	 * Retorna uma representação em String do objeto Product.
	 */
	@Override
	public String toString() {
		return "Product [name=" + name + ", price=" + price + "]";
	}
}
package util;

import java.util.function.Predicate;

//Classe ProductPredicate implementa a interface Predicate, específica para trabalhar com objetos do tipo Product
public class ProductPradicate implements Predicate<Product> {
	// Sobrescreve o método test da interface Predicate
	@Override
	public boolean test(Product p) {
		// retorna verdadeiro se o preço do produto for maior ou igual a 100.0
		return p.getPrice() >= 100.0;
	}

	/*
	 * // A classe ProductPredicate é utilizada para verificar se um produto tem
	 * preço maior ou igual a 100.0.A classe Predicate é uma interface funcional que
	 * contém apenas um método, test, que retorna um boolean e recebe um objeto
	 * genérico. Ela é usada para definir regras de validação ou filtros para
	 * objetos de determinado tipo.
	 */

}
package application;

import java.util.ArrayList;

public class Program {

	public static void main(String[] args) {
		List<Product> list = new ArrayList<>(); // cria uma lista de produtos
		list.add(new Product("TV", 900.00)); // adiciona um produto "TV" com preço 900.00
		list.add(new Product("Notebook", 50.00)); // adiciona um produto "Notebook" com preço 50.00
		list.add(new Product("Tablet", 350.00)); // adiciona um produto "Tablet" com preço 350.00
		list.add(new Product("Tablet", 80.90)); // adiciona um produto "Tablet" com preço 80.90
		
		/*
		 * Trabalhando com expressões lambda declaradas. A variável pred
		 * recebe uma função lambda declarada.
		 * Esta foram possibilita pegar valores de variáveis, exemplo:
		 * Predicate<Product> pred = p -> p.getPrice() >= n; sendo n a 
		 * variável que recebe o valor, inclusive digitado pelo usuário
		 */
		
		Predicate<Product> pred = p -> p.getPrice() >= 100.0;
		 
		list.removeIf(pred);

		// imprime os produtos restantes na lista
		for (Product p : list) {
			System.out.println(p);
		}
	}
}
 Expressão lambda inline
package entities;

/**
 * Classe que representa um produto, com seus atributos nome e preço.
 */
public class Product {

	private String name; // nome do produto
	private Double price; // preço do produto

	/**
	 * Construtor padrão.
	 */
	public Product() {
	}

	/**
	 * Construtor que inicializa o nome e preço do produto.
	 * 
	 * @param name  nome do produto
	 * @param price preço do produto
	 */
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

	/**
	 * Retorna o nome do produto.
	 * 
	 * @return nome do produto
	 */
	public String getName() {
		return name;
	}

	/**
	 * Define o nome do produto.
	 * 
	 * @param name nome do produto
	 */
	public void setName(String name) {
		this.name = name;
	}

	/**
	 * Retorna o preço do produto.
	 * 
	 * @return preço do produto
	 */
	public Double getPrice() {
		return price;
	}

	/**
	 * Define o preço do produto.
	 * 
	 * @param price preço do produto
	 */
	public void setPrice(Double price) {
		this.price = price;
	}
	
	/*
	 * Lembre-se: método estático trabalha com valores que recebe como argumento
	 */
	public static boolean staticProductPredicate(Product p) {
		return p.getPrice() >= 100.0;
	}
	
	/*
	 * Lembre-se: método não estático trabalha com valores da própria Classe,
	 * acessa atributos desta Classe
	 */
	public boolean nonStaticProductPredicate() {
		return price >= 100.0;
	}

	/**
	 * Retorna uma representação em String do objeto Product.
	 */
	@Override
	public String toString() {
		return "Product [name=" + name + ", price=" + price + "]";
	}
}
package util;

import java.util.function.Predicate;

//Classe ProductPredicate implementa a interface Predicate, específica para trabalhar com objetos do tipo Product
public class ProductPradicate implements Predicate<Product> {
	// Sobrescreve o método test da interface Predicate
	@Override
	public boolean test(Product p) {
		// retorna verdadeiro se o preço do produto for maior ou igual a 100.0
		return p.getPrice() >= 100.0;
	}

	/*
	 * // A classe ProductPredicate é utilizada para verificar se um produto tem
	 * preço maior ou igual a 100.0.A classe Predicate é uma interface funcional que
	 * contém apenas um método, test, que retorna um boolean e recebe um objeto
	 * genérico. Ela é usada para definir regras de validação ou filtros para
	 * objetos de determinado tipo.
	 */

}
package application;

import java.util.ArrayList;

public class Program {

	public static void main(String[] args) {
		List<Product> list = new ArrayList<>(); // cria uma lista de produtos
		list.add(new Product("TV", 900.00)); // adiciona um produto "TV" com preço 900.00
		list.add(new Product("Notebook", 50.00)); // adiciona um produto "Notebook" com preço 50.00
		list.add(new Product("Tablet", 350.00)); // adiciona um produto "Tablet" com preço 350.00
		list.add(new Product("Tablet", 80.90)); // adiciona um produto "Tablet" com preço 80.90
		
		/*
		 * Trabalhando com expressões lambda inline. removeIf recebe como
		 * parâmetro a própria expressão lambda.
		 */
				 
		list.removeIf(p -> p.getPrice() >= 100.0);

		// imprime os produtos restantes na lista
		for (Product p : list) {
			System.out.println(p);
		}
	}
}
 


===================================================================================================================== 
  Consumer
 
 
 
Implementação da interface
package entities;

//Classe Product que representa um produto
public class Product {

//Atributo privado para armazenar o nome do produto
	private String name;

//Atributo privado para armazenar o preço do produto
	private Double price;

//Construtor para inicializar os atributos da classe
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

//Método para retornar o nome do produto
	public String getName() {
		return name;
	}

//Método para definir o nome do produto
	public void setName(String name) {
		this.name = name;
	}

//Método para retornar o preço do produto
	public Double getPrice() {
		return price;
	}

//Método para definir o preço do produto
	public void setPrice(Double price) {
		this.price = price;
	}

//Sobrescrita do método toString para exibir o nome e preço do produto de forma legível
	@Override
	public String toString() {
		return name + ", " + String.format("%.2f", price);
	}
}
package util;

import java.util.function.Consumer;

import entities.Product;

//Classe auxiliar que implementa a interface Consumer para atualizar os preços dos produtos
public class PriceUpdate implements Consumer<Product> {

	// Método sobrescrito da interface Consumer, que é aplicado a cada elemento da
	// lista de produtos
	@Override
	public void accept(Product p) {
		// Aumenta o preço do produto em 10%
		p.setPrice(p.getPrice() * 1.1);
	}
	/*
	 * A classe Consumer em Java é uma interface funcional que representa uma
	 * operação que aceita um único argumento e não retorna nenhum resultado. Ela é
	 * usada principalmente em conjunto com a classe Stream para processar elementos
	 * em uma coleção de forma declarativa. A classe Consumer é geralmente passada
	 * como um argumento para métodos como forEach() e peek() para processar
	 * elementos em uma coleção.
	 */
}
package application;

import java.util.ArrayList;
import java.util.List;

import entities.Product;
import util.PriceUpdate;

//Classe principal do programa
public class Program {

    //Método main, ponto de entrada da aplicação
	public static void main(String[] args) {

        //Criação de uma lista de produtos
		List<Product> list = new ArrayList<>();

        //Adição de quatro produtos à lista
		list.add(new Product("Tv", 900.00));
		list.add(new Product("Mouse", 50.00));
		list.add(new Product("Tablet", 350.50));
		list.add(new Product("HD Case", 80.90));

        //Aplicação de uma classe auxiliar (PriceUpdate) para atualizar os preços dos produtos na lista
		list.forEach(new PriceUpdate());

        //Impressão dos produtos e seus preços atualizados na tela
		list.forEach(System.out::println);
	}
}
Reference method com método estático
package util;

import java.util.function.Consumer;

//Classe auxiliar que implementa a interface Consumer para atualizar os preços dos produtos
public class PriceUpdate implements Consumer<Product> {

    //Método sobrescrito da interface Consumer, que é aplicado a cada elemento da lista de produtos
	@Override
	public void accept(Product p) {
        //Aumenta o preço do produto em 10%
		p.setPrice(p.getPrice() * 1.1);
	}
}
package entities;

//Classe Product que representa um produto
public class Product {

//Atributo privado para armazenar o nome do produto
	private String name;

//Atributo privado para armazenar o preço do produto
	private Double price;

//Construtor para inicializar os atributos da classe
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

//Método para retornar o nome do produto
	public String getName() {
		return name;
	}

//Método para definir o nome do produto
	public void setName(String name) {
		this.name = name;
	}

//Método para retornar o preço do produto
	public Double getPrice() {
		return price;
	}

//Método para definir o preço do produto
	public void setPrice(Double price) {
		this.price = price;
	}
	
	public static void staticPriceUpdate(Product p) {
		p.setPrice(p.getPrice() * 1.1);
	}

//Sobrescrita do método toString para exibir o nome e preço do produto de forma legível
	@Override
	public String toString() {
		return name + ", " + String.format("%.2f", price);
	}
}
package application;

import java.util.ArrayList;

//Classe principal do programa
public class Program {

    //Método main, ponto de entrada da aplicação
	public static void main(String[] args) {

        //Criação de uma lista de produtos
		List<Product> list = new ArrayList<>();

        //Adição de quatro produtos à lista
		list.add(new Product("Tv", 900.00));
		list.add(new Product("Mouse", 50.00));
		list.add(new Product("Tablet", 350.50));
		list.add(new Product("HD Case", 80.90));

        //Aplicação de uma classe auxiliar (PriceUpdate) para atualizar os preços dos produtos na lista
		//Reference method com método estático
		list.forEach(Product :: staticPriceUpdate);

        //Impressão dos produtos e seus preços atualizados na tela
		list.forEach(System.out::println);
	}	
}
Reference method com método não estático
package util;

import java.util.function.Consumer;

//Classe auxiliar que implementa a interface Consumer para atualizar os preços dos produtos
public class PriceUpdate implements Consumer<Product> {

    //Método sobrescrito da interface Consumer, que é aplicado a cada elemento da lista de produtos
	@Override
	public void accept(Product p) {
        //Aumenta o preço do produto em 10%
		p.setPrice(p.getPrice() * 1.1);
	}
}
package entities;

//Classe Product que representa um produto
public class Product {

//Atributo privado para armazenar o nome do produto
	private String name;

//Atributo privado para armazenar o preço do produto
	private Double price;

//Construtor para inicializar os atributos da classe
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

//Método para retornar o nome do produto
	public String getName() {
		return name;
	}

//Método para definir o nome do produto
	public void setName(String name) {
		this.name = name;
	}

//Método para retornar o preço do produto
	public Double getPrice() {
		return price;
	}

//Método para definir o preço do produto
	public void setPrice(Double price) {
		this.price = price;
	}
	
	public static void staticPriceUpdate(Product p) {
		p.setPrice(p.getPrice() * 1.1);
	}
	
	//Método não estático trabalha com os dados da própria Classe
	public void nonStaticPriceUpdate() {
		price = price * 1.1;
	}

//Sobrescrita do método toString para exibir o nome e preço do produto de forma legível
	@Override
	public String toString() {
		return name + ", " + String.format("%.2f", price);
	}
}
package application;

import java.util.ArrayList;

//Classe principal do programa
public class Program {

    //Método main, ponto de entrada da aplicação
	public static void main(String[] args) {

        //Criação de uma lista de produtos
		List<Product> list = new ArrayList<>();

        //Adição de quatro produtos à lista
		list.add(new Product("Tv", 900.00));
		list.add(new Product("Mouse", 50.00));
		list.add(new Product("Tablet", 350.50));
		list.add(new Product("HD Case", 80.90));

        //Aplicação de uma classe auxiliar (PriceUpdate) para atualizar os preços dos produtos na lista
		//Reference method com método estático
		list.forEach(Product :: nonStaticPriceUpdate);

        //Impressão dos produtos e seus preços atualizados na tela
		list.forEach(System.out::println);
	}	
}
Expressão lambda declarada
package util;

import java.util.function.Consumer;

//Classe auxiliar que implementa a interface Consumer para atualizar os preços dos produtos
public class PriceUpdate implements Consumer<Product> {

    //Método sobrescrito da interface Consumer, que é aplicado a cada elemento da lista de produtos
	@Override
	public void accept(Product p) {
        //Aumenta o preço do produto em 10%
		p.setPrice(p.getPrice() * 1.1);
	}
}
package entities;

//Classe Product que representa um produto
public class Product {

//Atributo privado para armazenar o nome do produto
	private String name;

//Atributo privado para armazenar o preço do produto
	private Double price;

//Construtor para inicializar os atributos da classe
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

//Método para retornar o nome do produto
	public String getName() {
		return name;
	}

//Método para definir o nome do produto
	public void setName(String name) {
		this.name = name;
	}

//Método para retornar o preço do produto
	public Double getPrice() {
		return price;
	}

//Método para definir o preço do produto
	public void setPrice(Double price) {
		this.price = price;
	}
	
	public static void staticPriceUpdate(Product p) {
		p.setPrice(p.getPrice() * 1.1);
	}
	
	//Método não estático trabalha com os dados da própria Classe
	public void nonStaticPriceUpdate() {
		price = price * 1.1;
	}

//Sobrescrita do método toString para exibir o nome e preço do produto de forma legível
	@Override
	public String toString() {
		return name + ", " + String.format("%.2f", price);
	}
}
package application;

import java.util.ArrayList;

//Classe principal do programa
public class Program {

    //Método main, ponto de entrada da aplicação
	public static void main(String[] args) {

        //Criação de uma lista de produtos
		List<Product> list = new ArrayList<>();

        //Adição de quatro produtos à lista
		list.add(new Product("Tv", 900.00));
		list.add(new Product("Mouse", 50.00));
		list.add(new Product("Tablet", 350.50));
		list.add(new Product("HD Case", 80.90));
		
		Double factor = 1.1;
		
		//Expressão lambda declarada
		Consumer<Product> cons = p -> {
			p.setPrice(p.getPrice() * factor);
		};

        //Aplicação de uma classe auxiliar (PriceUpdate) para atualizar os preços dos produtos na lista
		//Reference method com método estático
		list.forEach(cons);

        //Impressão dos produtos e seus preços atualizados na tela
		list.forEach(System.out::println);
	}	
}
Expressão lambda inline
package util;

import java.util.function.Consumer;

import entities.Product;

//Classe auxiliar que implementa a interface Consumer para atualizar os preços dos produtos
public class PriceUpdate implements Consumer<Product> {

    //Método sobrescrito da interface Consumer, que é aplicado a cada elemento da lista de produtos
	@Override
	public void accept(Product p) {
        //Aumenta o preço do produto em 10%
		p.setPrice(p.getPrice() * 1.1);
	}
}
package entities;

//Classe Product que representa um produto
public class Product {

//Atributo privado para armazenar o nome do produto
	private String name;

//Atributo privado para armazenar o preço do produto
	private Double price;

//Construtor para inicializar os atributos da classe
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

//Método para retornar o nome do produto
	public String getName() {
		return name;
	}

//Método para definir o nome do produto
	public void setName(String name) {
		this.name = name;
	}

//Método para retornar o preço do produto
	public Double getPrice() {
		return price;
	}

//Método para definir o preço do produto
	public void setPrice(Double price) {
		this.price = price;
	}
	
	public static void staticPriceUpdate(Product p) {
		p.setPrice(p.getPrice() * 1.1);
	}
	
	//Método não estático trabalha com os dados da própria Classe
	public void nonStaticPriceUpdate() {
		price = price * 1.1;
	}

//Sobrescrita do método toString para exibir o nome e preço do produto de forma legível
	@Override
	public String toString() {
		return name + ", " + String.format("%.2f", price);
	}
}
package application;

import java.util.ArrayList;

//Classe principal do programa
public class Program {

    //Método main, ponto de entrada da aplicação
	public static void main(String[] args) {

        //Criação de uma lista de produtos
		List<Product> list = new ArrayList<>();

        //Adição de quatro produtos à lista
		list.add(new Product("Tv", 900.00));
		list.add(new Product("Mouse", 50.00));
		list.add(new Product("Tablet", 350.50));
		list.add(new Product("HD Case", 80.90));

        //Aplicação de uma classe auxiliar (PriceUpdate) para atualizar os preços dos produtos na lista
		//Expressão lambda inline
		list.forEach(p -> p.setPrice(p.getPrice() * 1.1));

        //Impressão dos produtos e seus preços atualizados na tela
		list.forEach(System.out::println);
	}	
}
 


===================================================================================================================== 
  Function (exemplo com map)
 
 
Implementação da interface
package util;

import java.util.function.Function;

// Classe para transformar o nome de um produto em maiúsculas
public class UpperCaseName implements Function<Product, String> {

	// Sobrescrita do método apply para transformar o nome do produto em maiúsculas
	@Override
	public String apply(Product p) {
		return p.getName().toUpperCase();
	}
	/*
	 * A interface funcional Function em Java é uma interface que representa uma
	 * função que recebe um argumento e retorna um resultado. Ela é usada para
	 * aplicar uma transformação aos elementos de uma coleção ou para mapear valores
	 * de uma fonte para outra. A interface Function é geralmente passada como um
	 * argumento para métodos como map() e flatMap() para transformar elementos em
	 * uma coleção. Ela também pode ser combinada com outras interfaces funcionais,
	 * como Predicate e Consumer, para criar expressões lambda mais complexas.
	 */
}
package entities;

//Classe Product que representa um produto
public class Product {

//Atributo privado para armazenar o nome do produto
	private String name;

//Atributo privado para armazenar o preço do produto
	private Double price;

//Construtor para inicializar os atributos da classe
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

//Método para retornar o nome do produto
	public String getName() {
		return name;
	}

//Método para definir o nome do produto
	public void setName(String name) {
		this.name = name;
	}

//Método para retornar o preço do produto
	public Double getPrice() {
		return price;
	}

//Método para definir o preço do produto
	public void setPrice(Double price) {
		this.price = price;
	}
	

//Sobrescrita do método toString para exibir o nome e preço do produto de forma legível
	@Override
	public String toString() {
		return name + ", " + String.format("%.2f", price);
	}
}
package application;

import java.util.ArrayList;

// Classe principal do programa
public class Program {

	// Método main, ponto de entrada da aplicação
	public static void main(String[] args) {

		// Criação de uma lista de produtos
		List<Product> list = new ArrayList<>();

		// Adição de quatro produtos à lista
		list.add(new Product("Tv", 900.00));
		list.add(new Product("Mouse", 50.00));
		list.add(new Product("Tablet", 350.50));
		list.add(new Product("HD Case", 80.90));

		// Criação de uma nova lista com os nomes dos produtos em maiúsculas
		// Implementação da interface
		List<String> names = list.stream().map(new UpperCaseName()).collect(Collectors.toList());

		// Impressão da lista de nomes na tela
		names.forEach(System.out::println);
	}
	/*
	 * A função map() em Java é utilizada para aplicar uma determinada operação em
	 * todos os elementos de uma coleção, como uma lista ou um array. Ela é
	 * fornecida pela interface Stream e pode ser utilizada com qualquer coleção que
	 * implemente a interface Collection. A função map() recebe como parâmetro uma
	 * função de transformação, que é aplicada a cada elemento da coleção. Ela
	 * retorna um novo Stream com os elementos transformados.
	 */
}
Reference method com método estático
package util;

import java.util.function.Function;

public class UpperCaseName implements Function<Product, String> {

	@Override
	public String apply(Product p) {
		return p.getName().toUpperCase();
	}
}
package entities;

//Classe Product que representa um produto
public class Product {

//Atributo privado para armazenar o nome do produto
	private String name;

//Atributo privado para armazenar o preço do produto
	private Double price;

//Construtor para inicializar os atributos da classe
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

//Método para retornar o nome do produto
	public String getName() {
		return name;
	}

//Método para definir o nome do produto
	public void setName(String name) {
		this.name = name;
	}

//Método para retornar o preço do produto
	public Double getPrice() {
		return price;
	}

//Método para definir o preço do produto
	public void setPrice(Double price) {
		this.price = price;
	}
	
	public static String staticUpperCaseName(Product p) {
		return p.getName().toUpperCase();
	}
	
//Sobrescrita do método toString para exibir o nome e preço do produto de forma legível
	@Override
	public String toString() {
		return name + ", " + String.format("%.2f", price);
	}
}
package application;

import java.util.ArrayList;

// Classe principal do programa
public class Program {

	// Método main, ponto de entrada da aplicação
	public static void main(String[] args) {

		// Criação de uma lista de produtos
		List<Product> list = new ArrayList<>();

		// Adição de quatro produtos à lista
		list.add(new Product("Tv", 900.00));
		list.add(new Product("Mouse", 50.00));
		list.add(new Product("Tablet", 350.50));
		list.add(new Product("HD Case", 80.90));

		// Criação de uma nova lista com os nomes dos produtos em maiúsculas
		//Reference method com método estático
		List<String> names = list.stream().map(Product :: staticUpperCaseName).collect(Collectors.toList());

		// Impressão da lista de nomes na tela
		names.forEach(System.out::println);
	}
	/*
	 * A função map() em Java é utilizada para aplicar uma determinada operação em
	 * todos os elementos de uma coleção, como uma lista ou um array. Ela é
	 * fornecida pela interface Stream e pode ser utilizada com qualquer coleção que
	 * implemente a interface Collection. A função map() recebe como parâmetro uma
	 * função de transformação, que é aplicada a cada elemento da coleção. Ela
	 * retorna um novo Stream com os elementos transformados. 
	 */
}
Reference method com método não estático
package util;

import java.util.function.Function;

public class UpperCaseName implements Function<Product, String> {

	@Override
	public String apply(Product p) {
		return p.getName().toUpperCase();
	}
}
package entities;

//Classe Product que representa um produto
public class Product {

//Atributo privado para armazenar o nome do produto
	private String name;

//Atributo privado para armazenar o preço do produto
	private Double price;

//Construtor para inicializar os atributos da classe
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

//Método para retornar o nome do produto
	public String getName() {
		return name;
	}

//Método para definir o nome do produto
	public void setName(String name) {
		this.name = name;
	}

//Método para retornar o preço do produto
	public Double getPrice() {
		return price;
	}

//Método para definir o preço do produto
	public void setPrice(Double price) {
		this.price = price;
	}
	
	public static String staticUpperCaseName(Product p) {
		return p.getName().toUpperCase();
	}
	
	public String nonStaticUpperCaseName() {
		return name.toUpperCase();
	}
	

//Sobrescrita do método toString para exibir o nome e preço do produto de forma legível
	@Override
	public String toString() {
		return name + ", " + String.format("%.2f", price);
	}
}
package application;

import java.util.ArrayList;

// Classe principal do programa
public class Program {

	// Método main, ponto de entrada da aplicação
	public static void main(String[] args) {

		// Criação de uma lista de produtos
		List<Product> list = new ArrayList<>();

		// Adição de quatro produtos à lista
		list.add(new Product("Tv", 900.00));
		list.add(new Product("Mouse", 50.00));
		list.add(new Product("Tablet", 350.50));
		list.add(new Product("HD Case", 80.90));

		// Criação de uma nova lista com os nomes dos produtos em maiúsculas
		//Reference method com método não estático
		List<String> names = list.stream().map(Product :: nonStaticUpperCaseName).collect(Collectors.toList());

		// Impressão da lista de nomes na tela
		names.forEach(System.out::println);
	}
	/*
	 * A função map() em Java é utilizada para aplicar uma determinada operação em
	 * todos os elementos de uma coleção, como uma lista ou um array. Ela é
	 * fornecida pela interface Stream e pode ser utilizada com qualquer coleção que
	 * implemente a interface Collection. A função map() recebe como parâmetro uma
	 * função de transformação, que é aplicada a cada elemento da coleção. Ela
	 * retorna um novo Stream com os elementos transformados. 
	 */
}
Expressão lambda declarada
package util;

import java.util.function.Function;

public class UpperCaseName implements Function<Product, String> {

	@Override
	public String apply(Product p) {
		return p.getName().toUpperCase();
	}
}
package entities;

//Classe Product que representa um produto
public class Product {

//Atributo privado para armazenar o nome do produto
	private String name;

//Atributo privado para armazenar o preço do produto
	private Double price;

//Construtor para inicializar os atributos da classe
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

//Método para retornar o nome do produto
	public String getName() {
		return name;
	}

//Método para definir o nome do produto
	public void setName(String name) {
		this.name = name;
	}

//Método para retornar o preço do produto
	public Double getPrice() {
		return price;
	}

//Método para definir o preço do produto
	public void setPrice(Double price) {
		this.price = price;
	}
	
	public static String staticUpperCaseName(Product p) {
		return p.getName().toUpperCase();
	}
	
	public String nonStaticUpperCaseName() {
		return name.toUpperCase();
	}
	

//Sobrescrita do método toString para exibir o nome e preço do produto de forma legível
	@Override
	public String toString() {
		return name + ", " + String.format("%.2f", price);
	}
}
package application;

import java.util.ArrayList;

// Classe principal do programa
public class Program {

	// Método main, ponto de entrada da aplicação
	public static void main(String[] args) {

		// Criação de uma lista de produtos
		List<Product> list = new ArrayList<>();

		// Adição de quatro produtos à lista
		list.add(new Product("Tv", 900.00));
		list.add(new Product("Mouse", 50.00));
		list.add(new Product("Tablet", 350.50));
		list.add(new Product("HD Case", 80.90));
		
		Function<Product, String> func = p -> p.getName().toUpperCase();

		// Criação de uma nova lista com os nomes dos produtos em maiúsculas
		//Expressão lambda declarada
		List<String> names = list.stream().map(func).collect(Collectors.toList());

		// Impressão da lista de nomes na tela
		names.forEach(System.out::println);
	}
	/*
	 * A função map() em Java é utilizada para aplicar uma determinada operação em
	 * todos os elementos de uma coleção, como uma lista ou um array. Ela é
	 * fornecida pela interface Stream e pode ser utilizada com qualquer coleção que
	 * implemente a interface Collection. A função map() recebe como parâmetro uma
	 * função de transformação, que é aplicada a cada elemento da coleção. Ela
	 * retorna um novo Stream com os elementos transformados. 
	 */
}
Expressão lambda inline
package util;

import java.util.function.Function;

public class UpperCaseName implements Function<Product, String> {

	@Override
	public String apply(Product p) {
		return p.getName().toUpperCase();
	}
}
package entities;

//Classe Product que representa um produto
public class Product {

//Atributo privado para armazenar o nome do produto
	private String name;

//Atributo privado para armazenar o preço do produto
	private Double price;

//Construtor para inicializar os atributos da classe
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

//Método para retornar o nome do produto
	public String getName() {
		return name;
	}

//Método para definir o nome do produto
	public void setName(String name) {
		this.name = name;
	}

//Método para retornar o preço do produto
	public Double getPrice() {
		return price;
	}

//Método para definir o preço do produto
	public void setPrice(Double price) {
		this.price = price;
	}
	
	public static String staticUpperCaseName(Product p) {
		return p.getName().toUpperCase();
	}
	
	public String nonStaticUpperCaseName() {
		return name.toUpperCase();
	}
	

//Sobrescrita do método toString para exibir o nome e preço do produto de forma legível
	@Override
	public String toString() {
		return name + ", " + String.format("%.2f", price);
	}
}
package application;

import java.util.ArrayList;

// Classe principal do programa
public class Program {

	// Método main, ponto de entrada da aplicação
	public static void main(String[] args) {

		// Criação de uma lista de produtos
		List<Product> list = new ArrayList<>();

		// Adição de quatro produtos à lista
		list.add(new Product("Tv", 900.00));
		list.add(new Product("Mouse", 50.00));
		list.add(new Product("Tablet", 350.50));
		list.add(new Product("HD Case", 80.90));
		

		// Criação de uma nova lista com os nomes dos produtos em maiúsculas
		// Expressão lambda inline
		List<String> names = list.stream().map(p -> p.getName().toUpperCase()).collect(Collectors.toList());

		// Impressão da lista de nomes na tela
		names.forEach(System.out::println);
	}
	/*
	 * A função map() em Java é utilizada para aplicar uma determinada operação em
	 * todos os elementos de uma coleção, como uma lista ou um array. Ela é
	 * fornecida pela interface Stream e pode ser utilizada com qualquer coleção que
	 * implemente a interface Collection. A função map() recebe como parâmetro uma
	 * função de transformação, que é aplicada a cada elemento da coleção. Ela
	 * retorna um novo Stream com os elementos transformados. 
	 */
}
As funções em Java são objetos de primeira ordem porque elas podem ser tratadas como qualquer outro objeto em Java. Isso significa que elas podem ser atribuídas a variáveis, passadas como argumentos para outras funções e retornadas como resultado. Isso é possível graças ao suporte para funções anônimas, também conhecidas como closures, que permitem que as funções sejam criadas e executadas dinamicamente em tempo de execução. Isso torna o código mais flexível e fácil de manter.
Um exemplo simples de como as funções em Java podem ser tratadas como objetos é quando elas são atribuídas a uma variável:
// Declarando uma função que retorna o dobro de um número
Function<Integer, Integer> dobro = (num) -> 2 * num;

// Atribuindo a função à variável 'calculo'
Function<Integer, Integer> calculo = dobro;

// Utilizando a função através da variável 'calculo'
System.out.println(calculo.apply(5)); // imprime 10

Outro exemplo é quando as funções são passadas como argumentos para outras funções:
// Declarando uma função que aplica uma operação matemática em um número
void aplicarOperacao(int num, Function<Integer, Integer> operacao) {
    System.out.println(operacao.apply(num));
}

// Declarando uma função que retorna o dobro de um número
Function<Integer, Integer> dobro = (num) -> 2 * num;

// Passando a função 'dobro' como argumento para a função 'aplicarOperacao'
aplicarOperacao(5, dobro); // imprime 10

E finalmente, as funções também podem ser retornadas como resultado de outras funções:
Function<Integer, Integer> operacaoSelecionada(String tipoOperacao) {
    if (tipoOperacao.equals("dobro")) {
        return (num) -> 2 * num;
    } else if (tipoOperacao.equals("quadrado")) {
        return (num) -> num * num;
    } else {
        return null;
    }
}

// Obtendo a função correspondente à operação selecionada
Function<Integer, Integer> operacao = operacaoSelecionada("dobro");

// Utilizando a função retornada
System.out.println(operacao.apply(5)); // imprime 10

Cada exemplo mostra como as funções em Java podem ser tratadas como objetos de primeira ordem e como isso pode ser usado para tornar o código mais flexível e reutilizável.
 
 
 
 
package model.services;

import java.util.List;

public class ProductService {

	public double filteredSum(List<Product> list) {
		double sum = 0.0;
		for (Product p : list) {
			if (p.getName().charAt(0) == 'T') {
				sum += p.getPrice();
			}
		}
		return sum;
	}
	/*
	 * Observe que, se o critério mudar, a classe precisará ser alterada.
	 * fereindo dessa forma o princípio de que a classe deve estar fechada
	 * para alteração.
	 * O PRÓXIMO CÓDIGO MOSTRA COMO RESOLVER ESTE PROBLEMA.
	 */
}
package model.entities;

public class Product {

	private String name;
	private Double price;
	
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Double getPrice() {
		return price;
	}
 
	public void setPrice(Double price) {
		this.price = price;
	}

	@Override
	public String toString() {
		return name + ", " + String.format("%.2f", price);
	}
}
package application;

import java.util.ArrayList;

public class Program {
	
	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		List<Product> list = new ArrayList<>();

		list.add(new Product("Tv", 900.00));
		list.add(new Product("Mouse", 50.00));
		list.add(new Product("Tablet", 350.50));
		list.add(new Product("HD Case", 80.90));

		ProductService ps = new ProductService();
		
		double sum = ps.filteredSum(list);
 
		System.out.println("Sum = " + String.format("%.2f", sum));
	}
}
Criando funções que recebem funções como argumento
//declaração do pacote do código
package model.services; 

//importa a classe List do pacote java.util
import java.util.List; 

//declaração da classe ProductService
public class ProductService { 
	
	/**
	 * Observe que o predicado que antes estava dentro da condição if agora
	 * está dentro do parâmetro da função, como predicado genérico.
	 */
	
	//declaração do método filteredSum que recebe uma lista de produtos e um objeto criteria que implementa a interface Predicate
	public double filteredSum(List<Product> list, Predicate<Product> criteria) { 
		
		//declaração e inicialização de uma variável sum com valor 0
		double sum = 0.0; 
		
		//percorre a lista de produtos
		for (Product p : list) { 
			
			//verifica se o produto p satisfaz o predicado passado como parâmetro
			if (criteria.test(p)) { 
				
				//se o produto satisfaz o predicado, o preço dele é somado à variável sum
				sum += p.getPrice(); 
			}
		}
		
		//retorna o valor total da soma
		return sum; 
	}
}
package model.entities;

public class Product {

	//declaração de variável de nome do produto
	private String name;
	//declaração de variável de preço do produto
	private Double price;
	
	//Construtor que inicializa as variáveis name e price
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

	//Retorna o nome do produto
	public String getName() {
		return name;
	}

	//Atribui um nome ao produto
	public void setName(String name) {
		this.name = name;
	}

	//Retorna o preço do produto
	public Double getPrice() {
		return price;
	}
 
	//Atribui um preço ao produto
	public void setPrice(Double price) {
		this.price = price;
	}

	//Sobrescreve o método toString() da classe Object
	@Override
	public String toString() {
		return name + ", " + String.format("%.2f", price);
	}
}
package application;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import model.entities.Product;
import model.services.ProductService;

public class Program {
	
	public static void main(String[] args) {

		//Definindo a localidade padrão para o Estados Unidos
		Locale.setDefault(Locale.US);
		
		//Criando uma lista de produtos
		List<Product> list = new ArrayList<>();

		//Adicionando produtos na lista
		list.add(new Product("Tv", 900.00));
		list.add(new Product("Mouse", 50.00));
		list.add(new Product("Tablet", 350.50));
		list.add(new Product("HD Case", 80.90));

		ProductService ps = new ProductService();
		
		//Calculando a soma dos produtos cujos nomes começam com "T"
		/*
		 * Dessa forma, temos uma função muito mais flexível e cujas condições
		 * de comparação podem ser passadas diretamete na classe principal e não
		 * na Classe ProductService.
		 */
		double sum = ps.filteredSum(list, p -> p.getName().charAt(0) == 'T');

		//Imprimindo o resultado
		System.out.println("Sum = " + String.format("%.2f", sum));
	}
}
 


===================================================================================================================== 
  Stream
 
 
 
package application;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

public class Program {

    public static void main(String[] args) {
        // Cria uma lista de Integer
        List<Integer> list = Arrays.asList(3, 4, 5, 10, 7);
        
        // Cria um stream a partir da lista
        Stream<Integer> st1 = list.stream();
        
        // Imprime os elementos do stream
        System.out.println(Arrays.toString(st1.toArray()));
        
        // Cria um stream de String
        Stream<String> st2 = Stream.of("Maria", "Alex", "Bob");
        
        // Imprime os elementos do stream
        System.out.println(Arrays.toString(st2.toArray()));
        
        // Cria um stream iterativo a partir da função de gerar números pares
        Stream<Integer> st3 = Stream.iterate(0, x -> x + 2);
        
        // Limitando a 10 elementos e imprimindo
        System.out.println(Arrays.toString(st3.limit(10).toArray()));
        
        // Cria um stream iterativo com a sequencia de Fibonacci
        Stream<Long> st4 = Stream.iterate(new long[] { 0L, 1L }, p -> new long[] { p[1], p[0] + p[1] }).map(p -> p[0]);
        
        // Limitando a 10 elementos e imprimindo
        System.out.println(Arrays.toString(st4.limit(10).toArray()));
    }
}
 


===================================================================================================================== 
  Pipeline (demo)
 
package application;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Program {

public static void main(String[] args) {
    //Cria uma lista de integers
    List<Integer> list = Arrays.asList(3, 4, 5, 10, 7);
    //Cria um Stream a partir da lista, e aplica a operação de mapeamento multiplicando cada elemento por 10
    Stream<Integer> st1 = list.stream().map(x -> x * 10);
    //Imprime o stream convertido em array
    System.out.println(Arrays.toString(st1.toArray()));
    //Usa o método reduce para somar todos os elementos da lista.
    int sum = list.stream().reduce(0, (x, y) -> x + y);
    System.out.println("Sum = " + sum);
    //Cria uma nova lista com os elementos pares da lista original, mapeando cada elemento multiplicando por 10
    List<Integer> newList = list.stream().filter(x -> x % 2 == 0).map(x -> x * 10).collect(Collectors.toList());
    //Imprime a nova lista convertida em array
    System.out.println(Arrays.toString(newList.toArray()));
}
}
 


===================================================================================================================== 
  Exercício resolvido - filter, sorted, map, reduce
 
 
package entities;

//Classe que representa um produto com seu nome e preço
public class Product {

	// Atributos do produto
	private String name;
	private Double price;

	// Construtor da classe, recebe o nome e o preço do produto
	public Product(String name, Double price) {
		this.name = name;
		this.price = price;
	}

	// Getter para o nome do produto
	public String getName() {
		return name;
	}

	// Setter para o nome do produto
	public void setName(String name) {
		this.name = name;
	}

	// Getter para o preço do produto
	public Double getPrice() {
		return price;
	}

	// Setter para o preço do produto
	public void setPrice(Double price) {
		this.price = price;
	}

	// Sobrescrita do método toString para retornar o nome e o preço do produto
	@Override
	public String toString() {
		return name + ", " + String.format("%.2f", price);
	}
}
package application;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Locale;
import java.util.Scanner;
import java.util.stream.Collectors;

import entities.Product;

public class Program {

	public static void main(String[] args) {

		// Define o formato de localização como EUA
		Locale.setDefault(Locale.US);
		// Inicializa o scanner para ler o caminho do arquivo
		Scanner sc = new Scanner(System.in);

		System.out.print("Enter full file path: ");
		String path = sc.nextLine();

		try (BufferedReader br = new BufferedReader(new FileReader(path))) {

			List<Product> list = new ArrayList<>();

			// Le a primeira linha do arquivo
			String line = br.readLine();
			// Enquanto houver linhas para serem lidas
			while (line != null) {
				// Separa os campos da linha pelo caractere ','
				String[] fields = line.split(",");
				// Adiciona um novo produto na lista com o nome e preço dos campos
				list.add(new Product(fields[0], Double.parseDouble(fields[1])));
				// Le a próxima linha
				line = br.readLine();
			}

			// Calcula a média dos preços dos produtos
			double avg = list.stream().map(p -> p.getPrice()).reduce(0.0, (x, y) -> x + y) / list.size();

			System.out.println("Average price: " + String.format("%.2f", avg));

			// Define um comparador para ordenar os nomes dos produtos
			Comparator<String> comp = (s1, s2) -> s1.toUpperCase().compareTo(s2.toUpperCase());

			// Filtra os produtos cujo preço é menor que a média, mapeia seus nomes e os
			// ordena de forma reversa
			List<String> names = list.stream().filter(p -> p.getPrice() < avg).map(p -> p.getName())
					.sorted(comp.reversed()).collect(Collectors.toList());

			// imprime cada nome do produto
			names.forEach(System.out::println);

		} catch (IOException e) {
			System.out.println("Error: " + e.getMessage());
		}
		sc.close();
	}
}
 


===================================================================================================================== 
  Exercício de fixação
 
 
package entities;

public class Employee {

// Variáveis de instância para armazenar informações do funcionário
	private String name;
	private String email;
	private Double salary;

// Construtor para inicializar as informações do funcionário
	public Employee(String name, String email, Double salary) {
		this.name = name;
		this.email = email;
		this.salary = salary;
	}

// Métodos Getter e Setter para acessar e modificar as informações do funcionário
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	public Double getSalary() {
		return salary;
	}

	public void setSalary(Double salary) {
		this.salary = salary;
	}
}
package application;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Scanner;
import java.util.stream.Collectors;

import entities.Employee;

public class Program {

	public static void main(String[] args) {

		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);

		// Pede o caminho completo do arquivo
		System.out.print("Enter full file path: ");
		String path = sc.nextLine();

		try (BufferedReader br = new BufferedReader(new FileReader(path))) {

			List<Employee> list = new ArrayList<>();

			// Lê cada linha do arquivo
			String line = br.readLine();
			while (line != null) {
				String[] fields = line.split(",");
				list.add(new Employee(fields[0], fields[1], Double.parseDouble(fields[2])));
				line = br.readLine();
			}

			// Pede o salário
			System.out.print("Enter salary: ");
			double salary = sc.nextDouble();

			// Filtra os funcionários com salário maior que o especificado, ordena os
			// e-mails e os armazena numa lista
			List<String> emails = list.stream().filter(x -> x.getSalary() > salary).map(x -> x.getEmail()).sorted()
					.collect(Collectors.toList());

			// Imprime os e-mails
			System.out.println("Email of people whose salary is more than " + String.format("%.2f", salary) + ":");
			emails.forEach(System.out::println);

			// Filtra os funcionários cujo nome começa com 'M', soma os salários e imprime o
			// resultado
			double sum = list.stream().filter(x -> x.getName().charAt(0) == 'M').map(x -> x.getSalary()).reduce(0.0,
					(x, y) -> x + y);

			System.out.println("Sum of salary from people whose name starts with 'M': " + String.format("%.2f", sum));

		} catch (IOException e) {
			System.out.println("Error: " + e.getMessage());
		}
		sc.close();
	}
}
 


===================================================================================================================== 
  Acesso a banco de dados com JDBC
 
 
Os três códigos a seguir são partes de uma aplicação Java que tem como objetivo conectar-se a um banco de dados MySQL e realizar operações nele.

O primeiro código é a classe DB, que é responsável por gerenciar a conexão com o banco de dados. A classe possui dois métodos estáticos: getConnection e closeConnection. O método getConnection é responsável por obter uma conexão com o banco de dados caso ainda não exista uma conexão ativa, e retorná-la. O método closeConnection é responsável por fechar a conexão com o banco de dados, caso ela exista. Além disso, a classe também possui o método loadProperties que carrega as informações de configuração do banco de dados a partir de um arquivo externo.

O segundo código é um arquivo de propriedades que contém as informações de configuração necessárias para a conexão com o banco de dados. Ele especifica o nome de usuário, senha, URL de conexão e configuração para não utilizar SSL (segurança de conexão).

O terceiro código é a classe Program, que é a classe principal da aplicação. Ela possui o método main que é o ponto de entrada da aplicação. O método obtém uma conexão com o banco de dados através da chamada ao método getConnection da classe DB, e logo em seguida fecha a conexão com o banco de dados através da chamada ao método closeConnection da mesma classe.

Em resumo, estes três códigos juntos formam uma aplicação Java que permite conectar-se a um banco de dados MySQL e realizar operações nele, gerenciando de maneira segura e eficiente as conexões com o banco de dados.
// Classe para gerenciamento de conexão com o banco de dados
package db;

import java.io.FileInputStream;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Properties;

public class DB {

	// Variável para armazenar a conexão com o banco de dados
	private static Connection conn = null;

	// Método para obter a conexão com o banco de dados
	public static Connection getConnection() {
		if (conn == null) { // Verifica se a conexão já foi estabelecida
			try {
				// Carrega as propriedades do arquivo "db.properties"
				Properties props = loadProperties();
				// Obtém a URL de conexão a partir das propriedades
				String url = props.getProperty("dburl");
				// Estabelece a conexão com o banco de dados
				conn = DriverManager.getConnection(url, props);
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha na conexão
				throw new DbException(e.getMessage());
			}
		}
		return conn;
	}

	// Método para fechar a conexão com o banco de dados
	public static void closeConnection() {
		if (conn != null) { // Verifica se a conexão já foi estabelecida
			try {
				conn.close(); // Fecha a conexão com o banco de dados
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha ao fechar a conexão
				throw new DbException(e.getMessage());
			}
		}
	}

	// Método para carregar as propriedades do arquivo "db.properties"
	private static Properties loadProperties() {
		try (FileInputStream fs = new FileInputStream("db.properties")) {
			Properties props = new Properties();
			props.load(fs); // Carrega as propriedades do arquivo
			return props;
		}

		// Tratamento de exceção em caso de falha ao carregar o arquivo de propriedades
		catch (IOException e) {
			throw new DbException(e.getMessage());
		}
	}
}

// Arquivo de propriedades para conexão com o banco de dados MySQL

// Nome de usuário para acessar o banco de dados
user=root

// Senha de acesso ao banco de dados
password=senha@123

// URL de conexão com o banco de dados
dburl=jdbc:mysql://localhost:3306/coursejdbc

// Configuração para não utilizar o SSL (segurança de conexão)
useSSL=false

// Classe principal da aplicação

package application;

import java.sql.Connection;

// Importa a classe de conexão com o banco de dados
import db.DB;

public class Program {

	public static void main(String[] args) {
		// Obtém uma conexão com o banco de dados
		Connection conn = DB.getConnection();
		
		// Fecha a conexão com o banco de dados
		DB.closeConnection();
	}

}

 
 


===================================================================================================================== 
  recuperar dados
Demo: recuperar dados: Este é um exemplo prático de como recuperar dados de uma base de dados. Aqui, o objetivo é recuperar os departamentos armazenados em uma base de dados.

Script SQL: material de apoio: O script SQL é um arquivo de texto que contém comandos SQL para criar e configurar uma base de dados. Este script pode ser usado como material de apoio para criar a base de dados necessária para a demonstração.

Código fonte: https://github.com/acenelio/jdbc2: Este é um repositório no Github que contém o código fonte de um projeto que utiliza JDBC para recuperar dados de uma base de dados. Este código pode ser usado como base para o desenvolvimento de aplicações que precisem recuperar dados de uma base de dados.

API:
 Statement: A API Statement é uma interface que representa uma instrução SQL que é enviada para o banco de dados. Ela pode ser usada para executar comandos SQL que não retornam dados (como INSERT, UPDATE, DELETE).
 ResultSet: A API ResultSet é uma interface que representa um conjunto de resultados retornados por uma consulta SQL. Ele contém dados armazenados em forma de tabela.

Os métodos first(), beforeFirst(), next() e absolute(int) do ResultSet são usados para navegar pelos dados retornados por uma consulta SQL. O método first() move para a primeira posição de dados, se houver. O método beforeFirst() move para a posição 0, antes da primeira posição de dados. O método next() move para a próxima posição de dados e retorna false se já estiver na última posição. O método absolute(int) move para a posição dada, lembrando que dados reais começam na posição 1.
// Classe para gerenciamento de conexão com o banco de dados
package db;

import java.io.FileInputStream;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

public class DB {

	// Variável para armazenar a conexão com o banco de dados
	private static Connection conn = null;

	// Método para obter a conexão com o banco de dados
	public static Connection getConnection() {
		if (conn == null) { // Verifica se a conexão já foi estabelecida
			try {
				// Carrega as propriedades do arquivo "db.properties"
				Properties props = loadProperties();
				// Obtém a URL de conexão a partir das propriedades
				String url = props.getProperty("dburl");
				// Estabelece a conexão com o banco de dados
				conn = DriverManager.getConnection(url, props);
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha na conexão
				throw new DbException(e.getMessage());
			}
		}
		return conn;
	}

	// Método para fechar a conexão com o banco de dados
	public static void closeConnection() {
		if (conn != null) { // Verifica se a conexão já foi estabelecida
			try {
				conn.close(); // Fecha a conexão com o banco de dados
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha ao fechar a conexão
				throw new DbException(e.getMessage());
			}
		}
	}

	// Método para carregar as propriedades do arquivo "db.properties"
	private static Properties loadProperties() {
		try (FileInputStream fs = new FileInputStream("db.properties")) {
			Properties props = new Properties();
			props.load(fs); // Carrega as propriedades do arquivo
			return props;
		}

		// Tratamento de exceção em caso de falha ao carregar o arquivo de propriedades
		catch (IOException e) {
			throw new DbException(e.getMessage());
		}
	}

	// Método para fechar o statement
	public static void closeStatement(Statement st) {
		if (st != null) { // Verifica se o statement já foi aberto
			try {
				st.close(); // Fecha o statement
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha ao fechar o statement
				throw new DbException(e.getMessage());
			}
		}
	}

	// Método para fechar o result set
	public static void closeResultSet(ResultSet rs) {
		if (rs != null) { // Verifica se o result set já foi aberto
			try {
				rs.close(); // Fecha o result set
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha ao fechar o result set
				throw new DbException(e.getMessage());
			}
		}
	}
}
Esta classe "DB" tem como objetivo gerenciar a conexão com o banco de dados da aplicação. A seguir, explicarei cada funcionalidade deste código e sua importância no contexto da aplicação.

Variável "conn"
É uma variável estática que armazena a conexão com o banco de dados. Ela é usada pelo método "getConnection()" para verificar se a conexão já foi estabelecida.
Método "getConnection()"
Este método é responsável por estabelecer a conexão com o banco de dados. Primeiro, ele verifica se a conexão já foi estabelecida através da variável "conn". Se a conexão ainda não foi estabelecida, o método carrega as propriedades do arquivo "db.properties", obtém a URL de conexão e estabelece a conexão com o banco de dados. Em caso de falha na conexão, uma exceção personalizada é lançada.
Método "closeConnection()"
Este método é responsável por fechar a conexão com o banco de dados. Ele verifica se a conexão já foi estabelecida através da variável "conn". Se a conexão já foi estabelecida, o método fecha a conexão. Em caso de falha ao fechar a conexão, uma exceção personalizada é lançada.
Método "loadProperties()"
Este método é responsável por carregar as propriedades do arquivo "db.properties". Ele lê o arquivo e carrega as propriedades para um objeto "Properties". Em caso de falha ao ler o arquivo, uma exceção personalizada é lançada.
Método "closeStatement(Statement st)"
Este método é responsável por fechar um objeto "Statement". Ele verifica se o objeto "Statement" é nulo e, caso não seja, fecha o objeto. Em caso de falha ao fechar o objeto "Statement", uma exceção personalizada é lançada.
Método "closeResultSet(ResultSet rs)"
Este método é responsável por fechar um objeto "ResultSet". Ele verifica se o objeto "ResultSet" é nulo e, caso não seja, fecha o objeto. Em caso de falha ao fechar o objeto "ResultSet", uma exceção personalizada é lançada.
// Classe principal da aplicação

package application;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import db.DB;

public class Program {

	public static void main(String[] args) {
		// Variáveis para conexão com banco de dados
		Connection conn = null;
		Statement st = null;
		ResultSet rs = null;

		// Tenta estabelecer conexão com o banco de dados
		try {
			conn = DB.getConnection();

			// Cria um objeto statement a partir da conexão
			st = conn.createStatement();

			// Executa uma consulta no banco de dados e armazena o resultado em um objeto
			// ResultSet
			rs = st.executeQuery("select * from department");

			// Loop para percorrer todas as linhas retornadas na consulta
			while (rs.next()) {
				// Imprime o Id e o Nome de cada departamento
				System.out.println(rs.getInt("Id") + ", " + rs.getString("Name"));
			}
		}
		// Captura possíveis exceções geradas pelo banco de dados
		catch (SQLException e) {
			e.printStackTrace();
		}

		// Bloco finally para fechar as conexões com o banco de dados independentemente
		// da execução
		finally {
			DB.closeResultSet(rs);
			DB.closeStatement(st);
			DB.closeConnection();
		}
	}
}
Importações:
java.sql.Connection: é uma interface que representa uma conexão com um banco de dados.
java.sql.ResultSet: é uma interface que representa o resultado de uma consulta ao banco de dados.
java.sql.Statement: é uma interface que representa uma instrução SQL.
db.DB: é uma classe que oferece métodos para conexão com o banco de dados.
Classe Program:
Método main: é o método principal da aplicação. É a partir dele que tudo começa a funcionar.
Variáveis:
Connection conn: variável que armazenará a conexão com o banco de dados.
Statement st: variável que armazenará a instrução SQL.
ResultSet rs: variável que armazenará o resultado da consulta ao banco de dados.
Bloco try-catch-finally:
O bloco try-catch-finally é responsável por lidar com possíveis exceções que possam ocorrer durante a execução do código.
No bloco try, é estabelecida a conexão com o banco de dados com o método getConnection() da classe DB.
É criada a instrução SQL com o método createStatement() da variável conn.
É executada a consulta ao banco de dados com o método executeQuery() da variável st, passando como argumento a string "select * from department".
O resultado da consulta é armazenado na variável rs.
No bloco while, é percorrido o resultado da consulta com o método next() da variável rs e é impresso na tela o valor dos campos Id e Name de cada linha retornada pela consulta.
No bloco catch, é tratada a exceção do tipo SQLException, imprimindo a pilha de chamadas da exceção com o método printStackTrace().
No bloco finally, é fechado o resultado da consulta, a instrução SQL e a conexão com o banco de dados com os métodos closeResultSet(), closeStatement() e closeConnection() da classe DB, respectivamente.
A importância destas funcionalidades no contexto da aplicação é permitir que seja feita uma consulta ao banco de dados e sejam exibidos os resultados na tela, de forma segura e controlada, tratando possíveis exceções.
I. Classe Program
1.1. A classe Program é a classe principal da aplicação.
1.2. Ela importa a classe "DB" e a interface "Connection" para conexão com o banco de dados.
1.3. O método "main" é responsável por criar a conexão com o banco de dados, realizar uma consulta na tabela "department" e imprimir os resultados.
1.4. O método "DB.getConnection()" é usado para estabelecer a conexão com o banco de dados.
1.5. A cláusula try-catch-finally é usada para tratar possíveis erros na conexão e na consulta ao banco de dados.
1.6. Os métodos "DB.closeResultSet(rs)", "DB.closeStatement(st)" e "DB.closeConnection()" são usados para fechar os recursos de maneira segura.

II. Classe DB
2.1. A classe "DB" é responsável por estabelecer a conexão com o banco de dados.
2.2. Ela contém métodos estáticos para fechar os recursos de maneira segura.


Classe DB
I. Método getConnection
I.1 Este método é responsável por estabelecer a conexão com o banco de dados.
I.2 Ele utiliza as informações de usuário e senha definidas no arquivo "db.properties" para se conectar ao banco.
I.3 Ele retorna uma instância da interface "Connection" com a conexão estabelecida.

II. Método closeResultSet
II.1 Este método é responsável por fechar o objeto "ResultSet", que é utilizado para armazenar os resultados de uma consulta SQL.
II.2 Ele recebe como parâmetro um objeto "ResultSet" e verifica se ele não é nulo antes de fechá-lo.
II.3 Este método é chamado no bloco finally da classe Program para garantir que o objeto "ResultSet" será fechado corretamente.

III. Método closeStatement
III.1 Este método é responsável por fechar o objeto "Statement", que é utilizado para executar comandos SQL.
III.2 Ele recebe como parâmetro um objeto "Statement" e verifica se ele não é nulo antes de fechá-lo.
III.3 Este método é chamado no bloco finally da classe Program para garantir que o objeto "Statement" será fechado corretamente.

IV. Método closeConnection
IV.1 Este método é responsável por fechar a conexão com o banco de dados.
IV.2 Ele recebe como parâmetro uma instância da interface "Connection" e verifica se ela não é nula antes de fechá-la.
IV.3 Este método é chamado no bloco finally da classe Program para garantir que a conexão será fechada corretamente.
 


===================================================================================================================== 
  inserir dados
[Acesso a dados com JDBC](https://drive.google.com/file/d/1rOt7dTLBXQv74aQBW8UiWI710N0k4pRN/view?usp=share_link)
Classe para gerenciamento de conexão com o banco de dados

Este é o código fonte de uma classe chamada "DB", destinada a gerenciar a conexão com o banco de dados. A classe contém métodos para estabelecer, fechar e obter a conexão com o banco de dados, bem como métodos para fechar o Statement e o ResultSet. A conexão com o banco de dados é armazenada na variável "conn".

A classe também contém um método "loadProperties", que carrega as propriedades de conexão com o banco de dados a partir de um arquivo "db.properties". O arquivo de propriedades contém informações como URL de conexão, nome de usuário e senha.

Em caso de falhas na conexão, fechamento de statements ou result sets, ou na leitura do arquivo de propriedades, a classe lança uma exceção personalizada "DbException".
// Classe para gerenciamento de conexão com o banco de dados
package db;

import java.io.FileInputStream;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

public class DB {

	// Variável para armazenar a conexão com o banco de dados
	private static Connection conn = null;

	// Método para obter a conexão com o banco de dados
	public static Connection getConnection() {
		if (conn == null) { // Verifica se a conexão já foi estabelecida
			try {
				// Carrega as propriedades do arquivo "db.properties"
				Properties props = loadProperties();
				// Obtém a URL de conexão a partir das propriedades
				String url = props.getProperty("dburl");
				// Estabelece a conexão com o banco de dados
				conn = DriverManager.getConnection(url, props);
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha na conexão
				throw new DbException(e.getMessage());
			}
		}
		return conn;
	}

	// Método para fechar a conexão com o banco de dados
	public static void closeConnection() {
		if (conn != null) { // Verifica se a conexão já foi estabelecida
			try {
				conn.close(); // Fecha a conexão com o banco de dados
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha ao fechar a conexão
				throw new DbException(e.getMessage());
			}
		}
	}

	// Método para carregar as propriedades do arquivo "db.properties"
	private static Properties loadProperties() {
		try (FileInputStream fs = new FileInputStream("db.properties")) {
			Properties props = new Properties();
			props.load(fs); // Carrega as propriedades do arquivo
			return props;
		}

		// Tratamento de exceção em caso de falha ao carregar o arquivo de propriedades
		catch (IOException e) {
			throw new DbException(e.getMessage());
		}
	}

	// Método para fechar o statement
	public static void closeStatement(Statement st) {
		if (st != null) { // Verifica se o statement já foi aberto
			try {
				st.close(); // Fecha o statement
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha ao fechar o statement
				throw new DbException(e.getMessage());
			}
		}
	}

	// Método para fechar o result set
	public static void closeResultSet(ResultSet rs) {
		if (rs != null) { // Verifica se o result set já foi aberto
			try {
				rs.close(); // Fecha o result set
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha ao fechar o result set
				throw new DbException(e.getMessage());
			}
		}
	}
}
Esta classe é uma exceção personalizada para ser usada no gerenciamento de conexão com o banco de dados. É uma subclasse de RuntimeException e aceita uma mensagem como parâmetro no construtor. Quando lançada, essa exceção armazena a mensagem passada e pode ser capturada em uma cláusula catch para tratar o erro apropriadamente.
package db;

public class DbException extends RuntimeException {

	private static final long serialVersionUID = 1L;
	
	public DbException(String msg) {
		super(msg);
	}
}
Este arquivo contém as informações necessárias para se conectar a um banco de dados MySQL. Ele inclui o nome de usuário (user) e a senha (password) para acessar o banco de dados, bem como a URL de conexão (dburl) que identifica onde o banco de dados está localizado. Também há uma configuração opcional (useSSL) para não utilizar o SSL (segurança de conexão), o que pode ser necessário em determinados ambientes de desenvolvimento.
// Arquivo de propriedades para conexão com o banco de dados MySQL

// Nome de usuário para acessar o banco de dados
user=root

// Senha de acesso ao banco de dados
password=senha@123

// URL de conexão com o banco de dados
dburl=jdbc:mysql://localhost:3306/coursejdbc

// Configuração para não utilizar o SSL (segurança de conexão)
useSSL=false
Este é o código de uma classe principal de uma aplicação Java que usa o JDBC para se conectar a um banco de dados MySQL e inserir dados em uma tabela. O arquivo de propriedades que contém as informações de conexão com o banco de dados (nome de usuário, senha e URL de conexão) é lido e usado para criar uma conexão com o banco de dados. Em seguida, é criado um objeto PreparedStatement que contém uma instrução SQL para inserir dados em uma tabela "seller". Os valores dos parâmetros da instrução são definidos usando o método setString e setDate e, em seguida, a instrução é executada usando o método executeUpdate. Se a inserção for bem-sucedida, o id gerado pelo banco de dados é recuperado e impresso na tela. Em caso de erro na conexão ou inserção, o stack trace é impresso na tela. Por fim, todos os recursos são fechados de maneira segura.
// Classe principal da aplicação

package application;

//Importações das bibliotecas necessárias para trabalhar com JDBC

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.ParseException;
import java.text.SimpleDateFormat;

//Importação da classe DB que trata a conexão com o banco de dados

import db.DB;

public class Program {

	public static void main(String[] args) {

		// Criação do objeto SimpleDateFormat para formatar a data
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");

		// Variáveis que serão usadas na conexão com o banco de dados
		Connection conn = null;
		PreparedStatement st = null;

		try {
			// Obtém a conexão com o banco de dados
			conn = DB.getConnection();

			// Criação do objeto PreparedStatement para realizar a inserção no banco de
			// dados
			st = conn.prepareStatement("INSERT INTO seller" + "(Name, Email, BirthDate, BaseSalary, DepartmentId) "
					+ "VALUES" + "(?, ?, ?, ?, ?)", Statement.RETURN_GENERATED_KEYS);

			// Define os valores dos parâmetros da instrução SQL.
			st.setString(1, "Carl Purple");
			st.setString(2, "carl@gmail.com");
			st.setDate(3, new java.sql.Date(sdf.parse("22/04/1985").getTime()));
			st.setDouble(4, 3000.0);
			st.setInt(5, 4);
			
			

			// ******SE QUISER INSERIR MAIS DE UM ITEM*******
			/*
			 * st = conn.prepareStatement(
			 * "insert into department (Name) values ('D1'),('D2')",
			 * Statement.RETURN_GENERATED_KEYS);
			 */
			
			

			// Executa a instrução SQL e armazena o número de linhas afetadas.
			int rowsAffected = st.executeUpdate();

			// Se houver pelo menos uma linha afetada, recupera o valor da chave gerada pelo
			// banco de dados.
			if (rowsAffected > 0) {
				ResultSet rs = st.getGeneratedKeys();
				// Impressão do id gerado na inserção
				while (rs.next()) {
					int id = rs.getInt(1);
					System.out.println("Done! Id = " + id);
				}
			} else {
				System.out.println("No rows affected!");
			}
		} catch (SQLException e) {
			// Tratamento de erro na conexão ou na inserção
			e.printStackTrace();
		} catch (ParseException e) {
			// Tratamento de erro na conversão da data
			e.printStackTrace();
		} finally {
			// Fechamento dos recursos de maneira segura
			DB.closeStatement(st);
			DB.closeConnection();
		}
	}
}
 


===================================================================================================================== 
  atualizar dados

// Classe para gerenciamento de conexão com o banco de dados
package db;

import java.io.FileInputStream;

public class DB {

	// Variável para armazenar a conexão com o banco de dados
	private static Connection conn = null;

	// Método para obter a conexão com o banco de dados
	public static Connection getConnection() {
		if (conn == null) { // Verifica se a conexão já foi estabelecida
			try {
				// Carrega as propriedades do arquivo "db.properties"
				Properties props = loadProperties();
				// Obtém a URL de conexão a partir das propriedades
				String url = props.getProperty("dburl");
				// Estabelece a conexão com o banco de dados
				conn = DriverManager.getConnection(url, props);
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha na conexão
				throw new DbException(e.getMessage());
			}
		}
		return conn;
	}

	// Método para fechar a conexão com o banco de dados
	public static void closeConnection() {
		if (conn != null) { // Verifica se a conexão já foi estabelecida
			try {
				conn.close(); // Fecha a conexão com o banco de dados
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha ao fechar a conexão
				throw new DbException(e.getMessage());
			}
		}
	}

	// Método para carregar as propriedades do arquivo "db.properties"
	private static Properties loadProperties() {
		try (FileInputStream fs = new FileInputStream("db.properties")) {
			Properties props = new Properties();
			props.load(fs); // Carrega as propriedades do arquivo
			return props;
		}

		// Tratamento de exceção em caso de falha ao carregar o arquivo de propriedades
		catch (IOException e) {
			throw new DbException(e.getMessage());
		}
	}

	// Método para fechar o statement
	public static void closeStatement(Statement st) {
		if (st != null) { // Verifica se o statement já foi aberto
			try {
				st.close(); // Fecha o statement
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha ao fechar o statement
				throw new DbException(e.getMessage());
			}
		}
	}

	// Método para fechar o result set
	public static void closeResultSet(ResultSet rs) {
		if (rs != null) { // Verifica se o result set já foi aberto
			try {
				rs.close(); // Fecha o result set
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha ao fechar o result set
				throw new DbException(e.getMessage());
			}
		}
	}
}
package db;

//Importa a classe base para exceções
import java.lang.RuntimeException;

public class DbException extends RuntimeException {

	private static final long serialVersionUID = 1L;

//Construtor que recebe uma mensagem para a exceção
	public DbException(String msg) {
		// Chama o construtor da classe base, passando a mensagem
		super(msg);
	}
}
Esta classe de exceção, chamada DbException, é utilizada para representar erros ocorridos durante o acesso ao banco de dados na aplicação. Ela estende a classe RuntimeException, o que significa que ela é uma exceção não checada, ou seja, não é necessário capturá-la explicitamente no código, a menos que se queira tratar de maneira específica.

Ao utilizar uma classe de exceção específica para representar erros no acesso ao banco de dados, é possível fornecer mensagens de erro mais claras e personalizadas, além de facilitar a depuração e correção de problemas. A classe DbException permite também que a aplicação centralize a tratativa de erros de acesso ao banco de dados, tornando o código mais claro e organizado.

Em resumo, a classe DbException é importante para a aplicação pois permite uma melhor tratativa de erros e melhora a clareza e organização do código.
// Arquivo de propriedades para conexão com o banco de dados MySQL

// Nome de usuário para acessar o banco de dados
user=root

// Senha de acesso ao banco de dados
password=senha@123

// URL de conexão com o banco de dados
dburl=jdbc:mysql://localhost:3306/coursejdbc

// Configuração para não utilizar o SSL (segurança de conexão)
useSSL=false
package application;

//Importa as classes necessárias para trabalhar com o banco de dados
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

//Importa a classe de acesso ao banco de dados
import db.DB;

public class Program {

	public static void main(String[] args) {
		// Cria variáveis para a conexão com o banco de dados e a declaração SQL
		Connection conn = null;
		PreparedStatement st = null;
		try {
			// Obtém a conexão com o banco de dados
			conn = DB.getConnection();

			// Cria a declaração SQL para atualizar os salários dos vendedores
			st = conn.prepareStatement(
					"UPDATE seller " + "SET BaseSalary = BaseSalary + ? " + "WHERE " + "(DepartmentId = ?)");

			// Define o valor a ser acrescido aos salários
			st.setDouble(1, 200.0);
			// Define o ID do departamento cujos vendedores terão o salário aumentado
			st.setInt(2, 2);

			// Executa a atualização e armazena o número de linhas afetadas
			int rowsAffected = st.executeUpdate();

			// Exibe a mensagem de sucesso e o número de linhas afetadas
			System.out.println("Done! Rows affected: " + rowsAffected);
		} catch (SQLException e) {
			// Exibe a stack trace em caso de erro na execução da atualização
			e.printStackTrace();
		} finally {
			// Fecha a declaração SQL
			DB.closeStatement(st);
			// Fecha a conexão com o banco de dados
			DB.closeConnection();
		}
	}
}
 


===================================================================================================================== 
  deletar dados
// Classe para gerenciamento de conexão com o banco de dados
package db;

import java.io.FileInputStream;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

public class DB {

	// Variável para armazenar a conexão com o banco de dados
	private static Connection conn = null;

	// Método para obter a conexão com o banco de dados
	public static Connection getConnection() {
		if (conn == null) { // Verifica se a conexão já foi estabelecida
			try {
				// Carrega as propriedades do arquivo "db.properties"
				Properties props = loadProperties();
				// Obtém a URL de conexão a partir das propriedades
				String url = props.getProperty("dburl");
				// Estabelece a conexão com o banco de dados
				conn = DriverManager.getConnection(url, props);
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha na conexão
				throw new DbException(e.getMessage());
			}
		}
		return conn;
	}

	// Método para fechar a conexão com o banco de dados
	public static void closeConnection() {
		if (conn != null) { // Verifica se a conexão já foi estabelecida
			try {
				conn.close(); // Fecha a conexão com o banco de dados
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha ao fechar a conexão
				throw new DbException(e.getMessage());
			}
		}
	}

	// Método para carregar as propriedades do arquivo "db.properties"
	private static Properties loadProperties() {
		try (FileInputStream fs = new FileInputStream("db.properties")) {
			Properties props = new Properties();
			props.load(fs); // Carrega as propriedades do arquivo
			return props;
		}

		// Tratamento de exceção em caso de falha ao carregar o arquivo de propriedades
		catch (IOException e) {
			throw new DbException(e.getMessage());
		}
	}

	// Método para fechar o statement
	public static void closeStatement(Statement st) {
		if (st != null) { // Verifica se o statement já foi aberto
			try {
				st.close(); // Fecha o statement
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha ao fechar o statement
				throw new DbException(e.getMessage());
			}
		}
	}

	// Método para fechar o result set
	public static void closeResultSet(ResultSet rs) {
		if (rs != null) { // Verifica se o result set já foi aberto
			try {
				rs.close(); // Fecha o result set
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha ao fechar o result set
				throw new DbException(e.getMessage());
			}
		}
	}
}
package db;

//Importa a classe base para exceções
import java.lang.RuntimeException;

public class DbException extends RuntimeException {

	private static final long serialVersionUID = 1L;

//Construtor que recebe uma mensagem para a exceção
	public DbException(String msg) {
		// Chama o construtor da classe base, passando a mensagem
		super(msg);
	}
}
// Declaração do pacote db
package db;

// Classe de exceção personalizada para tratamento de erros relacionados à integridade do banco de dados
public class DbIntegrityException extends RuntimeException {

// Identificador serial da classe
	private static final long serialVersionUID = 1L;

// Construtor que recebe uma mensagem de erro
	public DbIntegrityException(String msg) {
		// Chama o construtor da classe pai (RuntimeException) passando a mensagem de
		// erro
		super(msg);
	}
}
A classe DbIntegrityException é uma exceção personalizada criada para tratar erros relacionados à integridade do banco de dados. Ela é importante para o contexto da aplicação porque permite que o programador defina uma forma específica de lidar com esses tipos de erros, o que é importante para garantir a consistência dos dados e evitar problemas futuros.

Além disso, essa classe é uma extensão da classe RuntimeException, o que significa que ela é uma exceção não-checada, ou seja, não é necessário capturá-la explicitamente no código. Dessa forma, o programador pode se concentrar apenas na lógica da aplicação, sem se preocupar com a verificação de erros de integridade do banco de dados.

Em resumo, a classe DbIntegrityException é importante porque permite uma melhor gestão de erros relacionados à integridade do banco de dados, o que garante a qualidade e a consistência dos dados da aplicação.

O erro de integridade de banco de dados é uma condição em que o banco de dados não está mais consistente com as regras definidas para ele. Essas regras são conhecidas como "restrições de integridade" e incluem, por exemplo, a unicidade de valores em uma coluna, a presença de valores em campos obrigatórios, a relação entre tabelas, entre outros.

Quando uma operação viola essas restrições, é gerado um erro de integridade de banco de dados. Esses erros podem ocorrer, por exemplo, quando se tenta inserir um registro com uma chave duplicada ou atualizar um registro de tal forma que algum campo obrigatório fique vazio.

É importante tratar esses erros adequadamente, pois eles podem afetar a consistência e a integridade dos dados no banco de dados. Além disso, eles podem comprometer o funcionamento da aplicação que depende do banco de dados. Portanto, a gestão eficiente de erros de integridade de banco de dados é fundamental para garantir a qualidade e a confiabilidade da aplicação.
package application;
// Importa a classe Connection da biblioteca java.sql
import java.sql.Connection;

// Importa a classe PreparedStatement da biblioteca java.sql
import java.sql.PreparedStatement;

// Importa a classe SQLException da biblioteca java.sql
import java.sql.SQLException;

// Importa a classe DB da biblioteca db
import db.DB;

// Importa a classe DbIntegrityException da biblioteca db
import db.DbIntegrityException;

// Classe principal do programa
public class Program {

// Método main, ponto de entrada do programa
	public static void main(String[] args) {

		// Variável de conexão com o banco de dados
		Connection conn = null;

		// Variável que representa a instrução SQL a ser executada
		PreparedStatement st = null;

		// Bloco try-catch-finally para tratar possíveis erros
		try {
			// Obtém a conexão com o banco de dados através da classe DB
			conn = DB.getConnection();

			// Prepara a instrução SQL para exclusão de um departamento
			st = conn.prepareStatement("DELETE FROM department " + "WHERE " + "Id = ?");

			// Define o valor da primeira interrogação na instrução SQL como 5
			st.setInt(1, 5);

			// Executa a instrução SQL e armazena o número de linhas afetadas
			int rowsAffected = st.executeUpdate();

			// Imprime o resultado da operação
			System.out.println("Done! Rows affected: " + rowsAffected);
		} catch (SQLException e) {
			// Em caso de erro, lança uma exceção do tipo DbIntegrityException com a
			// mensagem de erro
			throw new DbIntegrityException(e.getMessage());
		} finally {
			// Fecha a variável de instrução SQL
			DB.closeStatement(st);

			// Fecha a conexão com o banco de dados
			DB.closeConnection();
		}
	}
}
 


===================================================================================================================== 
  transações
Uma transação em Java é um conjunto de operações que são executadas como uma única unidade lógica, garantindo a integridade dos dados. Isso significa que, se uma transação falhar a meio caminho, todas as alterações feitas durante a transação serão revertidas, mantendo os dados em um estado consistente.

A importância das transações em aplicações é garantir a integridade dos dados ao longo do tempo, mesmo em situações de falhas ou erros. Por exemplo, em um sistema bancário, uma transação pode ser usada para transferir dinheiro de uma conta para outra. Se a transação falhar a meio caminho, pode-se garantir que o dinheiro não será transferido, mantendo a integridade dos dados de ambas as contas.

Um exemplo prático de uso de transações pode ser em uma loja virtual. Ao realizar uma compra, a transação garantirá que, se houver algum problema durante o processamento da compra (por exemplo, falta de estoque), a compra será cancelada e o estoque será atualizado de forma consistente.
// Declaração do pacote db
package db;

// Classe de exceção personalizada para tratamento de erros relacionados à integridade do banco de dados
public class DbIntegrityException extends RuntimeException {

// Identificador serial da classe
	private static final long serialVersionUID = 1L;

// Construtor que recebe uma mensagem de erro
	public DbIntegrityException(String msg) {
		// Chama o construtor da classe pai (RuntimeException) passando a mensagem de
		// erro
		super(msg);
	}
}
package db;

//Importa a classe base para exceções
import java.lang.RuntimeException;

public class DbException extends RuntimeException {

	private static final long serialVersionUID = 1L;

//Construtor que recebe uma mensagem para a exceção
	public DbException(String msg) {
		// Chama o construtor da classe base, passando a mensagem
		super(msg);
	}
}
// Classe para gerenciamento de conexão com o banco de dados
package db;

import java.io.FileInputStream;

public class DB {

	// Variável para armazenar a conexão com o banco de dados
	private static Connection conn = null;

	// Método para obter a conexão com o banco de dados
	public static Connection getConnection() {
		if (conn == null) { // Verifica se a conexão já foi estabelecida
			try {
				// Carrega as propriedades do arquivo "db.properties"
				Properties props = loadProperties();
				// Obtém a URL de conexão a partir das propriedades
				String url = props.getProperty("dburl");
				// Estabelece a conexão com o banco de dados
				conn = DriverManager.getConnection(url, props);
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha na conexão
				throw new DbException(e.getMessage());
			}
		}
		return conn;
	}

	// Método para fechar a conexão com o banco de dados
	public static void closeConnection() {
		if (conn != null) { // Verifica se a conexão já foi estabelecida
			try {
				conn.close(); // Fecha a conexão com o banco de dados
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha ao fechar a conexão
				throw new DbException(e.getMessage());
			}
		}
	}

	// Método para carregar as propriedades do arquivo "db.properties"
	private static Properties loadProperties() {
		try (FileInputStream fs = new FileInputStream("db.properties")) {
			Properties props = new Properties();
			props.load(fs); // Carrega as propriedades do arquivo
			return props;
		}

		// Tratamento de exceção em caso de falha ao carregar o arquivo de propriedades
		catch (IOException e) {
			throw new DbException(e.getMessage());
		}
	}

	// Método para fechar o statement
	public static void closeStatement(Statement st) {
		if (st != null) { // Verifica se o statement já foi aberto
			try {
				st.close(); // Fecha o statement
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha ao fechar o statement
				throw new DbException(e.getMessage());
			}
		}
	}

	// Método para fechar o result set
	public static void closeResultSet(ResultSet rs) {
		if (rs != null) { // Verifica se o result set já foi aberto
			try {
				rs.close(); // Fecha o result set
			} catch (SQLException e) {
				// Lança uma exceção personalizada em caso de falha ao fechar o result set
				throw new DbException(e.getMessage());
			}
		}
	}
}
package application;

// Importa a classe Connection da biblioteca java.sql
import java.sql.Connection;
// Importa a classe SQLException da biblioteca java.sql
import java.sql.SQLException;
import java.sql.Statement;

// Importa a classe DB da biblioteca db
import db.DB;
import db.DbException;

// Classe principal do programa
public class Program {

// Método main, ponto de entrada do programa
	public static void main(String[] args) {

		// Variável de conexão com o banco de dados
		Connection conn = null;

		// Variável que representa a instrução SQL a ser executada
		Statement st = null;
		/*
		 * Aqui, estamos declarando as variáveis que serão usadas para conexão com o
		 * banco de dados e para a execução de instruções SQL.
		 */

		// Bloco try-catch-finally para tratar possíveis erros
		try {
			conn = DB.getConnection();
			conn.setAutoCommit(false);
			/*
			 * Aqui, estamos obtendo uma conexão com o banco de dados através da classe DB e
			 * desabilitando a opção autoCommit da conexão, que por padrão é verdadeira. Com
			 * isso, as operações de atualização não serão executadas imediatamente,
			 * permitindo que sejam feitas múltiplas operações antes de confirmá-las ou
			 * desfazê-las.
			 */

			st = conn.createStatement();
			int rows1 = st.executeUpdate("UPDATE seller SET BaseSalary = 2090 WHERE DepartmentId = 1");
			int rows2 = st.executeUpdate("UPDATE seller SET BaseSalary = 3090 WHERE DepartmentId = 2");
			conn.commit();
			/*
			 * Aqui, estamos criando uma instrução SQL através da conexão, executando duas
			 * atualizações (UPDATE) no banco de dados e confirmando as mudanças através do
			 * método commit().
			 */

			System.out.println("rows1 " + rows1);
			System.out.println("rows2 " + rows2);

		} catch (SQLException e) {
			try {
				conn.rollback();
				throw new DbException("Transaction rolled back! Caused by: " + e.getMessage());
			} catch (SQLException e1) {
				// TODO Auto-generated catch block
				throw new DbException("Error trying to rollback! Caused by: " + e.getMessage());
			}
		} finally {
			// Fecha a variável de instrução SQL
			DB.closeStatement(st);

			// Fecha a conexão com o banco de dados
			DB.closeConnection();
		}
		/*
		 * Aqui, estamos usando um bloco try-catch-finally para tratar possíveis erros
		 * durante as operações com o banco de dados. Caso ocorra uma exceção do tipo
		 * SQLException, o método rollback() será chamado para desfazer as mudanças no
		 * banco de dados e uma nova exceção será lançada. No final, estamos fechando a
		 * instrução SQL e a conexão com o banco de dados através dos métodos
		 * closeStatement(st) e closeConnection() da classe DB.
		 */
		/*
		 * A transação está na parte do código onde as duas atualizações (UPDATE) no
		 * banco de dados são realizadas. A opção de autoCommit da conexão foi
		 * desabilitada, o que permite que múltiplas operações sejam realizadas antes de
		 * confirmá-las ou desfazê-las. As mudanças são confirmadas com o método
		 * commit() e, caso ocorra uma exceção do tipo SQLException, o método rollback()
		 * é chamado para desfazer as mudanças no banco de dados.
		 */
	}
}
 


===================================================================================================================== 
  PROJETO JDBC
 


===================================================================================================================== 
  Padrão de projeto DAO (Data Access Object)
 
O padrão de projeto DAO (Data Access Object) é uma abordagem de programação que permite a separação da lógica de acesso a dados de uma aplicação. É utilizado para centralizar as operações de acesso aos dados em uma camada separada, garantindo assim uma melhor organização do código e uma maior flexibilidade na alteração das fontes de dados sem afetar a aplicação em si.

De forma geral, para cada entidade em uma aplicação, existe um objeto específico, chamado DAO, responsável por realizar as operações de acesso aos dados relacionados a essa entidade. Por exemplo, se tivermos a entidade "Cliente", teríamos um objeto "ClienteDao" responsável por realizar as operações de acesso aos dados dos clientes.

Cada DAO é definido por uma interface que define as operações básicas que precisam ser implementadas, como por exemplo, inserir, atualizar, excluir ou buscar dados. A implementação concreta dessas operações é feita por uma classe que implementa essa interface.

A injeção de dependência pode ser feita por meio do padrão de projeto Factory, permitindo que a aplicação seja desacoplada das fontes de dados, tornando mais fácil a alteração destas fontes sem afetar a aplicação em si.
// Interface DAO que define os métodos para acesso a dados de Clientes
public interface ClienteDao {
    public List<Cliente> getTodosClientes();
    public Cliente getClientePorId(int id);
    public void salvarCliente(Cliente cliente);
    public void atualizarCliente(Cliente cliente);
    public void excluirCliente(Cliente cliente);
}

// Implementação da interface ClienteDao usando JDBC
public class ClienteDaoJdbc implements ClienteDao {
    // Aqui pode haver código relacionado à conexão com o banco de dados, 
    // preparação de statements, execução de consultas, etc.
    
    @Override
    public List<Cliente> getTodosClientes() {
        // Consulta a tabela de clientes no banco de dados, 
        // retorna um List de objetos Cliente
    }
    
    @Override
    public Cliente getClientePorId(int id) {
        // Consulta o cliente com o ID especificado no banco de dados, 
        // retorna um objeto Cliente
    }
    
    @Override
    public void salvarCliente(Cliente cliente) {
        // Insere um novo cliente na tabela de clientes no banco de dados
    }
    
    @Override
    public void atualizarCliente(Cliente cliente) {
        // Atualiza as informações de um cliente na tabela de clientes no banco de dados
    }
    
    @Override
    public void excluirCliente(Cliente cliente) {
        // Remove um cliente da tabela de clientes no banco de dados
    }
}

// Classe Cliente que representa os dados de um cliente
public class Cliente {
    private int id;
    private String nome;
    private String endereco;
    // Outros atributos, getters, setters, etc.
}
// Classe de teste que demonstra o uso da classe ClienteDaoJdbc
public class TesteClienteDao {
    public static void main(String[] args) {
        ClienteDao clienteDao = new ClienteDaoJdbc();
        List<Cliente> clientes = clienteDao.getTodosClientes();
        for (Cliente cliente : clientes) {
            System.out.println(cliente.getNome());
        }
    }
}
Neste exemplo, temos uma interface ClienteDao que define os métodos para acesso a dados de clientes. Essa interface é implementada pela classe ClienteDaoJdbc, que usa JDBC (Java Database Connectivity) para se conectar ao banco de dados e realizar as operações de CRUD
 
Início do projeto importado do GitHub, coforme aula.
package db;

public class DbIntegrityException extends RuntimeException {
    private static final long serialVersionUID = 1L;

    // Construtor que recebe uma mensagem de erro
    public DbIntegrityException(String msg) {
        // Passa a mensagem de erro para o construtor da classe mãe (RuntimeException)
        super(msg);
    }
}
package db;

public class DbException extends RuntimeException {
    private static final long serialVersionUID = 1L;

    // Construtor que recebe uma mensagem de erro
    public DbException(String msg) {
        // Passa a mensagem de erro para o construtor da classe mãe (RuntimeException)
        super(msg);
    }
}
// Este é um código Java para uma classe "DB" que representa uma conexão com um banco de dados
package db;

import java.io.FileInputStream;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

public class DB {
// Propriedade estática para armazenar a conexão com o banco de dados
	private static Connection conn = null;

// Método para obter uma conexão com o banco de dados
	public static Connection getConnection() {
		// Verifica se a conexão já foi estabelecida
		if (conn == null) {
			try {
				// Carrega as propriedades de conexão a partir do arquivo db.properties
				Properties props = loadProperties();
				String url = props.getProperty("dburl");

				// Obtém a conexão com o banco de dados
				conn = DriverManager.getConnection(url, props);
			} catch (SQLException e) {
				// Lança uma exceção personalizada caso ocorra uma exceção de banco de dados
				throw new DbException(e.getMessage());
			}
		}
		// Retorna a conexão com o banco de dados
		return conn;
	}

// Método para fechar a conexão com o banco de dados
	public static void closeConnection() {
		// Verifica se a conexão está aberta
		if (conn != null) {
			try {
				// Fecha a conexão com o banco de dados
				conn.close();
			} catch (SQLException e) {
				// Lança uma exceção personalizada caso ocorra uma exceção de banco de dados
				throw new DbException(e.getMessage());
			}
		}
	}

// Método para carregar as propriedades de conexão a partir do arquivo db.properties
	private static Properties loadProperties() {
		try (FileInputStream fs = new FileInputStream("db.properties")) {
			Properties props = new Properties();
			props.load(fs);
			return props;
		} catch (IOException e) {
			// Lança uma exceção personalizada caso ocorra uma exceção de entrada/saída
			throw new DbException(e.getMessage());
		}
	}

// Método para fechar um objeto "Statement"
	public static void closeStatement(Statement st) {
		if (st != null) {
			try {
				st.close();
			} catch (SQLException e) {
// Lança uma exceção personalizada "DbException" caso haja erro ao fechar o statement
				throw new DbException(e.getMessage());
			}
		}
	}

// Método para fechar um objeto "ResultSet"
	public static void closeResultSet(ResultSet rs) {
		if (rs != null) {
			try {
				rs.close();
			} catch (SQLException e) {
// Lança uma exceção personalizada "DbException" caso haja erro ao fechar o result set
				throw new DbException(e.getMessage());
			}
		}
	}
}
user=root
password=senha@123
dburl=jdbc:mysql://localhost:3306/coursejdbc
useSSL=false
Término da importação do projeto, conforme aula.
 


===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 



===================================================================================================================== 
 
Início da implementação do restante do projeto pelo aluno
 


===================================================================================================================== 
  Department entity class
package model.entities;

import java.io.Serializable;
import java.util.Objects;

// Classe que representa um departamento
public class Department implements Serializable {

	private static final long serialVersionUID = 1L;

	// Id do departamento
	private Integer id;

	// Nome do departamento
	private String name;

	// Construtor vazio
	public Department() {
	}

	// Construtor com parâmetros
	public Department(Integer id, String name) {
		this.id = id;
		this.name = name;
	}

	// Getter para id do departamento
	public Integer getId() {
		return id;
	}

	// Setter para id do departamento
	public void setId(Integer id) {
		this.id = id;
	}

	// Getter para nome do departamento
	public String getName() {
		return name;
	}

	// Setter para nome do departamento
	public void setName(String name) {
		this.name = name;
	}

	// Método hashCode para id do departamento
	@Override
	public int hashCode() {
		return Objects.hash(id);
	}

	// Método equals para id do departamento
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Department other = (Department) obj;
		return Objects.equals(id, other.id);
	}

	// Representação string da classe
	@Override
	public String toString() {
		return "Department [id=" + id + ", name=" + name + "]";
	}
}
 


===================================================================================================================== 
  Seller entity class
package model.entities;

import java.io.Serializable;
import java.util.Date;
import java.util.Objects;

public class Seller implements Serializable {

	// ID da classe para uso do serializable
	private static final long serialVersionUID = 1L;

	// Atributos da classe Seller
	private Integer id;
	private String name;
	private String email;
	private Date birthDate;
	private Double baseSalary;

	/*
	 * A composição está presente na classe Seller, na propriedade
	 * "Department department". Isso significa que a classe Seller tem uma instância
	 * da classe Department. Isso ocorre porque existe uma relação entre um vendedor
	 * e um departamento, onde um vendedor pertence a um departamento.
	 * 
	 * A composição é importante porque permite que a classe Seller tenha acesso aos
	 * atributos e métodos da classe Department, e também permite que sejam feitas
	 * relações entre objetos de classes diferentes, tornando a modelagem do sistema
	 * mais organizada e coerente. Além disso, a composição fornece flexibilidade
	 * para modificar a classe Department sem afetar a classe Seller, o que facilita
	 * a manutenção do código.
	 */
	private Department department;

	// Construtor padrão
	public Seller() {
	}

	// Construtor com todos os atributos
	public Seller(Integer id, String name, String email, Date birthDate, Double baseSalary, Department department) {
		this.id = id;
		this.name = name;
		this.email = email;
		this.birthDate = birthDate;
		this.baseSalary = baseSalary;
		this.department = department;
	}

	// Métodos getters e setters para todos os atributos
	public Integer getId() {
		return id;
	}

	public void setId(Integer id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	public Date getBirthDate() {
		return birthDate;
	}

	public void setBirthDate(Date birthDate) {
		this.birthDate = birthDate;
	}

	public Double getBaseSalary() {
		return baseSalary;
	}

	public void setBaseSalary(Double baseSalary) {
		this.baseSalary = baseSalary;
	}

	public Department getDepartment() {
		return department;
	}

	public void setDepartment(Department department) {
		this.department = department;
	}

	// Implementação do método hashCode
	@Override
	public int hashCode() {
		return Objects.hash(id);
	}

	// Implementação do método equals
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Seller other = (Seller) obj;
		return Objects.equals(id, other.id);
	}

	// Implementação do método toString
	@Override
	public String toString() {
		return "Seller [id=" + id + ", name=" + name + ", email=" + email + ", birthDate=" + birthDate + ", baseSalary="
				+ baseSalary + ", department=" + department + "]";
	}
}
 


===================================================================================================================== 
  DepartmentDao and SellerDao interfaces
// Arquivo DepartmentDao.java

// Declaração do pacote model.dao
package model.dao;

// Importação da classe List do pacote java.util
import java.util.List;

// Importação da classe Department do pacote model.entities
import model.entities.Department;

/**
 * Interface DepartmentDao que contém métodos para manipular objetos Department
 * no banco de dados.
 */
public interface DepartmentDao {

	/**
	 * Insere um objeto Department no banco de dados.
	 * 
	 * @param obj Objeto Department a ser inserido.
	 */
	void insert(Department obj);

	/**
	 * Atualiza um objeto Department no banco de dados.
	 * 
	 * @param obj Objeto Department a ser atualizado.
	 */
	void update(Department obj);

	/**
	 * Remove um objeto Department do banco de dados a partir do seu ID.
	 * 
	 * @param id ID do objeto Department a ser removido.
	 */
	void deleteById(Integer id);

	/**
	 * Busca um objeto Department no banco de dados a partir do seu ID.
	 * 
	 * @param id ID do objeto Department a ser buscado.
	 * @return O objeto Department encontrado.
	 */
	Department findById(Integer id);

	/**
	 * Retorna uma lista com todos os objetos Department do banco de dados.
	 * 
	 * @return Uma lista com todos os objetos Department.
	 */
	List<Department> findAll();
}
package model.dao;

import java.util.List;

import model.entities.Seller;

/**
 * Interface que representa as operações de persistência para objetos do tipo
 * Seller.
 */
public interface SellerDao {

	/**
	 * Insere um objeto do tipo Seller no banco de dados.
	 * 
	 * @param obj Objeto do tipo Seller a ser inserido.
	 */
	void insert(Seller obj);

	/**
	 * Atualiza as informações de um objeto do tipo Seller no banco de dados.
	 * 
	 * @param obj Objeto do tipo Seller com as informações atualizadas.
	 */
	void update(Seller obj);

	/**
	 * Remove um objeto do tipo Seller do banco de dados, a partir do seu id.
	 * 
	 * @param id Id do objeto a ser removido.
	 */
	void deleteById(Integer id);

	/**
	 * Busca um objeto do tipo Seller no banco de dados, a partir do seu id.
	 * 
	 * @param id Id do objeto a ser buscado.
	 * @return O objeto do tipo Seller encontrado.
	 */
	Seller findById(Integer id);

	/**
	 * Busca todos os objetos do tipo Seller no banco de dados.
	 * 
	 * @return Lista de objetos do tipo Seller encontrados.
	 */
	List<Seller> findAll();
}
 


===================================================================================================================== 
  SellerDaoJDBC and DaoFactory
package model.dao.impl;

import java.util.List;

import model.dao.SellerDao;
import model.entities.Seller;

public class SellerDaoJDBC implements SellerDao {

	@Override
	public void insert(Seller obj) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void update(Seller obj) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteById(Integer id) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public Seller findById(Integer id) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<Seller> findAll() {
		// TODO Auto-generated method stub
		return null;
	}
}
package model.dao;

import model.dao.impl.SellerDaoJDBC;

public class DaoFactory {

	public static SellerDao createSellerDao() {
		return new SellerDaoJDBC();
	}
	/*
	 * A classe DaoFactory é uma classe de fábrica responsável por fornecer uma
	 * instância de um objeto que implementa a interface SellerDao. A importância
	 * desta classe é centralizar a criação de objetos, permitindo a mudança da
	 * implementação de uma interface sem afetar o resto da aplicação. Isso também
	 * ajuda a manter o código mais organizado e facilitar futuras manutenções, já
	 * que a criação de objetos fica concentrada em uma única classe.
	 */
}
 
 


===================================================================================================================== 
  findById implementation
package model.dao.impl;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

import db.DB;
import db.DbException;
import model.dao.SellerDao;
import model.entities.Department;
import model.entities.Seller;

public class SellerDaoJDBC implements SellerDao {

	private Connection conn;

//Constructor que recebe uma conexão como parâmetro e atribui ao atributo da classe
	public SellerDaoJDBC(Connection conn) {
		this.conn = conn;
	}

//Método para inserir vendedor
	@Override
	public void insert(Seller obj) {
		// TODO Auto-generated method stub

	}

//Método para atualizar vendedor
	@Override
	public void update(Seller obj) {
		// TODO Auto-generated method stub

	}

//Método para excluir vendedor por id
	@Override
	public void deleteById(Integer id) {
		// TODO Auto-generated method stub

	}

//Método para ENCONTRAR VENDEDOR PELO ID
	@Override
	public Seller findById(Integer id) {
		PreparedStatement st = null;
		ResultSet rs = null;
		try {
			// Comando SQL para buscar vendedor pelo id e o departamento associado
			st = conn.prepareStatement(
					"SELECT seller.*,department.Name as DepName " + "FROM seller INNER JOIN department "
							+ "ON seller.DepartmentId = department.Id " + "WHERE seller.Id = ? ");

			// definindo o id para busca
			st.setInt(1, id);
			rs = st.executeQuery();

			// se houver um resultado na busca
			if (rs.next()) {
				// criando o objeto do tipo Department
				Department dep = new Department();
				// definindo o id do departamento
				dep.setId(rs.getInt("DepartmentId"));
				// definindo o nome do departamento
				dep.setName(rs.getString("DepName"));

				// criando o objeto do tipo Seller
				Seller obj = new Seller();
				// definindo o id do vendedor
				obj.setId(rs.getInt("Id"));
				// definindo o nome do vendedor
				obj.setName(rs.getString("Name"));
				// definindo o email do vendedor
				obj.setEmail(rs.getString("Email"));
				// definindo o salário base do vendedor
				obj.setBaseSalary(rs.getDouble("BaseSalary"));
				// definindo a data de nascimento do vendedor
				obj.setBirthDate(rs.getDate("BirthDate"));
				// definindo o departamento do vendedor
				obj.setDepartment(dep);

				// retornando o objeto vendedor
				return obj;
			}

			// retornando null caso não haja um resultado
			return null;
		} catch (SQLException e) {
			// caso ocorra uma exceção, é lançada uma excessão do tipo DbException com a
			// mensagem de erro
			throw new DbException(e.getMessage());
		} finally {
			// fechando os recursos abertos pela consulta ao banco de dados
			DB.closeStatement(st);
			DB.closeResultSet(rs);
		}
	}

	// Método para buscar todos os vendedores
	@Override
	public List<Seller> findAll() {
		// TODO Auto-generated method stub
		return null;
	}

}
 


===================================================================================================================== 
  Reusing instantiation
package model.dao.impl;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

import db.DB;
import db.DbException;
import model.dao.SellerDao;
import model.entities.Department;
import model.entities.Seller;

public class SellerDaoJDBC implements SellerDao {

	private Connection conn;

//Constructor que recebe uma conexão como parâmetro e atribui ao atributo da classe
	public SellerDaoJDBC(Connection conn) {
		this.conn = conn;
	}

//Método para inserir vendedor
	@Override
	public void insert(Seller obj) {
		// TODO Auto-generated method stub

	}

//Método para atualizar vendedor
	@Override
	public void update(Seller obj) {
		// TODO Auto-generated method stub

	}

//Método para excluir vendedor por id
	@Override
	public void deleteById(Integer id) {
		// TODO Auto-generated method stub

	}

//Método para encontrar vendedor por id
	@Override
	public Seller findById(Integer id) {
		PreparedStatement st = null;
		ResultSet rs = null;
		try {
			// Comando SQL para buscar vendedor pelo id e o departamento associado
			st = conn.prepareStatement(
					"SELECT seller.*,department.Name as DepName " + "FROM seller INNER JOIN department "
							+ "ON seller.DepartmentId = department.Id " + "WHERE seller.Id = ? ");

			// definindo o id para busca
			st.setInt(1, id);
			rs = st.executeQuery();

			// se houver um resultado na busca
			if (rs.next()) {
				// criando o objeto do tipo Department
				Department dep = instantiateDepartment(rs);

				// criando o objeto do tipo Seller
				Seller obj = instantiateSeller(rs, dep);

				// retornando o objeto vendedor
				return obj;
			}

			// retornando null caso não haja um resultado
			return null;
		} catch (SQLException e) {
			// caso ocorra uma exceção, é lançada uma excessão do tipo DbException com a
			// mensagem de erro
			throw new DbException(e.getMessage());
		} finally {
			// fechando os recursos abertos pela consulta ao banco de dados
			DB.closeStatement(st);
			DB.closeResultSet(rs);
		}
	}

	private Seller instantiateSeller(ResultSet rs, Department dep) throws SQLException {
		// Criação de um objeto vendedor
		Seller obj = new Seller();

		// Preenchimento do id do vendedor com o valor obtido do resultado da consulta
		// ao banco de dados
		obj.setId(rs.getInt("Id"));

		// Preenchimento do nome do vendedor com o valor obtido do resultado da consulta
		// ao banco de dados
		obj.setName(rs.getString("Name"));

		// Preenchimento do email do vendedor com o valor obtido do resultado da
		// consulta ao banco de dados
		obj.setEmail(rs.getString("Email"));

		// Preenchimento do salário base do vendedor com o valor obtido do resultado da
		// consulta ao banco de dados
		obj.setBaseSalary(rs.getDouble("BaseSalary"));

		// Preenchimento da data de nascimento do vendedor com o valor obtido do
		// resultado da consulta ao banco de dados
		obj.setBirthDate(rs.getDate("BirthDate"));

		// Definindo o departamento do vendedor
		obj.setDepartment(dep);

		// Retornando o objeto vendedor preenchido com os valores obtidos do banco de
		// dados
		return obj;
	}

	private Department instantiateDepartment(ResultSet rs) throws SQLException {
		// Criando um novo objeto do tipo Department
		Department dep = new Department();

		// Definindo o id do departamento com o valor obtido na busca
		dep.setId(rs.getInt("DepartmentId"));

		// Definindo o nome do departamento com o valor obtido na busca
		dep.setName(rs.getString("DepName"));

		// retornando o objeto departamento
		return dep;
	}

	// Método para buscar todos os vendedores
	@Override
	public List<Seller> findAll() {
		// TODO Auto-generated method stub
		return null;
	}
	/*
	 * A classe SellerDaoJDBC implementa a interface SellerDao e contém métodos para
	 * realizar operações de CRUD (Create, Read, Update e Delete) com vendedores. A
	 * lógica para reutilização desta classe está presente na maneira como ela
	 * utiliza a conexão com o banco de dados fornecida por meio de seu construtor.
	 * A conexão é usada em todos os métodos para realizar as consultas necessárias.
	 * Além disso, o método findById realiza a busca de um vendedor pelo seu ID e
	 * retorna um objeto Seller preenchido com os dados encontrados no banco de
	 * dados.
	 */

}
 


===================================================================================================================== 
  findByDepartment implementation
package model.dao.impl;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import db.DB;
import db.DbException;
import model.dao.SellerDao;
import model.entities.Department;
import model.entities.Seller;

public class SellerDaoJDBC implements SellerDao {

	// Cria a conexão com o banco de dados
	private Connection conn;

	public SellerDaoJDBC(Connection conn) {
		this.conn = conn;
	}

	// Método que retorna um vendedor de acordo com o id
	@Override
	public Seller findById(Integer id) {
		PreparedStatement st = null; // declara uma variavél st que armazenará o objeto PreparedStatement
		ResultSet rs = null; // declara uma variável rs que armazena o objeto ResultSet
		try {
			// cria um objeto PreparedStatement com uma query sql para obter os dados do
			// vendedor de acordo com o id
			st = conn.prepareStatement(
					"SELECT seller.*,department.Name as DepName " + "FROM seller INNER JOIN department "
							+ "ON seller.DepartmentId = department.Id " + "WHERE seller.Id = ?");

			// define o parâmetro da query sql
			st.setInt(1, id);
			// executa a query sql e armazena o resultado no objeto ResultSet
			rs = st.executeQuery();
			if (rs.next()) { // se conseguiu obter os dados
				// cria um objeto Department a partir dos dados no ResultSet
				Department dep = instantiateDepartment(rs);
				// cria um objeto Seller a partir dos dados no ResutSet
				Seller obj = instantiateSeller(rs, dep);
				return obj; // retorna o objeto Seller criado
			}
			return null; // caso contrário retorna null
		} catch (SQLException e) {
			throw new DbException(e.getMessage());
		} finally {
			DB.closeStatement(st); // fecha o objeto PreparedStatement
			DB.closeResultSet(rs); // fecha o objeto ResultSet
		}
	}

	// cria um objeto Department a partir dos dados no ResultSet
	private Department instantiateDepartment(ResultSet rs) throws SQLException {
		Department dep = new Department();
		dep.setId(rs.getInt("DepartmentId"));
		dep.setName(rs.getString("DepName"));
		return dep;
	}

	// cria um objeto Seller a partir dos dados no ResutSet
	private Seller instantiateSeller(ResultSet rs, Department dep) throws SQLException {
		Seller obj = new Seller();
		obj.setId(rs.getInt("Id"));
		obj.setName(rs.getString("Name"));
		obj.setEmail(rs.getString("Email"));
		obj.setBaseSalary(rs.getDouble("BaseSalary"));
		obj.setBirthDate(rs.getDate("BirthDate"));
		obj.setDepartment(dep);
		return obj;
	}

	// Método que retorna uma lista de vendedores de acordo com o DEPARTAMENTO
	@Override
	public List<Seller> findByDepartment(Department department) {
		PreparedStatement st = null;
		ResultSet rs = null;
		try {
			// cria um objeto PreparedStatement com uma query sql para obter os dados dos vendedores de acordo com o departamento
			st = conn.prepareStatement(
					"SELECT seller.*,department.Name as DepName "
					+ "FROM seller INNER JOIN department "
					+ "ON seller.DepartmentId = department.Id "
					+ "WHERE DepartmentId = ? "
					+ "ORDER BY Name");
			
			// define o parâmetro da query sql
			st.setInt(1, department.getId());
			// executa a query sql e armazena o resultado no objeto ResultSet
			rs = st.executeQuery();
			
			List<Seller> list = new ArrayList<>(); // cria uma lista de Seller
			Map<Integer, Department> map = new HashMap<>(); // cria um mapa para armazenar os objetos Department
			
			// enquanto houver dados no ResultSet
			while (rs.next()) {
				
				Department dep = map.get(rs.getInt("DepartmentId")); // obtém o objeto Department no mapa
				
				// se o mapa não tiver um objeto Department para o id obtido
				if (dep == null) {
					// cria um objeto Department a partir dos dados no ResultSet
					dep = instantiateDepartment(rs);
					// armazena o objeto Department no mapa
					map.put(rs.getInt("DepartmentId"), dep);
				}
				
				// cria um objeto Seller a partir dos dados no ResutSet
				Seller obj = instantiateSeller(rs, dep);
				list.add(obj); // adiciona o objeto Seller à lista 
			}
			return list; // retorna a lista de Seller
		}
		catch (SQLException e) {
			throw new DbException(e.getMessage());
		}
		finally {
			DB.closeStatement(st); // fecha o objeto PreparedStatement
			DB.closeResultSet(rs); // fecha o objeto ResultSet
		}
	}
}
 


===================================================================================================================== 
  findAll implementation
package model.dao.impl;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import db.DB;
import db.DbException;
import model.dao.SellerDao;
import model.entities.Department;
import model.entities.Seller;

public class SellerDaoJDBC implements SellerDao {

	// Cria a conexão com o banco de dados
	private Connection conn;

	public SellerDaoJDBC(Connection conn) {
		this.conn = conn;
	}

	// Método que retorna um vendedor de acordo com o id
	@Override
	public Seller findById(Integer id) {
		PreparedStatement st = null; // declara uma variavél st que armazenará o objeto PreparedStatement
		ResultSet rs = null; // declara uma variável rs que armazena o objeto ResultSet
		try {
			// cria um objeto PreparedStatement com uma query sql para obter os dados do
			// vendedor de acordo com o id
			st = conn.prepareStatement(
					"SELECT seller.*,department.Name as DepName " + "FROM seller INNER JOIN department "
							+ "ON seller.DepartmentId = department.Id " + "WHERE seller.Id = ?");

			// define o parâmetro da query sql
			st.setInt(1, id);
			// executa a query sql e armazena o resultado no objeto ResultSet
			rs = st.executeQuery();
			if (rs.next()) { // se conseguiu obter os dados
				// cria um objeto Department a partir dos dados no ResultSet
				Department dep = instantiateDepartment(rs);
				// cria um objeto Seller a partir dos dados no ResutSet
				Seller obj = instantiateSeller(rs, dep);
				return obj; // retorna o objeto Seller criado
			}
			return null; // caso contrário retorna null
		} catch (SQLException e) {
			throw new DbException(e.getMessage());
		} finally {
			DB.closeStatement(st); // fecha o objeto PreparedStatement
			DB.closeResultSet(rs); // fecha o objeto ResultSet
		}
	}

	// cria um objeto Department a partir dos dados no ResultSet
	private Department instantiateDepartment(ResultSet rs) throws SQLException {
		Department dep = new Department();
		dep.setId(rs.getInt("DepartmentId"));
		dep.setName(rs.getString("DepName"));
		return dep;
	}

	// cria um objeto Seller a partir dos dados no ResutSet
	private Seller instantiateSeller(ResultSet rs, Department dep) throws SQLException {
		Seller obj = new Seller();
		obj.setId(rs.getInt("Id"));
		obj.setName(rs.getString("Name"));
		obj.setEmail(rs.getString("Email"));
		obj.setBaseSalary(rs.getDouble("BaseSalary"));
		obj.setBirthDate(rs.getDate("BirthDate"));
		obj.setDepartment(dep);
		return obj;
	}

	@Override
	public List<Seller> findAll() {
		PreparedStatement st = null;
		ResultSet rs = null;
		try {
			// cria um objeto PreparedStatement com uma query sql para obter os dados dos
			// vendedores de acordo com o departamento
			st = conn.prepareStatement(
					"SELECT seller.*,department.Name as DepName " + "FROM seller INNER JOIN department "
							+ "ON seller.DepartmentId = department.Id " + "ORDER BY Name");

			// executa a query sql e armazena o resultado no objeto ResultSet
			rs = st.executeQuery();

			List<Seller> list = new ArrayList<>(); // cria uma lista de Seller
			Map<Integer, Department> map = new HashMap<>(); // cria um mapa para armazenar os objetos Department

			// enquanto houver dados no ResultSet
			while (rs.next()) {

				Department dep = map.get(rs.getInt("DepartmentId")); // obtém o objeto Department no mapa

				// se o mapa não tiver um objeto Department para o id obtido
				if (dep == null) {
					// cria um objeto Department a partir dos dados no ResultSet
					dep = instantiateDepartment(rs);
					// armazena o objeto Department no mapa
					map.put(rs.getInt("DepartmentId"), dep);
				}

				// cria um objeto Seller a partir dos dados no ResutSet
				Seller obj = instantiateSeller(rs, dep);
				list.add(obj); // adiciona o objeto Seller à lista
			}
			return list; // retorna a lista de Seller
		} catch (SQLException e) {
			throw new DbException(e.getMessage());
		} finally {
			DB.closeStatement(st); // fecha o objeto PreparedStatement
			DB.closeResultSet(rs); // fecha o objeto ResultSet
		}
	}

	// Método que retorna uma lista de vendedores de acordo com o DEPARTAMENTO
	@Override
	public List<Seller> findByDepartment(Department department) {
		PreparedStatement st = null;
		ResultSet rs = null;
		try {
			// cria um objeto PreparedStatement com uma query sql para obter os dados dos
			// vendedores de acordo com o departamento
			st = conn.prepareStatement(
					"SELECT seller.*,department.Name as DepName " + "FROM seller INNER JOIN department "
							+ "ON seller.DepartmentId = department.Id " + "WHERE DepartmentId = ? " + "ORDER BY Name");

			// define o parâmetro da query sql
			st.setInt(1, department.getId());
			// executa a query sql e armazena o resultado no objeto ResultSet
			rs = st.executeQuery();

			List<Seller> list = new ArrayList<>(); // cria uma lista de Seller
			Map<Integer, Department> map = new HashMap<>(); // cria um mapa para armazenar os objetos Department

			// enquanto houver dados no ResultSet
			while (rs.next()) {

				Department dep = map.get(rs.getInt("DepartmentId")); // obtém o objeto Department no mapa

				// se o mapa não tiver um objeto Department para o id obtido
				if (dep == null) {
					// cria um objeto Department a partir dos dados no ResultSet
					dep = instantiateDepartment(rs);
					// armazena o objeto Department no mapa
					map.put(rs.getInt("DepartmentId"), dep);
				}

				// cria um objeto Seller a partir dos dados no ResutSet
				Seller obj = instantiateSeller(rs, dep);
				list.add(obj); // adiciona o objeto Seller à lista
			}
			return list; // retorna a lista de Seller
		} catch (SQLException e) {
			throw new DbException(e.getMessage());
		} finally {
			DB.closeStatement(st); // fecha o objeto PreparedStatement
			DB.closeResultSet(rs); // fecha o objeto ResultSet
		}
	}

	@Override
	public void insert(Seller obj) {
		// TODO Auto-generated method stub

	}

	@Override
	public void update(Seller obj) {
		// TODO Auto-generated method stub

	}

	@Override
	public void deleteById(Integer id) {
		// TODO Auto-generated method stub

	}

}
 


===================================================================================================================== 
  insert implementation
package model.dao.impl;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import db.DB;
import db.DbException;
import model.dao.SellerDao;
import model.entities.Department;
import model.entities.Seller;

public class SellerDaoJDBC implements SellerDao {

	// Cria a conexão com o banco de dados
	private Connection conn;

	public SellerDaoJDBC(Connection conn) {
		this.conn = conn;
	}

	// Método que retorna um vendedor de acordo com o id
	@Override
	public Seller findById(Integer id) {
		PreparedStatement st = null; // declara uma variavél st que armazenará o objeto PreparedStatement
		ResultSet rs = null; // declara uma variável rs que armazena o objeto ResultSet
		try {
			// cria um objeto PreparedStatement com uma query sql para obter os dados do
			// vendedor de acordo com o id
			st = conn.prepareStatement(
					"SELECT seller.*,department.Name as DepName " + "FROM seller INNER JOIN department "
							+ "ON seller.DepartmentId = department.Id " + "WHERE seller.Id = ?");

			// define o parâmetro da query sql
			st.setInt(1, id);
			// executa a query sql e armazena o resultado no objeto ResultSet
			rs = st.executeQuery();
			if (rs.next()) { // se conseguiu obter os dados
				// cria um objeto Department a partir dos dados no ResultSet
				Department dep = instantiateDepartment(rs);
				// cria um objeto Seller a partir dos dados no ResutSet
				Seller obj = instantiateSeller(rs, dep);
				return obj; // retorna o objeto Seller criado
			}
			return null; // caso contrário retorna null
		} catch (SQLException e) {
			throw new DbException(e.getMessage());
		} finally {
			DB.closeStatement(st); // fecha o objeto PreparedStatement
			DB.closeResultSet(rs); // fecha o objeto ResultSet
		}
	}

	// cria um objeto Department a partir dos dados no ResultSet
	private Department instantiateDepartment(ResultSet rs) throws SQLException {
		Department dep = new Department();
		dep.setId(rs.getInt("DepartmentId"));
		dep.setName(rs.getString("DepName"));
		return dep;
	}

	// cria um objeto Seller a partir dos dados no ResutSet
	private Seller instantiateSeller(ResultSet rs, Department dep) throws SQLException {
		Seller obj = new Seller();
		obj.setId(rs.getInt("Id"));
		obj.setName(rs.getString("Name"));
		obj.setEmail(rs.getString("Email"));
		obj.setBaseSalary(rs.getDouble("BaseSalary"));
		obj.setBirthDate(rs.getDate("BirthDate"));
		obj.setDepartment(dep);
		return obj;
	}

	@Override
	public void insert(Seller obj) {
		PreparedStatement st = null;
		try {
			// Cria a instrução SQL para inserir um vendedor na tabela seller
			st = conn.prepareStatement("INSERT INTO seller " + "(Name, Email, BirthDate, BaseSalary, DepartmentId) "
					+ "VALUES " + "(?, ?, ?, ?, ?)", Statement.RETURN_GENERATED_KEYS);

			// Define os valores para os parâmetros da instrução SQL
			st.setString(1, obj.getName());
			st.setString(2, obj.getEmail());
			st.setDate(3, new java.sql.Date(obj.getBirthDate().getTime()));
			st.setDouble(4, obj.getBaseSalary());
			st.setInt(5, obj.getDepartment().getId());

			// Executa a instrução SQL e verifica se alguma linha foi afetada
			int rowsAffected = st.executeUpdate();

			if (rowsAffected > 0) {
				// Se sim, recupera o id gerado automaticamente pelo banco de dados
				ResultSet rs = st.getGeneratedKeys();
				if (rs.next()) {
					int id = rs.getInt(1);
					obj.setId(id);
				}
				// Fecha o result set
				DB.closeResultSet(rs);
			} else {
				// Se não, lança uma exceção
				throw new DbException("Erro inesperado! Nenhuma linha foi afetada! ");
			}
		} catch (SQLException e) {
			// Lança uma exceção com a mensagem de erro da exceção SQL
			throw new DbException(e.getMessage());
		} finally {
			// Fecha o statement, independentemente do resultado da operação
			DB.closeStatement(st);
		}
	}

	@Override
	public void update(Seller obj) {
		// TODO Auto-generated method stub

	}

	@Override
	public void deleteById(Integer id) {
		// TODO Auto-generated method stub

	}

	@Override
	public List<Seller> findAll() {
		PreparedStatement st = null;
		ResultSet rs = null;
		try {
			// cria um objeto PreparedStatement com uma query sql para obter os dados dos
			// vendedores de acordo com o departamento
			st = conn.prepareStatement(
					"SELECT seller.*,department.Name as DepName " + "FROM seller INNER JOIN department "
							+ "ON seller.DepartmentId = department.Id " + "ORDER BY Name");

			// executa a query sql e armazena o resultado no objeto ResultSet
			rs = st.executeQuery();

			List<Seller> list = new ArrayList<>(); // cria uma lista de Seller
			Map<Integer, Department> map = new HashMap<>(); // cria um mapa para armazenar os objetos Department

			// enquanto houver dados no ResultSet
			while (rs.next()) {

				Department dep = map.get(rs.getInt("DepartmentId")); // obtém o objeto Department no mapa

				// se o mapa não tiver um objeto Department para o id obtido
				if (dep == null) {
					// cria um objeto Department a partir dos dados no ResultSet
					dep = instantiateDepartment(rs);
					// armazena o objeto Department no mapa
					map.put(rs.getInt("DepartmentId"), dep);
				}

				// cria um objeto Seller a partir dos dados no ResutSet
				Seller obj = instantiateSeller(rs, dep);
				list.add(obj); // adiciona o objeto Seller à lista
			}
			return list; // retorna a lista de Seller
		} catch (SQLException e) {
			throw new DbException(e.getMessage());
		} finally {
			DB.closeStatement(st); // fecha o objeto PreparedStatement
			DB.closeResultSet(rs); // fecha o objeto ResultSet
		}
	}

	// Método que retorna uma lista de vendedores de acordo com o DEPARTAMENTO
	@Override
	public List<Seller> findByDepartment(Department department) {
		PreparedStatement st = null;
		ResultSet rs = null;
		try {
			// cria um objeto PreparedStatement com uma query sql para obter os dados dos
			// vendedores de acordo com o departamento
			st = conn.prepareStatement(
					"SELECT seller.*,department.Name as DepName " + "FROM seller INNER JOIN department "
							+ "ON seller.DepartmentId = department.Id " + "WHERE DepartmentId = ? " + "ORDER BY Name");

			// define o parâmetro da query sql
			st.setInt(1, department.getId());
			// executa a query sql e armazena o resultado no objeto ResultSet
			rs = st.executeQuery();

			List<Seller> list = new ArrayList<>(); // cria uma lista de Seller
			Map<Integer, Department> map = new HashMap<>(); // cria um mapa para armazenar os objetos Department

			// enquanto houver dados no ResultSet
			while (rs.next()) {

				Department dep = map.get(rs.getInt("DepartmentId")); // obtém o objeto Department no mapa

				// se o mapa não tiver um objeto Department para o id obtido
				if (dep == null) {
					// cria um objeto Department a partir dos dados no ResultSet
					dep = instantiateDepartment(rs);
					// armazena o objeto Department no mapa
					map.put(rs.getInt("DepartmentId"), dep);
				}

				// cria um objeto Seller a partir dos dados no ResutSet
				Seller obj = instantiateSeller(rs, dep);
				list.add(obj); // adiciona o objeto Seller à lista
			}
			return list; // retorna a lista de Seller
		} catch (SQLException e) {
			throw new DbException(e.getMessage());
		} finally {
			DB.closeStatement(st); // fecha o objeto PreparedStatement
			DB.closeResultSet(rs); // fecha o objeto ResultSet
		}
	}
}
 


===================================================================================================================== 
  update implementation
package model.dao.impl;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import db.DB;
import db.DbException;
import model.dao.SellerDao;
import model.entities.Department;
import model.entities.Seller;

public class SellerDaoJDBC implements SellerDao {

	// Cria a conexão com o banco de dados
	private Connection conn;

	public SellerDaoJDBC(Connection conn) {
		this.conn = conn;
	}

	// Método que retorna um vendedor de acordo com o id
	@Override
	public Seller findById(Integer id) {
		PreparedStatement st = null; // declara uma variavél st que armazenará o objeto PreparedStatement
		ResultSet rs = null; // declara uma variável rs que armazena o objeto ResultSet
		try {
			// cria um objeto PreparedStatement com uma query sql para obter os dados do
			// vendedor de acordo com o id
			st = conn.prepareStatement(
					"SELECT seller.*,department.Name as DepName " + "FROM seller INNER JOIN department "
							+ "ON seller.DepartmentId = department.Id " + "WHERE seller.Id = ?");

			// define o parâmetro da query sql
			st.setInt(1, id);
			// executa a query sql e armazena o resultado no objeto ResultSet
			rs = st.executeQuery();
			if (rs.next()) { // se conseguiu obter os dados
				// cria um objeto Department a partir dos dados no ResultSet
				Department dep = instantiateDepartment(rs);
				// cria um objeto Seller a partir dos dados no ResutSet
				Seller obj = instantiateSeller(rs, dep);
				return obj; // retorna o objeto Seller criado
			}
			return null; // caso contrário retorna null
		} catch (SQLException e) {
			throw new DbException(e.getMessage());
		} finally {
			DB.closeStatement(st); // fecha o objeto PreparedStatement
			DB.closeResultSet(rs); // fecha o objeto ResultSet
		}
	}

	// cria um objeto Department a partir dos dados no ResultSet
	private Department instantiateDepartment(ResultSet rs) throws SQLException {
		Department dep = new Department();
		dep.setId(rs.getInt("DepartmentId"));
		dep.setName(rs.getString("DepName"));
		return dep;
	}

	// cria um objeto Seller a partir dos dados no ResutSet
	private Seller instantiateSeller(ResultSet rs, Department dep) throws SQLException {
		Seller obj = new Seller();
		obj.setId(rs.getInt("Id"));
		obj.setName(rs.getString("Name"));
		obj.setEmail(rs.getString("Email"));
		obj.setBaseSalary(rs.getDouble("BaseSalary"));
		obj.setBirthDate(rs.getDate("BirthDate"));
		obj.setDepartment(dep);
		return obj;
	}

	@Override
	public void insert(Seller obj) {
		PreparedStatement st = null;
		try {
			// Cria a instrução SQL para inserir um vendedor na tabela seller
			st = conn.prepareStatement("INSERT INTO seller " + "(Name, Email, BirthDate, BaseSalary, DepartmentId) "
					+ "VALUES " + "(?, ?, ?, ?, ?)", Statement.RETURN_GENERATED_KEYS);

			// Define os valores para os parâmetros da instrução SQL
			st.setString(1, obj.getName());
			st.setString(2, obj.getEmail());
			st.setDate(3, new java.sql.Date(obj.getBirthDate().getTime()));
			st.setDouble(4, obj.getBaseSalary());
			st.setInt(5, obj.getDepartment().getId());

			// Executa a instrução SQL e verifica se alguma linha foi afetada
			int rowsAffected = st.executeUpdate();

			if (rowsAffected > 0) {
				// Se sim, recupera o id gerado automaticamente pelo banco de dados
				ResultSet rs = st.getGeneratedKeys();
				if (rs.next()) {
					int id = rs.getInt(1);
					obj.setId(id);
				}
				// Fecha o result set
				DB.closeResultSet(rs);
			} else {
				// Se não, lança uma exceção
				throw new DbException("Erro inesperado! Nenhuma linha foi afetada! ");
			}
		} catch (SQLException e) {
			// Lança uma exceção com a mensagem de erro da exceção SQL
			throw new DbException(e.getMessage());
		} finally {
			// Fecha o statement, independentemente do resultado da operação
			DB.closeStatement(st);
		}
	}

	@Override
	public void update(Seller obj) {
		PreparedStatement st = null;
		try {
			// Cria a instrução SQL para inserir um vendedor na tabela seller
			st = conn.prepareStatement(
					"UPDATE seller " 
					+ "SET Name = ?, Email = ?, BirthDate = ?, BaseSalary = ?, DepartmentId = ? "
					+ "WHERE Id = ? " );

			// Define os valores para os parâmetros da instrução SQL
			st.setString(1, obj.getName());
			st.setString(2, obj.getEmail());
			st.setDate(3, new java.sql.Date(obj.getBirthDate().getTime()));
			st.setDouble(4, obj.getBaseSalary());
			st.setInt(5, obj.getDepartment().getId());
			st.setInt(6, obj.getId());

			// Executa a instrução 
			st.executeUpdate();

		} catch (SQLException e) {
			// Lança uma exceção com a mensagem de erro da exceção SQL
			throw new DbException(e.getMessage());
		} finally {
			// Fecha o statement, independentemente do resultado da operação
			DB.closeStatement(st);
		}

	}

	@Override
	public void deleteById(Integer id) {
		// TODO Auto-generated method stub

	}

	@Override
	public List<Seller> findAll() {
		PreparedStatement st = null;
		ResultSet rs = null;
		try {
			// cria um objeto PreparedStatement com uma query sql para obter os dados dos
			// vendedores de acordo com o departamento
			st = conn.prepareStatement(
					"SELECT seller.*,department.Name as DepName " + "FROM seller INNER JOIN department "
							+ "ON seller.DepartmentId = department.Id " + "ORDER BY Name");

			// executa a query sql e armazena o resultado no objeto ResultSet
			rs = st.executeQuery();

			List<Seller> list = new ArrayList<>(); // cria uma lista de Seller
			Map<Integer, Department> map = new HashMap<>(); // cria um mapa para armazenar os objetos Department

			// enquanto houver dados no ResultSet
			while (rs.next()) {

				Department dep = map.get(rs.getInt("DepartmentId")); // obtém o objeto Department no mapa

				// se o mapa não tiver um objeto Department para o id obtido
				if (dep == null) {
					// cria um objeto Department a partir dos dados no ResultSet
					dep = instantiateDepartment(rs);
					// armazena o objeto Department no mapa
					map.put(rs.getInt("DepartmentId"), dep);
				}

				// cria um objeto Seller a partir dos dados no ResutSet
				Seller obj = instantiateSeller(rs, dep);
				list.add(obj); // adiciona o objeto Seller à lista
			}
			return list; // retorna a lista de Seller
		} catch (SQLException e) {
			throw new DbException(e.getMessage());
		} finally {
			DB.closeStatement(st); // fecha o objeto PreparedStatement
			DB.closeResultSet(rs); // fecha o objeto ResultSet
		}
	}

	// Método que retorna uma lista de vendedores de acordo com o DEPARTAMENTO
	@Override
	public List<Seller> findByDepartment(Department department) {
		PreparedStatement st = null;
		ResultSet rs = null;
		try {
			// cria um objeto PreparedStatement com uma query sql para obter os dados dos
			// vendedores de acordo com o departamento
			st = conn.prepareStatement(
					"SELECT seller.*,department.Name as DepName " + "FROM seller INNER JOIN department "
							+ "ON seller.DepartmentId = department.Id " + "WHERE DepartmentId = ? " + "ORDER BY Name");

			// define o parâmetro da query sql
			st.setInt(1, department.getId());
			// executa a query sql e armazena o resultado no objeto ResultSet
			rs = st.executeQuery();

			List<Seller> list = new ArrayList<>(); // cria uma lista de Seller
			Map<Integer, Department> map = new HashMap<>(); // cria um mapa para armazenar os objetos Department

			// enquanto houver dados no ResultSet
			while (rs.next()) {

				Department dep = map.get(rs.getInt("DepartmentId")); // obtém o objeto Department no mapa

				// se o mapa não tiver um objeto Department para o id obtido
				if (dep == null) {
					// cria um objeto Department a partir dos dados no ResultSet
					dep = instantiateDepartment(rs);
					// armazena o objeto Department no mapa
					map.put(rs.getInt("DepartmentId"), dep);
				}

				// cria um objeto Seller a partir dos dados no ResutSet
				Seller obj = instantiateSeller(rs, dep);
				list.add(obj); // adiciona o objeto Seller à lista
			}
			return list; // retorna a lista de Seller
		} catch (SQLException e) {
			throw new DbException(e.getMessage());
		} finally {
			DB.closeStatement(st); // fecha o objeto PreparedStatement
			DB.closeResultSet(rs); // fecha o objeto ResultSet
		}
	}
}
 


===================================================================================================================== 
  delete implementation
package model.dao.impl;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import db.DB;
import db.DbException;
import model.dao.SellerDao;
import model.entities.Department;
import model.entities.Seller;

public class SellerDaoJDBC implements SellerDao {

	// Cria a conexão com o banco de dados
	private Connection conn;

	public SellerDaoJDBC(Connection conn) {
		this.conn = conn;
	}

	// Método que retorna um vendedor de acordo com o id
	@Override
	public Seller findById(Integer id) {
		PreparedStatement st = null; // declara uma variavél st que armazenará o objeto PreparedStatement
		ResultSet rs = null; // declara uma variável rs que armazena o objeto ResultSet
		try {
			// cria um objeto PreparedStatement com uma query sql para obter os dados do
			// vendedor de acordo com o id
			st = conn.prepareStatement(
					"SELECT seller.*,department.Name as DepName " + "FROM seller INNER JOIN department "
							+ "ON seller.DepartmentId = department.Id " + "WHERE seller.Id = ?");

			// define o parâmetro da query sql
			st.setInt(1, id);
			// executa a query sql e armazena o resultado no objeto ResultSet
			rs = st.executeQuery();
			if (rs.next()) { // se conseguiu obter os dados
				// cria um objeto Department a partir dos dados no ResultSet
				Department dep = instantiateDepartment(rs);
				// cria um objeto Seller a partir dos dados no ResutSet
				Seller obj = instantiateSeller(rs, dep);
				return obj; // retorna o objeto Seller criado
			}
			return null; // caso contrário retorna null
		} catch (SQLException e) {
			throw new DbException(e.getMessage());
		} finally {
			DB.closeStatement(st); // fecha o objeto PreparedStatement
			DB.closeResultSet(rs); // fecha o objeto ResultSet
		}
	}

	// cria um objeto Department a partir dos dados no ResultSet
	private Department instantiateDepartment(ResultSet rs) throws SQLException {
		Department dep = new Department();
		dep.setId(rs.getInt("DepartmentId"));
		dep.setName(rs.getString("DepName"));
		return dep;
	}

	// cria um objeto Seller a partir dos dados no ResutSet
	private Seller instantiateSeller(ResultSet rs, Department dep) throws SQLException {
		Seller obj = new Seller();
		obj.setId(rs.getInt("Id"));
		obj.setName(rs.getString("Name"));
		obj.setEmail(rs.getString("Email"));
		obj.setBaseSalary(rs.getDouble("BaseSalary"));
		obj.setBirthDate(rs.getDate("BirthDate"));
		obj.setDepartment(dep);
		return obj;
	}

	@Override
	public void insert(Seller obj) {
		PreparedStatement st = null;
		try {
			// Cria a instrução SQL para inserir um vendedor na tabela seller
			st = conn.prepareStatement("INSERT INTO seller " + "(Name, Email, BirthDate, BaseSalary, DepartmentId) "
					+ "VALUES " + "(?, ?, ?, ?, ?)", Statement.RETURN_GENERATED_KEYS);

			// Define os valores para os parâmetros da instrução SQL
			st.setString(1, obj.getName());
			st.setString(2, obj.getEmail());
			st.setDate(3, new java.sql.Date(obj.getBirthDate().getTime()));
			st.setDouble(4, obj.getBaseSalary());
			st.setInt(5, obj.getDepartment().getId());

			// Executa a instrução SQL e verifica se alguma linha foi afetada
			int rowsAffected = st.executeUpdate();

			if (rowsAffected > 0) {
				// Se sim, recupera o id gerado automaticamente pelo banco de dados
				ResultSet rs = st.getGeneratedKeys();
				if (rs.next()) {
					int id = rs.getInt(1);
					obj.setId(id);
				}
				// Fecha o result set
				DB.closeResultSet(rs);
			} else {
				// Se não, lança uma exceção
				throw new DbException("Erro inesperado! Nenhuma linha foi afetada! ");
			}
		} catch (SQLException e) {
			// Lança uma exceção com a mensagem de erro da exceção SQL
			throw new DbException(e.getMessage());
		} finally {
			// Fecha o statement, independentemente do resultado da operação
			DB.closeStatement(st);
		}
	}

	@Override
	public void update(Seller obj) {
		PreparedStatement st = null;
		try {
			// Cria a instrução SQL para inserir um vendedor na tabela seller
			st = conn.prepareStatement("UPDATE seller "
					+ "SET Name = ?, Email = ?, BirthDate = ?, BaseSalary = ?, DepartmentId = ? " + "WHERE Id = ? ");

			// Define os valores para os parâmetros da instrução SQL
			st.setString(1, obj.getName());
			st.setString(2, obj.getEmail());
			st.setDate(3, new java.sql.Date(obj.getBirthDate().getTime()));
			st.setDouble(4, obj.getBaseSalary());
			st.setInt(5, obj.getDepartment().getId());
			st.setInt(6, obj.getId());

			// Executa a instrução
			st.executeUpdate();

		} catch (SQLException e) {
			// Lança uma exceção com a mensagem de erro da exceção SQL
			throw new DbException(e.getMessage());
		} finally {
			// Fecha o statement, independentemente do resultado da operação
			DB.closeStatement(st);
		}

	}

	@Override
	// Deleta o vendedor pelo ID
	public void deleteById(Integer id) {
		// Prepara o statement para a query
		PreparedStatement st = null;
		try {
			// Query para deletar o vendedor
			st = conn.prepareStatement("DELETE FROM seller WHERE Id = ?");

			// Atribui o valor do ID ao statement
			st.setInt(1, id);

			// Executa a query
			st.executeUpdate();
		} catch (SQLException e) {
			// Lança uma exceção caso haja algum erro
			throw new DbException(e.getMessage());
		} finally {
			// Fecha o statement
			DB.closeStatement(st);
		}
	}

	@Override
	public List<Seller> findAll() {
		PreparedStatement st = null;
		ResultSet rs = null;
		try {
			// cria um objeto PreparedStatement com uma query sql para obter os dados dos
			// vendedores de acordo com o departamento
			st = conn.prepareStatement(
					"SELECT seller.*,department.Name as DepName " + "FROM seller INNER JOIN department "
							+ "ON seller.DepartmentId = department.Id " + "ORDER BY Name");

			// executa a query sql e armazena o resultado no objeto ResultSet
			rs = st.executeQuery();

			List<Seller> list = new ArrayList<>(); // cria uma lista de Seller
			Map<Integer, Department> map = new HashMap<>(); // cria um mapa para armazenar os objetos Department

			// enquanto houver dados no ResultSet
			while (rs.next()) {

				Department dep = map.get(rs.getInt("DepartmentId")); // obtém o objeto Department no mapa

				// se o mapa não tiver um objeto Department para o id obtido
				if (dep == null) {
					// cria um objeto Department a partir dos dados no ResultSet
					dep = instantiateDepartment(rs);
					// armazena o objeto Department no mapa
					map.put(rs.getInt("DepartmentId"), dep);
				}

				// cria um objeto Seller a partir dos dados no ResutSet
				Seller obj = instantiateSeller(rs, dep);
				list.add(obj); // adiciona o objeto Seller à lista
			}
			return list; // retorna a lista de Seller
		} catch (SQLException e) {
			throw new DbException(e.getMessage());
		} finally {
			DB.closeStatement(st); // fecha o objeto PreparedStatement
			DB.closeResultSet(rs); // fecha o objeto ResultSet
		}
	}

	// Método que retorna uma lista de vendedores de acordo com o DEPARTAMENTO
	@Override
	public List<Seller> findByDepartment(Department department) {
		PreparedStatement st = null;
		ResultSet rs = null;
		try {
			// cria um objeto PreparedStatement com uma query sql para obter os dados dos
			// vendedores de acordo com o departamento
			st = conn.prepareStatement(
					"SELECT seller.*,department.Name as DepName " + "FROM seller INNER JOIN department "
							+ "ON seller.DepartmentId = department.Id " + "WHERE DepartmentId = ? " + "ORDER BY Name");

			// define o parâmetro da query sql
			st.setInt(1, department.getId());
			// executa a query sql e armazena o resultado no objeto ResultSet
			rs = st.executeQuery();

			List<Seller> list = new ArrayList<>(); // cria uma lista de Seller
			Map<Integer, Department> map = new HashMap<>(); // cria um mapa para armazenar os objetos Department

			// enquanto houver dados no ResultSet
			while (rs.next()) {

				Department dep = map.get(rs.getInt("DepartmentId")); // obtém o objeto Department no mapa

				// se o mapa não tiver um objeto Department para o id obtido
				if (dep == null) {
					// cria um objeto Department a partir dos dados no ResultSet
					dep = instantiateDepartment(rs);
					// armazena o objeto Department no mapa
					map.put(rs.getInt("DepartmentId"), dep);
				}

				// cria um objeto Seller a partir dos dados no ResutSet
				Seller obj = instantiateSeller(rs, dep);
				list.add(obj); // adiciona o objeto Seller à lista
			}
			return list; // retorna a lista de Seller
		} catch (SQLException e) {
			throw new DbException(e.getMessage());
		} finally {
			DB.closeStatement(st); // fecha o objeto PreparedStatement
			DB.closeResultSet(rs); // fecha o objeto ResultSet
		}
	}
}
 


===================================================================================================================== 
  DepartmentDao implementation
package model.dao.impl;

//Importações necessárias
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import db.DB;
import db.DbException;
import db.DbIntegrityException;
import model.dao.DepartmentDao;
import model.entities.Department;

public class DepartmentDaoJDBC implements DepartmentDao { //Classe que implementa o DAO do  Department

	private Connection conn;
	
	public DepartmentDaoJDBC(Connection conn) { //Construtor que recebe uma conexão
		this.conn = conn;
	}
	
	@Override
	public Department findById(Integer id) { //Método para buscar um departmento por Id
		PreparedStatement st = null;
		ResultSet rs = null;
		try {
			st = conn.prepareStatement( //Prepara a query para buscar o departmento
				"SELECT * FROM department WHERE Id = ?");
			st.setInt(1, id);
			rs = st.executeQuery();
			if (rs.next()) { //Se encontrar o departmento
				Department obj = new Department(); //Cria um novo departmento
				obj.setId(rs.getInt("Id")); //Seta os atributos
				obj.setName(rs.getString("Name"));
				return obj; //Retorna o objeto
			}
			return null;
		}
		catch (SQLException e) {
			throw new DbException(e.getMessage());
		}
		finally {
			DB.closeStatement(st);
			DB.closeResultSet(rs);
		}
	}

	@Override
	public List<Department> findAll() { //Método para buscar todos os departments
		PreparedStatement st = null;
		ResultSet rs = null;
		try {
			st = conn.prepareStatement( //Prepara a query para buscar todos os departments
				"SELECT * FROM department ORDER BY Name");
			rs = st.executeQuery();

			List<Department> list = new ArrayList<>(); //Cria uma lista de departments

			while (rs.next()) {
				Department obj = new Department(); //Cria um novo departmento
				obj.setId(rs.getInt("Id")); //Seta os atributos
				obj.setName(rs.getString("Name"));
				list.add(obj); //Adiciona o objeto a lista
			}
			return list;
		}
		catch (SQLException e) {
			throw new DbException(e.getMessage());
		}
		finally {
			DB.closeStatement(st);
			DB.closeResultSet(rs);
		}
	}

	@Override
	public void insert(Department obj) { //Método para inserir um novo departmento
		PreparedStatement st = null;
		try {
			st = conn.prepareStatement(
				"INSERT INTO department " +
				"(Name) " +
				"VALUES " +
				"(?)", 
				Statement.RETURN_GENERATED_KEYS);

			st.setString(1, obj.getName()); //Seta o nome do departmento

			int rowsAffected = st.executeUpdate();
			
			if (rowsAffected > 0) {
				ResultSet rs = st.getGeneratedKeys();
				if (rs.next()) {
					int id = rs.getInt(1); //Pega o Id do departmento
					obj.setId(id); //Seta o Id no objeto
				}
			}
			else {
				throw new DbException("Unexpected error! No rows affected!");
			}
		}
		catch (SQLException e) {
			throw new DbException(e.getMessage());
		} 
		finally {
			DB.closeStatement(st);
		}
	}

	@Override
	public void update(Department obj) { //Método para atualizar um departmento
		PreparedStatement st = null;
		try {
			st = conn.prepareStatement(
				"UPDATE department " +
				"SET Name = ? " +
				"WHERE Id = ?");

			st.setString(1, obj.getName()); //Seta o novo nome do departmento
			st.setInt(2, obj.getId()); //Seta o Id do departmento

			st.executeUpdate();
		}
		catch (SQLException e) {
			throw new DbException(e.getMessage());
		} 
		finally {
			DB.closeStatement(st);
		}
	}

	@Override
	public void deleteById(Integer id) { //Método para deletar um departmento
		PreparedStatement st = null;
		try {
			st = conn.prepareStatement(
				"DELETE FROM department WHERE Id = ?");

			st.setInt(1, id); //Seta o Id do departmento

			st.executeUpdate();
		}
		catch (SQLException e) {
			throw new DbIntegrityException(e.getMessage());
		} 
		finally {
			DB.closeStatement(st);
		}
	}
}

 


===================================================================================================================== 
  IMPLEMENTAÇÃO FINAL DO PROJETO DEMO-DAO-JDBC
 
 
 
 
user=root
password=senha@123
dburl=jdbc:mysql://localhost:3306/coursejdbc
useSSL=false

package model.entities;

import java.io.Serializable;
import java.util.Date;
import java.util.Objects;

public class Seller implements Serializable {

	// ID da classe para uso do serializable
	private static final long serialVersionUID = 1L;

	// Atributos da classe Seller
	private Integer id;
	private String name;
	private String email;
	private Date birthDate;
	private Double baseSalary;

	/*
	 * A composição está presente na classe Seller, na propriedade
	 * "Department department". Isso significa que a classe Seller tem uma instância
	 * da classe Department. Isso ocorre porque existe uma relação entre um vendedor
	 * e um departamento, onde um vendedor pertence a um departamento.
	 * 
	 * A composição é importante porque permite que a classe Seller tenha acesso aos
	 * atributos e métodos da classe Department, e também permite que sejam feitas
	 * relações entre objetos de classes diferentes, tornando a modelagem do sistema
	 * mais organizada e coerente. Além disso, a composição fornece flexibilidade
	 * para modificar a classe Department sem afetar a classe Seller, o que facilita
	 * a manutenção do código.
	 */
	private Department department;

	// Construtor padrão
	public Seller() {
	}

	// Construtor com todos os atributos
	public Seller(Integer id, String name, String email, Date birthDate, Double baseSalary, Department department) {
		this.id = id;
		this.name = name;
		this.email = email;
		this.birthDate = birthDate;
		this.baseSalary = baseSalary;
		this.department = department;
	}

	// Métodos getters e setters para todos os atributos
	public Integer getId() {
		return id;
	}

	public void setId(Integer id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	public Date getBirthDate() {
		return birthDate;
	}

	public void setBirthDate(Date birthDate) {
		this.birthDate = birthDate;
	}

	public Double getBaseSalary() {
		return baseSalary;
	}

	public void setBaseSalary(Double baseSalary) {
		this.baseSalary = baseSalary;
	}

	public Department getDepartment() {
		return department;
	}

	public void setDepartment(Department department) {
		this.department = department;
	}

	// Implementação do método hashCode
	@Override
	public int hashCode() {
		return Objects.hash(id);
	}

	// Implementação do método equals
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Seller other = (Seller) obj;
		return Objects.equals(id, other.id);
	}

	// Implementação do método toString
	@Override
	public String toString() {
		return "Seller [id=" + id + ", name=" + name + ", email=" + email + ", birthDate=" + birthDate + ", baseSalary="
				+ baseSalary + ", department=" + department + "]";
	}
}

package model.entities;

import java.io.Serializable;
import java.util.Objects;

// Classe que representa um departamento
public class Department implements Serializable {

	private static final long serialVersionUID = 1L;

	// Id do departamento
	private Integer id;

	// Nome do departamento
	private String name;

	// Construtor vazio
	public Department() {
	}

	// Construtor com parâmetros
	public Department(Integer id, String name) {
		this.id = id;
		this.name = name;
	}

	// Getter para id do departamento
	public Integer getId() {
		return id;
	}

	// Setter para id do departamento
	public void setId(Integer id) {
		this.id = id;
	}

	// Getter para nome do departamento
	public String getName() {
		return name;
	}

	// Setter para nome do departamento
	public void setName(String name) {
		this.name = name;
	}

	// Método hashCode para id do departamento
	@Override
	public int hashCode() {
		return Objects.hash(id);
	}

	// Método equals para id do departamento
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Department other = (Department) obj;
		return Objects.equals(id, other.id);
	}

	// Representação string da classe
	@Override
	public String toString() {
		return "Department [id=" + id + ", name=" + name + "]";
	}
}

package model.dao.impl;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import db.DB;
import db.DbException;
import model.dao.SellerDao;
import model.entities.Department;
import model.entities.Seller;

public class SellerDaoJDBC implements SellerDao {

	// Cria a conexão com o banco de dados
	private Connection conn;

	public SellerDaoJDBC(Connection conn) {
		this.conn = conn;
	}

	// Método que retorna um vendedor de acordo com o id
	@Override
	public Seller findById(Integer id) {
		PreparedStatement st = null; // declara uma variavél st que armazenará o objeto PreparedStatement
		ResultSet rs = null; // declara uma variável rs que armazena o objeto ResultSet
		try {
			// cria um objeto PreparedStatement com uma query sql para obter os dados do
			// vendedor de acordo com o id
			st = conn.prepareStatement(
					"SELECT seller.*,department.Name as DepName " + "FROM seller INNER JOIN department "
							+ "ON seller.DepartmentId = department.Id " + "WHERE seller.Id = ?");

			// define o parâmetro da query sql
			st.setInt(1, id);
			// executa a query sql e armazena o resultado no objeto ResultSet
			rs = st.executeQuery();
			if (rs.next()) { // se conseguiu obter os dados
				// cria um objeto Department a partir dos dados no ResultSet
				Department dep = instantiateDepartment(rs);
				// cria um objeto Seller a partir dos dados no ResutSet
				Seller obj = instantiateSeller(rs, dep);
				return obj; // retorna o objeto Seller criado
			}
			return null; // caso contrário retorna null
		} catch (SQLException e) {
			throw new DbException(e.getMessage());
		} finally {
			DB.closeStatement(st); // fecha o objeto PreparedStatement
			DB.closeResultSet(rs); // fecha o objeto ResultSet
		}
	}

	// cria um objeto Department a partir dos dados no ResultSet
	private Department instantiateDepartment(ResultSet rs) throws SQLException {
		Department dep = new Department();
		dep.setId(rs.getInt("DepartmentId"));
		dep.setName(rs.getString("DepName"));
		return dep;
	}

	// cria um objeto Seller a partir dos dados no ResutSet
	private Seller instantiateSeller(ResultSet rs, Department dep) throws SQLException {
		Seller obj = new Seller();
		obj.setId(rs.getInt("Id"));
		obj.setName(rs.getString("Name"));
		obj.setEmail(rs.getString("Email"));
		obj.setBaseSalary(rs.getDouble("BaseSalary"));
		obj.setBirthDate(rs.getDate("BirthDate"));
		obj.setDepartment(dep);
		return obj;
	}

	@Override
	public void insert(Seller obj) {
		PreparedStatement st = null;
		try {
			// Cria a instrução SQL para inserir um vendedor na tabela seller
			st = conn.prepareStatement("INSERT INTO seller " + "(Name, Email, BirthDate, BaseSalary, DepartmentId) "
					+ "VALUES " + "(?, ?, ?, ?, ?)", Statement.RETURN_GENERATED_KEYS);

			// Define os valores para os parâmetros da instrução SQL
			st.setString(1, obj.getName());
			st.setString(2, obj.getEmail());
			st.setDate(3, new java.sql.Date(obj.getBirthDate().getTime()));
			st.setDouble(4, obj.getBaseSalary());
			st.setInt(5, obj.getDepartment().getId());

			// Executa a instrução SQL e verifica se alguma linha foi afetada
			int rowsAffected = st.executeUpdate();

			if (rowsAffected > 0) {
				// Se sim, recupera o id gerado automaticamente pelo banco de dados
				ResultSet rs = st.getGeneratedKeys();
				if (rs.next()) {
					int id = rs.getInt(1);
					obj.setId(id);
				}
				// Fecha o result set
				DB.closeResultSet(rs);
			} else {
				// Se não, lança uma exceção
				throw new DbException("Erro inesperado! Nenhuma linha foi afetada! ");
			}
		} catch (SQLException e) {
			// Lança uma exceção com a mensagem de erro da exceção SQL
			throw new DbException(e.getMessage());
		} finally {
			// Fecha o statement, independentemente do resultado da operação
			DB.closeStatement(st);
		}
	}

	@Override
	public void update(Seller obj) {
		PreparedStatement st = null;
		try {
			// Cria a instrução SQL para inserir um vendedor na tabela seller
			st = conn.prepareStatement("UPDATE seller "
					+ "SET Name = ?, Email = ?, BirthDate = ?, BaseSalary = ?, DepartmentId = ? " + "WHERE Id = ? ");

			// Define os valores para os parâmetros da instrução SQL
			st.setString(1, obj.getName());
			st.setString(2, obj.getEmail());
			st.setDate(3, new java.sql.Date(obj.getBirthDate().getTime()));
			st.setDouble(4, obj.getBaseSalary());
			st.setInt(5, obj.getDepartment().getId());
			st.setInt(6, obj.getId());

			// Executa a instrução
			st.executeUpdate();

		} catch (SQLException e) {
			// Lança uma exceção com a mensagem de erro da exceção SQL
			throw new DbException(e.getMessage());
		} finally {
			// Fecha o statement, independentemente do resultado da operação
			DB.closeStatement(st);
		}

	}

	@Override
	// Deleta o vendedor pelo ID
	public void deleteById(Integer id) {
		// Prepara o statement para a query
		PreparedStatement st = null;
		try {
			// Query para deletar o vendedor
			st = conn.prepareStatement("DELETE FROM seller WHERE Id = ?");

			// Atribui o valor do ID ao statement
			st.setInt(1, id);

			// Executa a query
			st.executeUpdate();
		} catch (SQLException e) {
			// Lança uma exceção caso haja algum erro
			throw new DbException(e.getMessage());
		} finally {
			// Fecha o statement
			DB.closeStatement(st);
		}
	}

	@Override
	public List<Seller> findAll() {
		PreparedStatement st = null;
		ResultSet rs = null;
		try {
			// cria um objeto PreparedStatement com uma query sql para obter os dados dos
			// vendedores de acordo com o departamento
			st = conn.prepareStatement(
					"SELECT seller.*,department.Name as DepName " + "FROM seller INNER JOIN department "
							+ "ON seller.DepartmentId = department.Id " + "ORDER BY Name");

			// executa a query sql e armazena o resultado no objeto ResultSet
			rs = st.executeQuery();

			List<Seller> list = new ArrayList<>(); // cria uma lista de Seller
			Map<Integer, Department> map = new HashMap<>(); // cria um mapa para armazenar os objetos Department

			// enquanto houver dados no ResultSet
			while (rs.next()) {

				Department dep = map.get(rs.getInt("DepartmentId")); // obtém o objeto Department no mapa

				// se o mapa não tiver um objeto Department para o id obtido
				if (dep == null) {
					// cria um objeto Department a partir dos dados no ResultSet
					dep = instantiateDepartment(rs);
					// armazena o objeto Department no mapa
					map.put(rs.getInt("DepartmentId"), dep);
				}

				// cria um objeto Seller a partir dos dados no ResutSet
				Seller obj = instantiateSeller(rs, dep);
				list.add(obj); // adiciona o objeto Seller à lista
			}
			return list; // retorna a lista de Seller
		} catch (SQLException e) {
			throw new DbException(e.getMessage());
		} finally {
			DB.closeStatement(st); // fecha o objeto PreparedStatement
			DB.closeResultSet(rs); // fecha o objeto ResultSet
		}
	}

	// Método que retorna uma lista de vendedores de acordo com o DEPARTAMENTO
	@Override
	public List<Seller> findByDepartment(Department department) {
		PreparedStatement st = null;
		ResultSet rs = null;
		try {
			// cria um objeto PreparedStatement com uma query sql para obter os dados dos
			// vendedores de acordo com o departamento
			st = conn.prepareStatement(
					"SELECT seller.*,department.Name as DepName " + "FROM seller INNER JOIN department "
							+ "ON seller.DepartmentId = department.Id " + "WHERE DepartmentId = ? " + "ORDER BY Name");

			// define o parâmetro da query sql
			st.setInt(1, department.getId());
			// executa a query sql e armazena o resultado no objeto ResultSet
			rs = st.executeQuery();

			List<Seller> list = new ArrayList<>(); // cria uma lista de Seller
			Map<Integer, Department> map = new HashMap<>(); // cria um mapa para armazenar os objetos Department

			// enquanto houver dados no ResultSet
			while (rs.next()) {

				Department dep = map.get(rs.getInt("DepartmentId")); // obtém o objeto Department no mapa

				// se o mapa não tiver um objeto Department para o id obtido
				if (dep == null) {
					// cria um objeto Department a partir dos dados no ResultSet
					dep = instantiateDepartment(rs);
					// armazena o objeto Department no mapa
					map.put(rs.getInt("DepartmentId"), dep);
				}

				// cria um objeto Seller a partir dos dados no ResutSet
				Seller obj = instantiateSeller(rs, dep);
				list.add(obj); // adiciona o objeto Seller à lista
			}
			return list; // retorna a lista de Seller
		} catch (SQLException e) {
			throw new DbException(e.getMessage());
		} finally {
			DB.closeStatement(st); // fecha o objeto PreparedStatement
			DB.closeResultSet(rs); // fecha o objeto ResultSet
		}
	}
}
package model.dao.impl;

//Importações necessárias
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import db.DB;
import db.DbException;
import db.DbIntegrityException;
import model.dao.DepartmentDao;
import model.entities.Department;

public class DepartmentDaoJDBC implements DepartmentDao { //Classe que implementa o DAO do  Department

	private Connection conn;
	
	public DepartmentDaoJDBC(Connection conn) { //Construtor que recebe uma conexão
		this.conn = conn;
	}
	
	@Override
	public Department findById(Integer id) { //Método para buscar um departmento por Id
		PreparedStatement st = null;
		ResultSet rs = null;
		try {
			st = conn.prepareStatement( //Prepara a query para buscar o departmento
				"SELECT * FROM department WHERE Id = ?");
			st.setInt(1, id);
			rs = st.executeQuery();
			if (rs.next()) { //Se encontrar o departmento
				Department obj = new Department(); //Cria um novo departmento
				obj.setId(rs.getInt("Id")); //Seta os atributos
				obj.setName(rs.getString("Name"));
				return obj; //Retorna o objeto
			}
			return null;
		}
		catch (SQLException e) {
			throw new DbException(e.getMessage());
		}
		finally {
			DB.closeStatement(st);
			DB.closeResultSet(rs);
		}
	}

	@Override
	public List<Department> findAll() { //Método para buscar todos os departments
		PreparedStatement st = null;
		ResultSet rs = null;
		try {
			st = conn.prepareStatement( //Prepara a query para buscar todos os departments
				"SELECT * FROM department ORDER BY Name");
			rs = st.executeQuery();

			List<Department> list = new ArrayList<>(); //Cria uma lista de departments

			while (rs.next()) {
				Department obj = new Department(); //Cria um novo departmento
				obj.setId(rs.getInt("Id")); //Seta os atributos
				obj.setName(rs.getString("Name"));
				list.add(obj); //Adiciona o objeto a lista
			}
			return list;
		}
		catch (SQLException e) {
			throw new DbException(e.getMessage());
		}
		finally {
			DB.closeStatement(st);
			DB.closeResultSet(rs);
		}
	}

	@Override
	public void insert(Department obj) { //Método para inserir um novo departmento
		PreparedStatement st = null;
		try {
			st = conn.prepareStatement(
				"INSERT INTO department " +
				"(Name) " +
				"VALUES " +
				"(?)", 
				Statement.RETURN_GENERATED_KEYS);

			st.setString(1, obj.getName()); //Seta o nome do departmento

			int rowsAffected = st.executeUpdate();
			
			if (rowsAffected > 0) {
				ResultSet rs = st.getGeneratedKeys();
				if (rs.next()) {
					int id = rs.getInt(1); //Pega o Id do departmento
					obj.setId(id); //Seta o Id no objeto
				}
			}
			else {
				throw new DbException("Unexpected error! No rows affected!");
			}
		}
		catch (SQLException e) {
			throw new DbException(e.getMessage());
		} 
		finally {
			DB.closeStatement(st);
		}
	}

	@Override
	public void update(Department obj) { //Método para atualizar um departmento
		PreparedStatement st = null;
		try {
			st = conn.prepareStatement(
				"UPDATE department " +
				"SET Name = ? " +
				"WHERE Id = ?");

			st.setString(1, obj.getName()); //Seta o novo nome do departmento
			st.setInt(2, obj.getId()); //Seta o Id do departmento

			st.executeUpdate();
		}
		catch (SQLException e) {
			throw new DbException(e.getMessage());
		} 
		finally {
			DB.closeStatement(st);
		}
	}

	@Override
	public void deleteById(Integer id) { //Método para deletar um departmento
		PreparedStatement st = null;
		try {
			st = conn.prepareStatement(
				"DELETE FROM department WHERE Id = ?");

			st.setInt(1, id); //Seta o Id do departmento

			st.executeUpdate();
		}
		catch (SQLException e) {
			throw new DbIntegrityException(e.getMessage());
		} 
		finally {
			DB.closeStatement(st);
		}
	}
}

package model.dao;

import java.util.List;

import model.entities.Department;
import model.entities.Seller;

/**
 * Interface que representa as operações de persistência para objetos do tipo
 * Seller.
 */
public interface SellerDao {

	/**
	 * Insere um objeto do tipo Seller no banco de dados.
	 * 
	 * @param obj Objeto do tipo Seller a ser inserido.
	 */
	void insert(Seller obj);

	/**
	 * Atualiza as informações de um objeto do tipo Seller no banco de dados.
	 * 
	 * @param obj Objeto do tipo Seller com as informações atualizadas.
	 */
	void update(Seller obj);

	/**
	 * Remove um objeto do tipo Seller do banco de dados, a partir do seu id.
	 * 
	 * @param id Id do objeto a ser removido.
	 */
	void deleteById(Integer id);

	/**
	 * Busca um objeto do tipo Seller no banco de dados, a partir do seu id.
	 * 
	 * @param id Id do objeto a ser buscado.
	 * @return O objeto do tipo Seller encontrado.
	 */
	Seller findById(Integer id);

	/**
	 * Busca todos os objetos do tipo Seller no banco de dados.
	 * 
	 * @return Lista de objetos do tipo Seller encontrados.
	 */
	List<Seller> findAll();
	List<Seller> findByDepartment(Department department);
}
// Arquivo DepartmentDao.java

// Declaração do pacote model.dao
package model.dao;

// Importação da classe List do pacote java.util
import java.util.List;

// Importação da classe Department do pacote model.entities
import model.entities.Department;

/**
 * Interface DepartmentDao que contém métodos para manipular objetos Department
 * no banco de dados.
 */
public interface DepartmentDao {

	/**
	 * Insere um objeto Department no banco de dados.
	 * 
	 * @param obj Objeto Department a ser inserido.
	 */
	void insert(Department obj);

	/**
	 * Atualiza um objeto Department no banco de dados.
	 * 
	 * @param obj Objeto Department a ser atualizado.
	 */
	void update(Department obj);

	/**
	 * Remove um objeto Department do banco de dados a partir do seu ID.
	 * 
	 * @param id ID do objeto Department a ser removido.
	 */
	void deleteById(Integer id);

	/**
	 * Busca um objeto Department no banco de dados a partir do seu ID.
	 * 
	 * @param id ID do objeto Department a ser buscado.
	 * @return O objeto Department encontrado.
	 */
	Department findById(Integer id);

	/**
	 * Retorna uma lista com todos os objetos Department do banco de dados.
	 * 
	 * @return Uma lista com todos os objetos Department.
	 */
	List<Department> findAll();
}

package model.dao;

//package model.dao; - Declaração de pacote
import db.DB; // Importação da classe DB
import model.dao.impl.DepartmentDaoJDBC; // Importação da classe DepartmentDaoJDBC
import model.dao.impl.SellerDaoJDBC; // Importação da classe SellerDaoJDBC

public class DaoFactory { // Declaração da classe DaoFactory

	// Método para criar um SellerDao
	public static SellerDao createSellerDao() {
		// Retorna uma instância de SellerDaoJDBC com a conexão do BD
		return new SellerDaoJDBC(DB.getConnection());
	}

	// Método para criar um DepartmentDao
	public static DepartmentDao createDepartmentDao() {
		// Retorna uma instância de Department
		return new DepartmentDaoJDBC(DB.getConnection());
	}
	/*
	 * A classe DaoFactory é uma classe de fábrica responsável por fornecer uma
	 * instância de um objeto que implementa a interface SellerDao. A importância
	 * desta classe é centralizar a criação de objetos, permitindo a mudança da
	 * implementação de uma interface sem afetar o resto da aplicação. Isso também
	 * ajuda a manter o código mais organizado e facilitar futuras manutenções, já
	 * que a criação de objetos fica concentrada em uma única classe.
	 */
}

package db;

public class DbIntegrityException extends RuntimeException {
    private static final long serialVersionUID = 1L;

    // Construtor que recebe uma mensagem de erro
    public DbIntegrityException(String msg) {
        // Passa a mensagem de erro para o construtor da classe mãe (RuntimeException)
        super(msg);
    }
}


package db;

public class DbException extends RuntimeException {
    private static final long serialVersionUID = 1L;

    // Construtor que recebe uma mensagem de erro
    public DbException(String msg) {
        // Passa a mensagem de erro para o construtor da classe mãe (RuntimeException)
        super(msg);
    }
}


// Este é um código Java para uma classe "DB" que representa uma conexão com um banco de dados
package db;

import java.io.FileInputStream;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

public class DB {
// Propriedade estática para armazenar a conexão com o banco de dados
	private static Connection conn = null;

// Método para obter uma conexão com o banco de dados
	public static Connection getConnection() {
		// Verifica se a conexão já foi estabelecida
		if (conn == null) {
			try {
				// Carrega as propriedades de conexão a partir do arquivo db.properties
				Properties props = loadProperties();
				String url = props.getProperty("dburl");

				// Obtém a conexão com o banco de dados
				conn = DriverManager.getConnection(url, props);
			} catch (SQLException e) {
				// Lança uma exceção personalizada caso ocorra uma exceção de banco de dados
				throw new DbException(e.getMessage());
			}
		}
		// Retorna a conexão com o banco de dados
		return conn;
	}

// Método para fechar a conexão com o banco de dados
	public static void closeConnection() {
		// Verifica se a conexão está aberta
		if (conn != null) {
			try {
				// Fecha a conexão com o banco de dados
				conn.close();
			} catch (SQLException e) {
				// Lança uma exceção personalizada caso ocorra uma exceção de banco de dados
				throw new DbException(e.getMessage());
			}
		}
	}

// Método para carregar as propriedades de conexão a partir do arquivo db.properties
	private static Properties loadProperties() {
		try (FileInputStream fs = new FileInputStream("db.properties")) {
			Properties props = new Properties();
			props.load(fs);
			return props;
		} catch (IOException e) {
			// Lança uma exceção personalizada caso ocorra uma exceção de entrada/saída
			throw new DbException(e.getMessage());
		}
	}

// Método para fechar um objeto "Statement"
	public static void closeStatement(Statement st) {
		if (st != null) {
			try {
				st.close();
			} catch (SQLException e) {
// Lança uma exceção personalizada "DbException" caso haja erro ao fechar o statement
				throw new DbException(e.getMessage());
			}
		}
	}

// Método para fechar um objeto "ResultSet"
	public static void closeResultSet(ResultSet rs) {
		if (rs != null) {
			try {
				rs.close();
			} catch (SQLException e) {
// Lança uma exceção personalizada "DbException" caso haja erro ao fechar o result set
				throw new DbException(e.getMessage());
			}
		}
	}
}
package application;

//Esta classe Program2 é responsável por testar as operações CRUD (Create, Read, Update e Delete)
//realizadas pelo objeto departmentDao, que é criado pela classe DaoFactory.

import java.util.List;
import java.util.Scanner;

import model.dao.DaoFactory;
import model.dao.DepartmentDao;
import model.entities.Department;

public class Program2 {

public static void main(String[] args) {

	Scanner sc = new Scanner(System.in);
	
	// Cria um objeto departmentDao, que é responsável por realizar as operações CRUD em uma tabela de departamentos.
	DepartmentDao departmentDao = DaoFactory.createDepartmentDao();

	System.out.println("=== TEST 1: findById =======");
	// Testa a operação de leitura (Read) do departamento com id 1.
	Department dep = departmentDao.findById(1);
	System.out.println(dep);
	
	System.out.println("\n=== TEST 2: findAll =======");
	// Testa a operação de leitura (Read) de todos os departamentos.
	List<Department> list = departmentDao.findAll();
	for (Department d : list) {
		System.out.println(d);
	}

	System.out.println("\n=== TEST 3: insert =======");
	// Testa a operação de criação (Create) de um novo departamento.
	Department newDepartment = new Department(null, "Music");
	departmentDao.insert(newDepartment);
	System.out.println("Inserted! New id: " + newDepartment.getId());

	System.out.println("\n=== TEST 4: update =======");
	// Testa a operação de atualização (Update) de um departamento existente.
	Department dep2 = departmentDao.findById(1);
	dep2.setName("Food");
	departmentDao.update(dep2);
	System.out.println("Update completed");
	
	System.out.println("\n=== TEST 5: delete =======");
	// Testa a operação de exclusão (Delete) de um departamento existente.
	System.out.print("Enter id for delete test: ");
	int id = sc.nextInt();
	departmentDao.deleteById(id);
	System.out.println("Delete completed");

	sc.close();
}
}

package application;

//Importa as classes necessárias para o programa
import java.util.Date;
import java.util.List;
import java.util.Scanner;

import model.dao.DaoFactory;
import model.dao.SellerDao;
import model.entities.Department;
import model.entities.Seller;

public class Program {

	public static void main(String[] args) {

		// Declara um objeto Scanner para ler os dados do teclado
		Scanner sc = new Scanner(System.in);

		// Instancia um objeto do tipo SellerDao
		SellerDao sellerDao = DaoFactory.createSellerDao();

		// Testa a operação findById
		System.out.println("=== TEST 1: seller findById =====");
		Seller seller = sellerDao.findById(3);
		System.out.println(seller);

		// Testa a operação findByDepartment
		System.out.println("\n=== TEST 2: seller findByDepartment =====");
		Department department = new Department(2, null);
		List<Seller> list = sellerDao.findByDepartment(department);
		for (Seller obj : list) {
			System.out.println(obj);
		}

		// Testa a operação findAll
		System.out.println("\n=== TEST 3: seller findAll =====");
		list = sellerDao.findAll();
		for (Seller obj : list) {
			System.out.println(obj);
		}

		// Testa a operação insert
		System.out.println("\n=== TEST 4: seller insert =====");
		Seller newSeller = new Seller(null, "Greg", "greg@gmail.com", new Date(), 4000.0, department);
		sellerDao.insert(newSeller);
		System.out.println("Inserted New id = " + newSeller.getId());

		// Testa a operação update
		System.out.println("\n=== TEST 5: seller update =====");
		seller = sellerDao.findById(1);
		seller.setName("Martha Waine");
		sellerDao.update(seller);
		System.out.println("Update completed");

		// Testa a operação delete
		System.out.println("\n=== TEST 6: seller delete =====");
		System.out.println("Enter id for delete test: ");
		int id = sc.nextInt();
		sellerDao.deleteById(id);
		System.out.println("Delete completed");

		// Fecha o objeto Scanner
		sc.close();
	}
}
